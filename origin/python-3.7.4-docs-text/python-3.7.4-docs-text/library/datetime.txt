"datetime" --- 基本的日期和时间类型
***********************************

**源代码：** Lib/datetime.py

======================================================================

"datetime"  模块提供了可以通过多种方式操作日期和时间的类。在支持日期时
间数学运算的同时，实现的关注点更着重于如何能够更有效地解析其属性用于格
式化输出和数据操作。相关功能可以参阅 "time" 和 "calendar"  模块。

有两种日期和时间的对象：天真型和觉悟型。

觉悟型对象有着用足以支持一些应用层面算法和国家层面时间调整的信息，例如
时区和夏令时，来让自己和其他的觉悟型对象区别开来。觉悟型对象是用来表达
不对解释器开放的特定时间信息 [1]。

天真型对象没包含足够多的信息来明确定位与之相关的 "date"对象和"time"对
象。天真型对象代表的是 世界标准时间(UTC), 当地时间或者是其它时区的时间
完全取决于程序就像一个数字是代表的是米、英里或者质量完全取决于程序。天
真型对象以忽略了一些现实情况的为代价使得它容易理解和使用。

对于需要觉悟型对象的应用， "datetime" 对象和 "time" 对象有一个可选的时
区信息属性 "tzinfo" ，这个属性可以设置给 "tzinfo" 类的子类实例。这些
"tzinfo" 对象捕获关于相对于世界标准时间（UTC）偏移、时区名字和夏令时是
否有效等信息。需要注意的是，只有一个具体的 "tzinfo" 类，即由
"datetime" 模块提供的 "timezone" 类。 "timezone" 类可以代表相对于世界
标准时间（UTC）固定偏移的简单时区，比如世界标准时间（UTC）自己或者北美
东部时间或者东部夏令时。支持时区的详细程度取决于应用。世界各地的时间调
整规则相比理性更加政治性，经常会变更。也没有一个基于世界标准时间（UTC
）的标准套件适合用于所有应用。

The "datetime" module exports the following constants:

datetime.MINYEAR

   "date" 或者 "datetime" 对象允许的最小年份。 常量 "MINYEAR" 是 "1"
   。

datetime.MAXYEAR

   "date" 或 "datetime" 对象允许最大的年份。常量 "MAXYEAR" 是 "9999"
   。

参见:

  模块 "calendar"
     日历相关函数

  模块 "time"
     时间的访问和转换


有效的类型
==========

class datetime.date

   理想的天真型日期假设公历是永远有效的。属性 : "year", "month", and
   "day" 。

class datetime.time

   一个理想的时间独立于任何一天，假设每一天一共有24*60*60秒（这里没有"
   闰秒"的概念）。属性： "hour", "minute", "second", "microsecond", 和
   "tzinfo"。

class datetime.datetime

   日期和时间的结合。属性："year", "month", "day", "hour", "minute",
   "second", "microsecond", and "tzinfo".

class datetime.timedelta

   表示两个 "date" 对象或者 "time" 对象,或者 "datetime" 对象之间的时间
   间隔，精确到微秒。

class datetime.tzinfo

   一个描述时区信息的抽象基类。用于给 "datetime" 类和 "time" 类提供自
   定义的时间调整概念（例如，负责时区或者夏令时）。

class datetime.timezone

   一个实现了 "tzinfo" 抽象基类的子类，用于表示相对于 世界标准时间（
   UTC）的偏移量。

   3.2 新版功能.

这些类型的对象都是不可变的。

"date"  类型 的对象都是 天真型 的。

An object of type "time" or "datetime" may be naive or aware. A
"datetime" object *d* is aware if "d.tzinfo" is not "None" and
"d.tzinfo.utcoffset(d)" does not return "None".  If "d.tzinfo" is
"None", or if "d.tzinfo" is not "None" but "d.tzinfo.utcoffset(d)"
returns "None", *d* is naive.  A "time" object *t* is aware if
"t.tzinfo" is not "None" and "t.tzinfo.utcoffset(None)" does not
return "None".  Otherwise, *t* is naive.

天真型和觉悟型之间的差别不适用于 "timedelta" 对象。

子类关系

   object
       timedelta
       tzinfo
           timezone
       time
       date
           datetime


"timedelta" 类对象
==================

"timedelta" 对象表示两个 date 或者 time 的时间间隔。

class datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)

   所有的参数都是可选的并且默认为 "0"。这些参数可以是整数或者浮点数，
   也可以是正数或者负数。

   只有 *days*,*seconds* 和 *microseconds* 会存储在内部，即python内部
   以 *days*,*seconds* 和 *microseconds* 三个单位作为存储的基本单位。
   参数单位转换规则如下：

   * 1毫秒会转换成1000微秒。

   * 1分钟会转换成60秒。

   * 1小时会转换成3600秒。

   * 1星期会转换成7天。

   days, seconds, microseconds 本身也是标准化的，以保证表达方式的唯一
   性，例：

   * "0 <= microseconds < 1000000"

   * "0 <= seconds < 3600*24" (一天的秒数)

   * "-999999999 <= days <= 999999999"

   在有任何浮点型参数或者微秒为小数的情况下，所有小数均会按照前面的换
   算规则叠加到下一级，并使用round-half-to-even的方法对微秒进行取舍。
   没有浮点型参数情况下，转换的过程就是精确的（没有信息丢失）。

   如果标准化后的 days 数值超过了指定范围，将会抛出 "OverflowError" 异
   常。

   需要注意的是，负数被标准化后的结果会让你大吃一惊。例如，

   >>> from datetime import timedelta
   >>> d = timedelta(microseconds=-1)
   >>> (d.days, d.seconds, d.microseconds)
   (-1, 86399, 999999)

类属性：

timedelta.min

   The most negative "timedelta" object, "timedelta(-999999999)".

timedelta.max

   The most positive "timedelta" object, "timedelta(days=999999999,
   hours=23, minutes=59, seconds=59, microseconds=999999)".

timedelta.resolution

   两个不相等的 "timedelta" 类对象最小的间隔为
   "timedelta(microseconds=1)"。

需要注意的是，因为标准化的缘故，"timedelta.max" > "-timedelta.min"，
"-timedelta.max" 不可以表示一个 "timedelta" 类对象。

实例属性（只读）：

+--------------------+----------------------------------------------+
| 属性               | 值                                           |
|====================|==============================================|
| "days"             | -999999999 至 999999999 ，含999999999        |
+--------------------+----------------------------------------------+
| "seconds"          | 0 至 86399，包含86399                        |
+--------------------+----------------------------------------------+
| "microseconds"     | 0 至 999999，包含999999                      |
+--------------------+----------------------------------------------+

支持的运算：

+----------------------------------+-------------------------------------------------+
| 运算                             | 结果                                            |
|==================================|=================================================|
| "t1 = t2 + t3"                   | *t2* 和 *t3* 的和。 运算后 *t1*-*t2* == *t3*    |
|                                  | and *t1*-*t3* == *t2* 必 为真值。(1)            |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 - t3"                   | *t2* 减 *t3* 的差。 运算后 *t1* == *t2* - *t3*  |
|                                  | and *t2* == *t1* + *t3* 必为真值。 (1)(6)       |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 * i or t1 = i * t2"     | 乘以一个整数。运算后假如 "i != 0" 则 *t1* // i  |
|                                  | == *t2* 必为真值。                              |
+----------------------------------+-------------------------------------------------+
|                                  | In general, *t1* * i == *t1* * (i-1) + *t1* is  |
|                                  | true. (1)                                       |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 * f or t1 = f * t2"     | 乘以一个浮点数，结果会被舍入到 timedelta 最接近 |
|                                  | 的整数倍。 精度使用四舍 五偶入奇不入规则。      |
+----------------------------------+-------------------------------------------------+
| "f = t2 / t3"                    | 总时间 *t2* 除以间隔单位 *t3* (3)。 返回一个    |
|                                  | "float" 对象。                                  |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 / f or t1 = t2 / i"     | 除以一个浮点数或整数。 结果会被舍入到 timedelta |
|                                  | 最接近的整数倍。 精度 使用四舍五偶入奇不入规则  |
|                                  | 。                                              |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 // i" or "t1 = t2 //    | 取整除，余数部分(如果有的话)将被丢弃。在第二种  |
| t3"                              | 情况下，返回一个整数。 (3)                      |
+----------------------------------+-------------------------------------------------+
| "t1 = t2 % t3"                   | 余数为一个 "timedelta" 对象。(3)                |
+----------------------------------+-------------------------------------------------+
| "q, r = divmod(t1, t2)"          | 通过 : "q = t1 // t2" (3) and "r = t1 % t2" 计  |
|                                  | 算出商和余数。q是一个整 数，r是一个 "timedelta" |
|                                  | 对象。                                          |
+----------------------------------+-------------------------------------------------+
| "+t1"                            | 返回一个相同数值的 "timedelta" 对象。           |
+----------------------------------+-------------------------------------------------+
| "-t1"                            | 等价于 "timedelta"(-*t1.days*, -*t1.seconds*,   |
|                                  | -*t1.microseconds*), 和 *t1** -1. (1)(4)        |
+----------------------------------+-------------------------------------------------+
| "abs(t)"                         | 当 "t.days >= 0``时等于 +\ *t*, 当 ``t.days <   |
|                                  | 0" 时 -*t* 。 (2)                               |
+----------------------------------+-------------------------------------------------+
| "str(t)"                         | 返回一个形如 "[D day[s], ][H]H:MM:SS[.UUUUUU]"  |
|                                  | 的字符串，当 "t" 为负数 的时候，  D 也为负数。  |
|                                  | (5)                                             |
+----------------------------------+-------------------------------------------------+
| "repr(t)"                        | 返回一个 "timedelta" 对象的字符串表示形式，作为 |
|                                  | 附带正规属性值的构造器 调用。                   |
+----------------------------------+-------------------------------------------------+

注释:

1. 精确但可能会溢出。

2. 精确且不会溢出。

3. 除以0将会抛出异常  "ZeroDivisionError" 。

4. -*timedelta.max* 不是一个 "timedelta" 类对象。

5. String representations of "timedelta" objects are normalized
   similarly to their internal representation.  This leads to somewhat
   unusual results for negative timedeltas.  For example:

   >>> timedelta(hours=-5)
   datetime.timedelta(days=-1, seconds=68400)
   >>> print(_)
   -1 day, 19:00:00

6. 表达式 "t2 - t3" 通常与 "t2 + (-t3)" 是等价的，除非 t3 等于
   "timedelta.max"; 在这种情况下前者会返回结果，而后者则会溢出。

除了上面列举的操作以外 "timedelta" 对象还支持与 "date" 和 "datetime"
对象进行特定的相加和相减运算（见下文）。

在 3.2 版更改: 现在已支持 "timedelta" 对象与另一个 "timedelta" 对象相
整除或相除，包括求余运算和 "divmod()" 函数。 现在也支持 "timedelta" 对
象被 "float" 对象除或乘。

"timedelta" 对象与 "timedelta" 对象比较的支持是通过将表示较小时间差的
timedelta 对象视为较小值。 为了防止将混合类型比较回退为基于对象地址的
默认比较，当 "timedelta" 对象与不同类型的对象比较时，将会引发
"TypeError"，除非比较运算符是 "==" 或 "!="。 在后一种情况下将分别返回
"False" 或 "True"。

"timedelta" 对象是 *hashable*  类型的(可以作为字典关键字), 支持高效获
取, 在布尔上下文中， "timedelta" 对象大多数情况下都被视为真，仅在不等
于 "timedelta(0)" 时。

实例方法：

timedelta.total_seconds()

   返回时间间隔包含了多少秒。造价于 "td / timedelta(seconds=1)"。对于
   其它单位可以直接使用除法的形式 (例如  "td /
   timedelta(microseconds=1)")。

   需要注意的是，时间间隔较大时，这个方法的结果中的微秒将会失真（大多
   数平台上大于270年视为一个较大的时间间隔）。

   3.2 新版功能.

用法示例：

>>> from datetime import timedelta
>>> year = timedelta(days=365)
>>> another_year = timedelta(weeks=40, days=84, hours=23,
...                          minutes=50, seconds=600)  # adds up to 365 days
>>> year.total_seconds()
31536000.0
>>> year == another_year
True
>>> ten_years = 10 * year
>>> ten_years, ten_years.days // 365
(datetime.timedelta(days=3650), 10)
>>> nine_years = ten_years - year
>>> nine_years, nine_years.days // 365
(datetime.timedelta(days=3285), 9)
>>> three_years = nine_years // 3
>>> three_years, three_years.days // 365
(datetime.timedelta(days=1095), 3)
>>> abs(three_years - ten_years) == 2 * three_years + year
True


"date" 对象
===========

"date" 对象代表一个理想化历法中的日期（年、月和日），即当今的格列高利
历向前后两个方向无限延伸。公元 1  年 1 月 1 日是第 1 日，公元 1 年 1
月 2 日是第 2 日， 依此类推。 这与 Dershowitz 与 Reingold 所著
Calendrical Calculations 中“预期格列高利”历法的定义一致，它是适用于该
书中所有运算的基础历法。 请参阅该书了解在预期格列高利历序列与许多其他
历法系统之间进行转换的算法。

class datetime.date(year, month, day)

   所有参数都是必选的。参数可以是在下面范围内的整数：

   * "MINYEAR <= year <= MAXYEAR"

   * "1 <= month <= 12"

   * "1 <= 日期 <= 给定年月对应的天数"

   如果参数不在这些范围内，则抛出 "ValueError" 异常。

其它构造器，所有的类方法：

classmethod date.today()

   返回当地的当前日期。与``date.fromtimestamp(time.time())``等价。

classmethod date.fromtimestamp(timestamp)

   返回对应于 POSIX 时间戳例如 "time.time()" 返回值的本地日期。 这可能
   引发 "OverflowError"，如果时间戳数值超出所在平台 C "localtime()" 函
   数的支持范围的话，并会在 "localtime()" 出错时引发 "OSError"。 通常
   该数值会被限制在 1970 年至 2038 年之间。 请注意在时间戳概念包含闰秒
   的非 POSIX 系统上，闰秒会被 "fromtimestamp()" 所忽略。

   在 3.3 版更改: 引发 "OverflowError" 而不是 "ValueError"，如果时间戳
   数值超出所在平台 C "localtime()" 函数的支持范围的话，并会在
   "localtime()" 出错时引发 "OSError" 而不是 "ValueError"。

classmethod date.fromordinal(ordinal)

   返回对应于预期格列高利历序号的日期，其中公元 1 年 1 月 1 日的序号为
   1。 除非 "1 <= 序号 <= date.max.toordinal()" 否则会引发
   "ValueError"。 对于任意日期 *d*， "date.fromordinal(d.toordinal())
   == d"。

classmethod date.fromisoformat(date_string)

   返回对应于 "date.isoformat()" 所提供的 *date_string* 格式的 "date"
   。 特别地，此函数支持 "YYYY-MM-DD" 格式的字符串。

   警告: 此函数不支持解析任意 ISO 8601 字符串 —— 它的目的只是作为
     "date.isoformat()" 的逆操作。

   3.7 新版功能.

类属性：

date.min

   最小的日期 "date(MINYEAR, 1, 1)" 。

date.max

   最大的日期 ，"date(MAXYEAR, 12, 31)"。

date.resolution

   两个日期对象的最小间隔，"timedelta(days=1)"。

实例属性（只读）：

date.year

   在 "MINYEAR" 和 "MAXYEAR" 之间，包含边界。

date.month

   1 至 12（含）

date.day

   返回1到指定年月的天数间的数字。

支持的运算：

+---------------------------------+------------------------------------------------+
| 运算                            | 结果                                           |
|=================================|================================================|
| "date2 = date1 + timedelta"     | *date2* 等于从 *date1* 减去 "timedelta.days"   |
|                                 | 天。 (1)                                       |
+---------------------------------+------------------------------------------------+
| "date2 = date1 - timedelta"     | 计算 *date2* 的值使得 "date2 + timedelta ==    |
|                                 | date1"。 (2)                                   |
+---------------------------------+------------------------------------------------+
| "timedelta = date1 - date2"     | (3)                                            |
+---------------------------------+------------------------------------------------+
| "date1 < date2"                 | 如果 *date1* 的时间在 *date2* 之前则认为       |
|                                 | *date1* 小于 *date2* 。 (4)                    |
+---------------------------------+------------------------------------------------+

注释:

1. 如果 "timedelta.days > 0" 则 *date2* 在时间线上前进，如果
   "timedelta.days < 0" 则后退。 操作完成后 "date2 - date1 ==
   timedelta.days"。 "timedelta.seconds" 和 "timedelta.microseconds"
   会被忽略。如果 "date2.year" 将小于 "MINYEAR" 或大于 "MAXYEAR" 则会
   引发 "OverflowError"。.

2. "timedelta.seconds" 和 "timedelta.microseconds" 会被忽略。

3. 精确且不会溢出。 操作完成后 timedelta.seconds 和
   timedelta.microseconds 均为0， 并且 date2 + timedelta == date1。

4. 换句话说，当且仅当 "date1.toordinal() < date2.toordinal()" 时
   "date1 < date2"。 日期比较会引发 "TypeError"，如果比较目标不为
   "date" 对象的话。 不过也可能会返回  "NotImplemented"，如果比较目标
   具有 "timetuple()" 属性的话。 这个钩子给予其他日期对象类型实现混合
   类型比较的机会。 否则，当 "date" 对象与不同类型的对象比较时将会引发
   "TypeError"，除非 "==" 或 "!=" 比较。 后两种情况将分别返回 "False"
   或 "True"。

日期可以作为字典的关键字。在布尔上下文中，所有的 "date" 对象都视为真。

实例方法：

date.replace(year=self.year, month=self.month, day=self.day)

   Return a date with the same value, except for those parameters
   given new values by whichever keyword arguments are specified.  For
   example, if "d == date(2002, 12, 31)", then "d.replace(day=26) ==
   date(2002, 12, 26)".

date.timetuple()

   Return a "time.struct_time" such as returned by "time.localtime()".
   The hours, minutes and seconds are 0, and the DST flag is -1.
   "d.timetuple()" is equivalent to "time.struct_time((d.year,
   d.month, d.day, 0, 0, 0, d.weekday(), yday, -1))", where "yday =
   d.toordinal() - date(d.year, 1, 1).toordinal() + 1" is the day
   number within the current year starting with "1" for January 1st.

date.toordinal()

   Return the proleptic Gregorian ordinal of the date, where January 1
   of year 1 has ordinal 1.  For any "date" object *d*,
   "date.fromordinal(d.toordinal()) == d".

date.weekday()

   返回一个整数代表星期几，星期一为0，星期天为6。例如， "date(2002,
   12, 4).weekday() == 2"，表示的是星期三。参阅 "isoweekday()"。

date.isoweekday()

   返回一个整数代表星期几，星期一为1，星期天为7。例如："date(2002, 12,
   4).isoweekday() == 3",表示星期三。参见 "weekday()", "isocalendar()"
   。

date.isocalendar()

   返回一个三元元组，(ISO year, ISO week number, ISO weekday) 。

   ISO日历是一个被广泛使用的公历。可以从
   https://www.staff.science.uu.nl/~gent0113/calendar/isocalendar.htm
   上查看更完整的说明。

   The ISO year consists of 52 or 53 full weeks, and where a week
   starts on a Monday and ends on a Sunday.  The first week of an ISO
   year is the first (Gregorian) calendar week of a year containing a
   Thursday. This is called week number 1, and the ISO year of that
   Thursday is the same as its Gregorian year.

   For example, 2004 begins on a Thursday, so the first week of ISO
   year 2004 begins on Monday, 29 Dec 2003 and ends on Sunday, 4 Jan
   2004, so that "date(2003, 12, 29).isocalendar() == (2004, 1, 1)"
   and "date(2004, 1, 4).isocalendar() == (2004, 1, 7)".

date.isoformat()

   返回一个 ISO 8601 格式的字符串， 'YYYY-MM-DD'。例如 "date(2002, 12,
   4).isoformat() == '2002-12-04'"。

date.__str__()

   对于日期对象 *d*, "str(d)" 等价于 "d.isoformat()" 。

date.ctime()

   Return a string representing the date, for example "date(2002, 12,
   4).ctime() == 'Wed Dec 4 00:00:00 2002'". "d.ctime()" is equivalent
   to "time.ctime(time.mktime(d.timetuple()))" on platforms where the
   native C "ctime()" function (which "time.ctime()" invokes, but
   which "date.ctime()" does not invoke) conforms to the C standard.

date.strftime(format)

   Return a string representing the date, controlled by an explicit
   format string. Format codes referring to hours, minutes or seconds
   will see 0 values. For a complete list of formatting directives,
   see strftime() and strptime() Behavior.

date.__format__(format)

   Same as "date.strftime()". This makes it possible to specify a
   format string for a "date" object in formatted string literals and
   when using "str.format()". For a complete list of formatting
   directives, see strftime() and strptime() Behavior.

Example of counting days to an event:

   >>> import time
   >>> from datetime import date
   >>> today = date.today()
   >>> today
   datetime.date(2007, 12, 5)
   >>> today == date.fromtimestamp(time.time())
   True
   >>> my_birthday = date(today.year, 6, 24)
   >>> if my_birthday < today:
   ...     my_birthday = my_birthday.replace(year=today.year + 1)
   >>> my_birthday
   datetime.date(2008, 6, 24)
   >>> time_to_birthday = abs(my_birthday - today)
   >>> time_to_birthday.days
   202

Example of working with "date":

   >>> from datetime import date
   >>> d = date.fromordinal(730920) # 730920th day after 1. 1. 0001
   >>> d
   datetime.date(2002, 3, 11)
   >>> t = d.timetuple()
   >>> for i in t:     
   ...     print(i)
   2002                # year
   3                   # month
   11                  # day
   0
   0
   0
   0                   # weekday (0 = Monday)
   70                  # 70th day in the year
   -1
   >>> ic = d.isocalendar()
   >>> for i in ic:    
   ...     print(i)
   2002                # ISO year
   11                  # ISO week number
   1                   # ISO day number ( 1 = Monday )
   >>> d.isoformat()
   '2002-03-11'
   >>> d.strftime("%d/%m/%y")
   '11/03/02'
   >>> d.strftime("%A %d. %B %Y")
   'Monday 11. March 2002'
   >>> 'The {1} is {0:%d}, the {2} is {0:%B}.'.format(d, "day", "month")
   'The day is 11, the month is March.'


"datetime" 对象
===============

A "datetime" object is a single object containing all the information
from a "date" object and a "time" object.  Like a "date" object,
"datetime" assumes the current Gregorian calendar extended in both
directions; like a time object, "datetime" assumes there are exactly
3600*24 seconds in every day.

构造器 ：

class datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

   year, month, day 三个参数是必选的。 *tzinfo* 可以是 "None",  或者是
   是一个 "tzinfo" 子类的实例。其余的参数可以是在以下范围内的整数：

   * "MINYEAR <= year <= MAXYEAR",

   * "1 <= month <= 12",

   * "1 <= day <= 指定年月的天数",

   * "0 <= hour < 24",

   * "0 <= minute < 60",

   * "0 <= second < 60",

   * "0 <= microsecond < 1000000",

   * "fold in [0, 1]".

   如果参数不在这些范围内，则抛出 "ValueError" 异常。

   3.6 新版功能: 增加了 "fold" 参数。

其它构造器，所有的类方法：

classmethod datetime.today()

   Return the current local datetime, with "tzinfo" "None". This is
   equivalent to "datetime.fromtimestamp(time.time())". See also
   "now()", "fromtimestamp()".

classmethod datetime.now(tz=None)

   Return the current local date and time.  If optional argument *tz*
   is "None" or not specified, this is like "today()", but, if
   possible, supplies more precision than can be gotten from going
   through a "time.time()" timestamp (for example, this may be
   possible on platforms supplying the C "gettimeofday()" function).

   If *tz* is not "None", it must be an instance of a "tzinfo"
   subclass, and the current date and time are converted to *tz*’s
   time zone.  In this case the result is equivalent to
   "tz.fromutc(datetime.utcnow().replace(tzinfo=tz))". See also
   "today()", "utcnow()".

classmethod datetime.utcnow()

   Return the current UTC date and time, with "tzinfo" "None". This is
   like "now()", but returns the current UTC date and time, as a naive
   "datetime" object.  An aware current UTC datetime can be obtained
   by calling "datetime.now(timezone.utc)".  See also "now()".

classmethod datetime.fromtimestamp(timestamp, tz=None)

   Return the local date and time corresponding to the POSIX
   timestamp, such as is returned by "time.time()". If optional
   argument *tz* is "None" or not specified, the timestamp is
   converted to the platform's local date and time, and the returned
   "datetime" object is naive.

   If *tz* is not "None", it must be an instance of a "tzinfo"
   subclass, and the timestamp is converted to *tz*’s time zone.  In
   this case the result is equivalent to "tz.fromutc(datetime.utcfrom
   timestamp(timestamp).replace(tzinfo=tz))".

   "fromtimestamp()" may raise "OverflowError", if the timestamp is
   out of the range of values supported by the platform C
   "localtime()" or "gmtime()" functions, and "OSError" on
   "localtime()" or "gmtime()" failure. It's common for this to be
   restricted to years in 1970 through 2038. Note that on non-POSIX
   systems that include leap seconds in their notion of a timestamp,
   leap seconds are ignored by "fromtimestamp()", and then it's
   possible to have two timestamps differing by a second that yield
   identical "datetime" objects. See also "utcfromtimestamp()".

   在 3.3 版更改: Raise "OverflowError" instead of "ValueError" if the
   timestamp is out of the range of values supported by the platform C
   "localtime()" or "gmtime()" functions. Raise "OSError" instead of
   "ValueError" on "localtime()" or "gmtime()" failure.

   在 3.6 版更改: "fromtimestamp()" may return instances with "fold"
   set to 1.

classmethod datetime.utcfromtimestamp(timestamp)

   Return the UTC "datetime" corresponding to the POSIX timestamp,
   with "tzinfo" "None". This may raise "OverflowError", if the
   timestamp is out of the range of values supported by the platform C
   "gmtime()" function, and "OSError" on "gmtime()" failure. It's
   common for this to be restricted to years in 1970 through 2038.

   To get an aware "datetime" object, call "fromtimestamp()":

      datetime.fromtimestamp(timestamp, timezone.utc)

   On the POSIX compliant platforms, it is equivalent to the following
   expression:

      datetime(1970, 1, 1, tzinfo=timezone.utc) + timedelta(seconds=timestamp)

   except the latter formula always supports the full years range:
   between "MINYEAR" and "MAXYEAR" inclusive.

   在 3.3 版更改: Raise "OverflowError" instead of "ValueError" if the
   timestamp is out of the range of values supported by the platform C
   "gmtime()" function. Raise "OSError" instead of "ValueError" on
   "gmtime()" failure.

classmethod datetime.fromordinal(ordinal)

   Return the "datetime" corresponding to the proleptic Gregorian
   ordinal, where January 1 of year 1 has ordinal 1. "ValueError" is
   raised unless "1 <= ordinal <= datetime.max.toordinal()".  The
   hour, minute, second and microsecond of the result are all 0, and
   "tzinfo" is "None".

classmethod datetime.combine(date, time, tzinfo=self.tzinfo)

   Return a new "datetime" object whose date components are equal to
   the given "date" object's, and whose time components are equal to
   the given "time" object's.  If the *tzinfo* argument is provided,
   its value is used to set the "tzinfo" attribute of the result,
   otherwise the "tzinfo" attribute of the *time* argument is used.

   For any "datetime" object *d*, "d == datetime.combine(d.date(),
   d.time(), d.tzinfo)".  If date is a "datetime" object, its time
   components and "tzinfo" attributes are ignored.

   在 3.6 版更改: Added the *tzinfo* argument.

classmethod datetime.fromisoformat(date_string)

   Return a "datetime" corresponding to a *date_string* in one of the
   formats emitted by "date.isoformat()" and "datetime.isoformat()".
   Specifically, this function supports strings in the format(s)
   "YYYY-MM-DD[*HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]]", where
   "*" can match any single character.

   警告: This does not support parsing arbitrary ISO 8601 strings -
     it is only intended as the inverse operation of
     "datetime.isoformat()".

   3.7 新版功能.

classmethod datetime.strptime(date_string, format)

   Return a "datetime" corresponding to *date_string*, parsed
   according to *format*.  This is equivalent to
   "datetime(*(time.strptime(date_string, format)[0:6]))".
   "ValueError" is raised if the date_string and format can't be
   parsed by "time.strptime()" or if it returns a value which isn't a
   time tuple. For a complete list of formatting directives, see
   strftime() and strptime() Behavior.

类属性：

datetime.min

   The earliest representable "datetime", "datetime(MINYEAR, 1, 1,
   tzinfo=None)".

datetime.max

   The latest representable "datetime", "datetime(MAXYEAR, 12, 31, 23,
   59, 59, 999999, tzinfo=None)".

datetime.resolution

   The smallest possible difference between non-equal "datetime"
   objects, "timedelta(microseconds=1)".

实例属性（只读）：

datetime.year

   在 "MINYEAR" 和 "MAXYEAR" 之间，包含边界。

datetime.month

   1 至 12（含）

datetime.day

   返回1到指定年月的天数间的数字。

datetime.hour

   In "range(24)".

datetime.minute

   In "range(60)".

datetime.second

   In "range(60)".

datetime.microsecond

   In "range(1000000)".

datetime.tzinfo

   The object passed as the *tzinfo* argument to the "datetime"
   constructor, or "None" if none was passed.

datetime.fold

   In "[0, 1]".  Used to disambiguate wall times during a repeated
   interval.  (A repeated interval occurs when clocks are rolled back
   at the end of daylight saving time or when the UTC offset for the
   current zone is decreased for political reasons.) The value 0 (1)
   represents the earlier (later) of the two moments with the same
   wall time representation.

   3.6 新版功能.

支持的运算：

+-----------------------------------------+----------------------------------+
| 运算                                    | 结果                             |
|=========================================|==================================|
| "datetime2 = datetime1 + timedelta"     | (1)                              |
+-----------------------------------------+----------------------------------+
| "datetime2 = datetime1 - timedelta"     | (2)                              |
+-----------------------------------------+----------------------------------+
| "timedelta = datetime1 - datetime2"     | (3)                              |
+-----------------------------------------+----------------------------------+
| "datetime1 < datetime2"                 | Compares "datetime" to           |
|                                         | "datetime". (4)                  |
+-----------------------------------------+----------------------------------+

1. datetime2 is a duration of timedelta removed from datetime1,
   moving forward in time if "timedelta.days" > 0, or backward if
   "timedelta.days" < 0.  The result has the same "tzinfo" attribute
   as the input datetime, and datetime2 - datetime1 == timedelta
   after. "OverflowError" is raised if datetime2.year would be smaller
   than "MINYEAR" or larger than "MAXYEAR". Note that no time zone
   adjustments are done even if the input is an aware object.

2. Computes the datetime2 such that datetime2 + timedelta ==
   datetime1. As for addition, the result has the same "tzinfo"
   attribute as the input datetime, and no time zone adjustments are
   done even if the input is aware.

3. Subtraction of a "datetime" from a "datetime" is defined only if
   both operands are naive, or if both are aware.  If one is aware and
   the other is naive, "TypeError" is raised.

   If both are naive, or both are aware and have the same "tzinfo"
   attribute, the "tzinfo" attributes are ignored, and the result is a
   "timedelta" object *t* such that "datetime2 + t == datetime1".  No
   time zone adjustments are done in this case.

   If both are aware and have different "tzinfo" attributes, "a-b"
   acts as if *a* and *b* were first converted to naive UTC datetimes
   first.  The result is "(a.replace(tzinfo=None) - a.utcoffset()) -
   (b.replace(tzinfo=None) - b.utcoffset())" except that the
   implementation never overflows.

4. *datetime1* is considered less than *datetime2* when *datetime1*
   precedes *datetime2* in time.

   If one comparand is naive and the other is aware, "TypeError" is
   raised if an order comparison is attempted.  For equality
   comparisons, naive instances are never equal to aware instances.

   If both comparands are aware, and have the same "tzinfo" attribute,
   the common "tzinfo" attribute is ignored and the base datetimes are
   compared.  If both comparands are aware and have different "tzinfo"
   attributes, the comparands are first adjusted by subtracting their
   UTC offsets (obtained from "self.utcoffset()").

   在 3.3 版更改: Equality comparisons between naive and aware
   "datetime" instances don't raise "TypeError".

   注解: In order to stop comparison from falling back to the
     default scheme of comparing object addresses, datetime comparison
     normally raises "TypeError" if the other comparand isn't also a
     "datetime" object.  However, "NotImplemented" is returned instead
     if the other comparand has a "timetuple()" attribute.  This hook
     gives other kinds of date objects a chance at implementing mixed-
     type comparison.  If not, when a "datetime" object is compared to
     an object of a different type, "TypeError" is raised unless the
     comparison is "==" or "!=".  The latter cases return "False" or
     "True", respectively.

"datetime" objects can be used as dictionary keys. In Boolean
contexts, all "datetime" objects are considered to be true.

实例方法：

datetime.date()

   Return "date" object with same year, month and day.

datetime.time()

   Return "time" object with same hour, minute, second, microsecond
   and fold. "tzinfo" is "None".  See also method "timetz()".

   在 3.6 版更改: The fold value is copied to the returned "time"
   object.

datetime.timetz()

   Return "time" object with same hour, minute, second, microsecond,
   fold, and tzinfo attributes.  See also method "time()".

   在 3.6 版更改: The fold value is copied to the returned "time"
   object.

datetime.replace(year=self.year, month=self.month, day=self.day, hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)

   Return a datetime with the same attributes, except for those
   attributes given new values by whichever keyword arguments are
   specified.  Note that "tzinfo=None" can be specified to create a
   naive datetime from an aware datetime with no conversion of date
   and time data.

   3.6 新版功能: 增加了 "fold" 参数。

datetime.astimezone(tz=None)

   Return a "datetime" object with new "tzinfo" attribute *tz*,
   adjusting the date and time data so the result is the same UTC time
   as *self*, but in *tz*'s local time.

   If provided, *tz* must be an instance of a "tzinfo" subclass, and
   its "utcoffset()" and "dst()" methods must not return "None".  If
   *self* is naive, it is presumed to represent time in the system
   timezone.

   If called without arguments (or with "tz=None") the system local
   timezone is assumed for the target timezone.  The ".tzinfo"
   attribute of the converted datetime instance will be set to an
   instance of "timezone" with the zone name and offset obtained from
   the OS.

   If "self.tzinfo" is *tz*, "self.astimezone(tz)" is equal to *self*:
   no adjustment of date or time data is performed. Else the result is
   local time in the timezone *tz*, representing the same UTC time as
   *self*:  after "astz = dt.astimezone(tz)", "astz -
   astz.utcoffset()" will have the same date and time data as "dt -
   dt.utcoffset()".

   If you merely want to attach a time zone object *tz* to a datetime
   *dt* without adjustment of date and time data, use
   "dt.replace(tzinfo=tz)".  If you merely want to remove the time
   zone object from an aware datetime *dt* without conversion of date
   and time data, use "dt.replace(tzinfo=None)".

   Note that the default "tzinfo.fromutc()" method can be overridden
   in a "tzinfo" subclass to affect the result returned by
   "astimezone()". Ignoring error cases, "astimezone()" acts like:

      def astimezone(self, tz):
          if self.tzinfo is tz:
              return self
          # Convert self to UTC, and attach the new time zone object.
          utc = (self - self.utcoffset()).replace(tzinfo=tz)
          # Convert from UTC to tz's local time.
          return tz.fromutc(utc)

   在 3.3 版更改: *tz* now can be omitted.

   在 3.6 版更改: The "astimezone()" method can now be called on naive
   instances that are presumed to represent system local time.

datetime.utcoffset()

   If "tzinfo" is "None", returns "None", else returns
   "self.tzinfo.utcoffset(self)", and raises an exception if the
   latter doesn't return "None" or a "timedelta" object with magnitude
   less than one day.

   在 3.7 版更改: The UTC offset is not restricted to a whole number
   of minutes.

datetime.dst()

   If "tzinfo" is "None", returns "None", else returns
   "self.tzinfo.dst(self)", and raises an exception if the latter
   doesn't return "None" or a "timedelta" object with magnitude less
   than one day.

   在 3.7 版更改: The DST offset is not restricted to a whole number
   of minutes.

datetime.tzname()

   If "tzinfo" is "None", returns "None", else returns
   "self.tzinfo.tzname(self)", raises an exception if the latter
   doesn't return "None" or a string object,

datetime.timetuple()

   Return a "time.struct_time" such as returned by "time.localtime()".
   "d.timetuple()" is equivalent to "time.struct_time((d.year,
   d.month, d.day, d.hour, d.minute, d.second, d.weekday(), yday,
   dst))", where "yday = d.toordinal() - date(d.year, 1,
   1).toordinal() + 1" is the day number within the current year
   starting with "1" for January 1st. The "tm_isdst" flag of the
   result is set according to the "dst()" method: "tzinfo" is "None"
   or "dst()" returns "None", "tm_isdst" is set to "-1"; else if
   "dst()" returns a non-zero value, "tm_isdst" is set to "1"; else
   "tm_isdst" is set to "0".

datetime.utctimetuple()

   If "datetime" instance *d* is naive, this is the same as
   "d.timetuple()" except that "tm_isdst" is forced to 0 regardless of
   what "d.dst()" returns.  DST is never in effect for a UTC time.

   If *d* is aware, *d* is normalized to UTC time, by subtracting
   "d.utcoffset()", and a "time.struct_time" for the normalized time
   is returned.  "tm_isdst" is forced to 0. Note that an
   "OverflowError" may be raised if *d*.year was "MINYEAR" or
   "MAXYEAR" and UTC adjustment spills over a year boundary.

datetime.toordinal()

   Return the proleptic Gregorian ordinal of the date.  The same as
   "self.date().toordinal()".

datetime.timestamp()

   Return POSIX timestamp corresponding to the "datetime" instance.
   The return value is a "float" similar to that returned by
   "time.time()".

   Naive "datetime" instances are assumed to represent local time and
   this method relies on the platform C "mktime()" function to perform
   the conversion.  Since "datetime" supports wider range of values
   than "mktime()" on many platforms, this method may raise
   "OverflowError" for times far in the past or far in the future.

   For aware "datetime" instances, the return value is computed as:

      (dt - datetime(1970, 1, 1, tzinfo=timezone.utc)).total_seconds()

   3.3 新版功能.

   在 3.6 版更改: The "timestamp()" method uses the "fold" attribute
   to disambiguate the times during a repeated interval.

   注解: There is no method to obtain the POSIX timestamp directly
     from a naive "datetime" instance representing UTC time.  If your
     application uses this convention and your system timezone is not
     set to UTC, you can obtain the POSIX timestamp by supplying
     "tzinfo=timezone.utc":

        timestamp = dt.replace(tzinfo=timezone.utc).timestamp()

     or by calculating the timestamp directly:

        timestamp = (dt - datetime(1970, 1, 1)) / timedelta(seconds=1)

datetime.weekday()

   Return the day of the week as an integer, where Monday is 0 and
   Sunday is 6. The same as "self.date().weekday()". See also
   "isoweekday()".

datetime.isoweekday()

   Return the day of the week as an integer, where Monday is 1 and
   Sunday is 7. The same as "self.date().isoweekday()". See also
   "weekday()", "isocalendar()".

datetime.isocalendar()

   Return a 3-tuple, (ISO year, ISO week number, ISO weekday).  The
   same as "self.date().isocalendar()".

datetime.isoformat(sep='T', timespec='auto')

   Return a string representing the date and time in ISO 8601 format,
   YYYY-MM-DDTHH:MM:SS.ffffff or, if "microsecond" is 0, YYYY-MM-
   DDTHH:MM:SS

   If "utcoffset()" does not return "None", a string is appended,
   giving the UTC offset: YYYY-MM-
   DDTHH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if "microsecond" is 0
   YYYY-MM-DDTHH:MM:SS+HH:MM[:SS[.ffffff]].

   The optional argument *sep* (default "'T'") is a one-character
   separator, placed between the date and time portions of the result.
   For example,

   >>> from datetime import tzinfo, timedelta, datetime
   >>> class TZ(tzinfo):
   ...     def utcoffset(self, dt): return timedelta(minutes=-399)
   ...
   >>> datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')
   '2002-12-25 00:00:00-06:39'

   The optional argument *timespec* specifies the number of additional
   components of the time to include (the default is "'auto'"). It can
   be one of the following:

   * "'auto'": Same as "'seconds'" if "microsecond" is 0, same as
     "'microseconds'" otherwise.

   * "'hours'": Include the "hour" in the two-digit HH format.

   * "'minutes'": Include "hour" and "minute" in HH:MM format.

   * "'seconds'": Include "hour", "minute", and "second" in HH:MM:SS
     format.

   * "'milliseconds'": Include full time, but truncate fractional
     second part to milliseconds. HH:MM:SS.sss format.

   * "'microseconds'": Include full time in HH:MM:SS.ffffff format.

   注解: Excluded time components are truncated, not rounded.

   "ValueError" will be raised on an invalid *timespec* argument.

   >>> from datetime import datetime
   >>> datetime.now().isoformat(timespec='minutes')   # doctest: +SKIP
   '2002-12-25T00:00'
   >>> dt = datetime(2015, 1, 1, 12, 30, 59, 0)
   >>> dt.isoformat(timespec='microseconds')
   '2015-01-01T12:30:59.000000'

   3.6 新版功能: Added the *timespec* argument.

datetime.__str__()

   For a "datetime" instance *d*, "str(d)" is equivalent to
   "d.isoformat(' ')".

datetime.ctime()

   Return a string representing the date and time, for example
   "datetime(2002, 12, 4, 20, 30, 40).ctime() == 'Wed Dec  4 20:30:40
   2002'". "d.ctime()" is equivalent to
   "time.ctime(time.mktime(d.timetuple()))" on platforms where the
   native C "ctime()" function (which "time.ctime()" invokes, but
   which "datetime.ctime()" does not invoke) conforms to the C
   standard.

datetime.strftime(format)

   Return a string representing the date and time, controlled by an
   explicit format string.  For a complete list of formatting
   directives, see strftime() and strptime() Behavior.

datetime.__format__(format)

   Same as "datetime.strftime()".  This makes it possible to specify a
   format string for a "datetime" object in formatted string literals
   and when using "str.format()".  For a complete list of formatting
   directives, see strftime() and strptime() Behavior.

Examples of working with datetime objects:

   >>> from datetime import datetime, date, time
   >>> # Using datetime.combine()
   >>> d = date(2005, 7, 14)
   >>> t = time(12, 30)
   >>> datetime.combine(d, t)
   datetime.datetime(2005, 7, 14, 12, 30)
   >>> # Using datetime.now() or datetime.utcnow()
   >>> datetime.now()   
   datetime.datetime(2007, 12, 6, 16, 29, 43, 79043)   # GMT +1
   >>> datetime.utcnow()   
   datetime.datetime(2007, 12, 6, 15, 29, 43, 79060)
   >>> # Using datetime.strptime()
   >>> dt = datetime.strptime("21/11/06 16:30", "%d/%m/%y %H:%M")
   >>> dt
   datetime.datetime(2006, 11, 21, 16, 30)
   >>> # Using datetime.timetuple() to get tuple of all attributes
   >>> tt = dt.timetuple()
   >>> for it in tt:   
   ...     print(it)
   ...
   2006    # year
   11      # month
   21      # day
   16      # hour
   30      # minute
   0       # second
   1       # weekday (0 = Monday)
   325     # number of days since 1st January
   -1      # dst - method tzinfo.dst() returned None
   >>> # Date in ISO format
   >>> ic = dt.isocalendar()
   >>> for it in ic:   
   ...     print(it)
   ...
   2006    # ISO year
   47      # ISO week
   2       # ISO weekday
   >>> # Formatting datetime
   >>> dt.strftime("%A, %d. %B %Y %I:%M%p")
   'Tuesday, 21. November 2006 04:30PM'
   >>> 'The {1} is {0:%d}, the {2} is {0:%B}, the {3} is {0:%I:%M%p}.'.format(dt, "day", "month", "time")
   'The day is 21, the month is November, the time is 04:30PM.'

Using datetime with tzinfo:

>>> from datetime import timedelta, datetime, tzinfo, timezone
>>> class KabulTz(tzinfo):
...     # Kabul used +4 until 1945, when they moved to +4:30
...     UTC_MOVE_DATE = datetime(1944, 12, 31, 20, tzinfo=timezone.utc)
...     def utcoffset(self, dt):
...         if dt.year < 1945:
...             return timedelta(hours=4)
...         elif (1945, 1, 1, 0, 0) <= dt.timetuple()[:5] < (1945, 1, 1, 0, 30):
...             # If dt falls in the imaginary range, use fold to decide how
...             # to resolve. See PEP495
...             return timedelta(hours=4, minutes=(30 if dt.fold else 0))
...         else:
...             return timedelta(hours=4, minutes=30)
...
...     def fromutc(self, dt):
...         # A custom implementation is required for fromutc as
...         # the input to this function is a datetime with utc values
...         # but with a tzinfo set to self
...         # See datetime.astimezone or fromtimestamp
...
...         # Follow same validations as in datetime.tzinfo
...         if not isinstance(dt, datetime):
...             raise TypeError("fromutc() requires a datetime argument")
...         if dt.tzinfo is not self:
...             raise ValueError("dt.tzinfo is not self")
...
...         if dt.replace(tzinfo=timezone.utc) >= self.UTC_MOVE_DATE:
...             return dt + timedelta(hours=4, minutes=30)
...         else:
...             return dt + timedelta(hours=4)
...
...     def dst(self, dt):
...         return timedelta(0)
...
...     def tzname(self, dt):
...         if dt >= self.UTC_MOVE_DATE:
...             return "+04:30"
...         else:
...             return "+04"
...
...     def  __repr__(self):
...         return f"{self.__class__.__name__}()"
...
>>> tz1 = KabulTz()
>>> # Datetime before the change
>>> dt1 = datetime(1900, 11, 21, 16, 30, tzinfo=tz1)
>>> print(dt1.utcoffset())
4:00:00
>>> # Datetime after the change
>>> dt2 = datetime(2006, 6, 14, 13, 0, tzinfo=tz1)
>>> print(dt2.utcoffset())
4:30:00
>>> # Convert datetime to another time zone
>>> dt3 = dt2.astimezone(timezone.utc)
>>> dt3
datetime.datetime(2006, 6, 14, 8, 30, tzinfo=datetime.timezone.utc)
>>> dt2
datetime.datetime(2006, 6, 14, 13, 0, tzinfo=KabulTz())
>>> dt2.utctimetuple() == dt3.utctimetuple()
True


"time" Objects
==============

A time object represents a (local) time of day, independent of any
particular day, and subject to adjustment via a "tzinfo" object.

class datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None, *, fold=0)

   All arguments are optional.  *tzinfo* may be "None", or an instance
   of a "tzinfo" subclass.  The remaining arguments may be integers,
   in the following ranges:

   * "0 <= hour < 24",

   * "0 <= minute < 60",

   * "0 <= second < 60",

   * "0 <= microsecond < 1000000",

   * "fold in [0, 1]".

   If an argument outside those ranges is given, "ValueError" is
   raised.  All default to "0" except *tzinfo*, which defaults to
   "None".

类属性：

time.min

   The earliest representable "time", "time(0, 0, 0, 0)".

time.max

   The latest representable "time", "time(23, 59, 59, 999999)".

time.resolution

   The smallest possible difference between non-equal "time" objects,
   "timedelta(microseconds=1)", although note that arithmetic on
   "time" objects is not supported.

实例属性（只读）：

time.hour

   In "range(24)".

time.minute

   In "range(60)".

time.second

   In "range(60)".

time.microsecond

   In "range(1000000)".

time.tzinfo

   The object passed as the tzinfo argument to the "time" constructor,
   or "None" if none was passed.

time.fold

   In "[0, 1]".  Used to disambiguate wall times during a repeated
   interval.  (A repeated interval occurs when clocks are rolled back
   at the end of daylight saving time or when the UTC offset for the
   current zone is decreased for political reasons.) The value 0 (1)
   represents the earlier (later) of the two moments with the same
   wall time representation.

   3.6 新版功能.

支持的运算：

* comparison of "time" to "time", where *a* is considered less than
  *b* when *a* precedes *b* in time.  If one comparand is naive and
  the other is aware, "TypeError" is raised if an order comparison is
  attempted. For equality comparisons, naive instances are never equal
  to aware instances.

  If both comparands are aware, and have the same "tzinfo" attribute,
  the common "tzinfo" attribute is ignored and the base times are
  compared.  If both comparands are aware and have different "tzinfo"
  attributes, the comparands are first adjusted by subtracting their
  UTC offsets (obtained from "self.utcoffset()"). In order to stop
  mixed-type comparisons from falling back to the default comparison
  by object address, when a "time" object is compared to an object of
  a different type, "TypeError" is raised unless the comparison is
  "==" or "!=".  The latter cases return "False" or "True",
  respectively.

  在 3.3 版更改: Equality comparisons between naive and aware "time"
  instances don't raise "TypeError".

* hash, use as dict key

* efficient pickling

In boolean contexts, a "time" object is always considered to be true.

在 3.5 版更改: Before Python 3.5, a "time" object was considered to be
false if it represented midnight in UTC.  This behavior was considered
obscure and error-prone and has been removed in Python 3.5.  See
bpo-13936 for full details.

Other constructor:

classmethod time.fromisoformat(time_string)

   Return a "time" corresponding to a *time_string* in one of the
   formats emitted by "time.isoformat()". Specifically, this function
   supports strings in the format(s)
   "HH[:MM[:SS[.fff[fff]]]][+HH:MM[:SS[.ffffff]]]".

   警告: This does not support parsing arbitrary ISO 8601 strings -
     it is only intended as the inverse operation of
     "time.isoformat()".

   3.7 新版功能.

实例方法：

time.replace(hour=self.hour, minute=self.minute, second=self.second, microsecond=self.microsecond, tzinfo=self.tzinfo, * fold=0)

   Return a "time" with the same value, except for those attributes
   given new values by whichever keyword arguments are specified.
   Note that "tzinfo=None" can be specified to create a naive "time"
   from an aware "time", without conversion of the time data.

   3.6 新版功能: 增加了 "fold" 参数。

time.isoformat(timespec='auto')

   Return a string representing the time in ISO 8601 format,
   HH:MM:SS.ffffff or, if "microsecond" is 0, HH:MM:SS If
   "utcoffset()" does not return "None", a string is appended, giving
   the UTC offset: HH:MM:SS.ffffff+HH:MM[:SS[.ffffff]] or, if
   self.microsecond is 0, HH:MM:SS+HH:MM[:SS[.ffffff]].

   The optional argument *timespec* specifies the number of additional
   components of the time to include (the default is "'auto'"). It can
   be one of the following:

   * "'auto'": Same as "'seconds'" if "microsecond" is 0, same as
     "'microseconds'" otherwise.

   * "'hours'": Include the "hour" in the two-digit HH format.

   * "'minutes'": Include "hour" and "minute" in HH:MM format.

   * "'seconds'": Include "hour", "minute", and "second" in HH:MM:SS
     format.

   * "'milliseconds'": Include full time, but truncate fractional
     second part to milliseconds. HH:MM:SS.sss format.

   * "'microseconds'": Include full time in HH:MM:SS.ffffff format.

   注解: Excluded time components are truncated, not rounded.

   "ValueError" will be raised on an invalid *timespec* argument.

   >>> from datetime import time
   >>> time(hour=12, minute=34, second=56, microsecond=123456).isoformat(timespec='minutes')
   '12:34'
   >>> dt = time(hour=12, minute=34, second=56, microsecond=0)
   >>> dt.isoformat(timespec='microseconds')
   '12:34:56.000000'
   >>> dt.isoformat(timespec='auto')
   '12:34:56'

   3.6 新版功能: Added the *timespec* argument.

time.__str__()

   For a time *t*, "str(t)" is equivalent to "t.isoformat()".

time.strftime(format)

   Return a string representing the time, controlled by an explicit
   format string.  For a complete list of formatting directives, see
   strftime() and strptime() Behavior.

time.__format__(format)

   Same as "time.strftime()". This makes it possible to specify a
   format string for a "time" object in formatted string literals and
   when using "str.format()".  For a complete list of formatting
   directives, see strftime() and strptime() Behavior.

time.utcoffset()

   If "tzinfo" is "None", returns "None", else returns
   "self.tzinfo.utcoffset(None)", and raises an exception if the
   latter doesn't return "None" or a "timedelta" object with magnitude
   less than one day.

   在 3.7 版更改: The UTC offset is not restricted to a whole number
   of minutes.

time.dst()

   If "tzinfo" is "None", returns "None", else returns
   "self.tzinfo.dst(None)", and raises an exception if the latter
   doesn't return "None", or a "timedelta" object with magnitude less
   than one day.

   在 3.7 版更改: The DST offset is not restricted to a whole number
   of minutes.

time.tzname()

   If "tzinfo" is "None", returns "None", else returns
   "self.tzinfo.tzname(None)", or raises an exception if the latter
   doesn't return "None" or a string object.

示例:

>>> from datetime import time, tzinfo, timedelta
>>> class TZ1(tzinfo):
...     def utcoffset(self, dt):
...         return timedelta(hours=1)
...     def dst(self, dt):
...         return timedelta(0)
...     def tzname(self,dt):
...         return "+01:00"
...     def  __repr__(self):
...         return f"{self.__class__.__name__}()"
...
>>> t = time(12, 10, 30, tzinfo=TZ1())
>>> t
datetime.time(12, 10, 30, tzinfo=TZ1())
>>> t.isoformat()
'12:10:30+01:00'
>>> t.dst()
datetime.timedelta(0)
>>> t.tzname()
'+01:00'
>>> t.strftime("%H:%M:%S %Z")
'12:10:30 +01:00'
>>> 'The {} is {:%H:%M}.'.format("time", t)
'The time is 12:10.'


"tzinfo" 对象
=============

class datetime.tzinfo

   This is an abstract base class, meaning that this class should not
   be instantiated directly.  You need to derive a concrete subclass,
   and (at least) supply implementations of the standard "tzinfo"
   methods needed by the "datetime" methods you use.  The "datetime"
   module supplies a simple concrete subclass of "tzinfo", "timezone",
   which can represent timezones with fixed offset from UTC such as
   UTC itself or North American EST and EDT.

   An instance of (a concrete subclass of) "tzinfo" can be passed to
   the constructors for "datetime" and "time" objects. The latter
   objects view their attributes as being in local time, and the
   "tzinfo" object supports methods revealing offset of local time
   from UTC, the name of the time zone, and DST offset, all relative
   to a date or time object passed to them.

   Special requirement for pickling:  A "tzinfo" subclass must have an
   "__init__()" method that can be called with no arguments, else it
   can be pickled but possibly not unpickled again.  This is a
   technical requirement that may be relaxed in the future.

   A concrete subclass of "tzinfo" may need to implement the following
   methods.  Exactly which methods are needed depends on the uses made
   of aware "datetime" objects.  If in doubt, simply implement all of
   them.

tzinfo.utcoffset(dt)

   Return offset of local time from UTC, as a "timedelta" object that
   is positive east of UTC.  If local time is west of UTC, this should
   be negative.  Note that this is intended to be the total offset
   from UTC; for example, if a "tzinfo" object represents both time
   zone and DST adjustments, "utcoffset()" should return their sum.
   If the UTC offset isn't known, return "None".  Else the value
   returned must be a "timedelta" object strictly between
   "-timedelta(hours=24)" and "timedelta(hours=24)" (the magnitude of
   the offset must be less than one day).  Most implementations of
   "utcoffset()" will probably look like one of these two:

      return CONSTANT                 # fixed-offset class
      return CONSTANT + self.dst(dt)  # daylight-aware class

   If "utcoffset()" does not return "None", "dst()" should not return
   "None" either.

   The default implementation of "utcoffset()" raises
   "NotImplementedError".

   在 3.7 版更改: The UTC offset is not restricted to a whole number
   of minutes.

tzinfo.dst(dt)

   Return the daylight saving time (DST) adjustment, as a "timedelta"
   object or "None" if DST information isn't known.  Return
   "timedelta(0)" if DST is not in effect. If DST is in effect, return
   the offset as a "timedelta" object (see "utcoffset()" for details).
   Note that DST offset, if applicable, has already been added to the
   UTC offset returned by "utcoffset()", so there's no need to consult
   "dst()" unless you're interested in obtaining DST info separately.
   For example, "datetime.timetuple()" calls its "tzinfo" attribute's
   "dst()" method to determine how the "tm_isdst" flag should be set,
   and "tzinfo.fromutc()" calls "dst()" to account for DST changes
   when crossing time zones.

   An instance *tz* of a "tzinfo" subclass that models both standard
   and daylight times must be consistent in this sense:

   "tz.utcoffset(dt) - tz.dst(dt)"

   must return the same result for every "datetime" *dt* with
   "dt.tzinfo == tz"  For sane "tzinfo" subclasses, this expression
   yields the time zone's "standard offset", which should not depend
   on the date or the time, but only on geographic location.  The
   implementation of "datetime.astimezone()" relies on this, but
   cannot detect violations; it's the programmer's responsibility to
   ensure it.  If a "tzinfo" subclass cannot guarantee this, it may be
   able to override the default implementation of "tzinfo.fromutc()"
   to work correctly with "astimezone()" regardless.

   Most implementations of "dst()" will probably look like one of
   these two:

      def dst(self, dt):
          # a fixed-offset class:  doesn't account for DST
          return timedelta(0)

   or

      def dst(self, dt):
          # Code to set dston and dstoff to the time zone's DST
          # transition times based on the input dt.year, and expressed
          # in standard local time.  Then

          if dston <= dt.replace(tzinfo=None) < dstoff:
              return timedelta(hours=1)
          else:
              return timedelta(0)

   The default implementation of "dst()" raises "NotImplementedError".

   在 3.7 版更改: The DST offset is not restricted to a whole number
   of minutes.

tzinfo.tzname(dt)

   Return the time zone name corresponding to the "datetime" object
   *dt*, as a string. Nothing about string names is defined by the
   "datetime" module, and there's no requirement that it mean anything
   in particular.  For example, "GMT", "UTC", "-500", "-5:00", "EDT",
   "US/Eastern", "America/New York" are all valid replies.  Return
   "None" if a string name isn't known.  Note that this is a method
   rather than a fixed string primarily because some "tzinfo"
   subclasses will wish to return different names depending on the
   specific value of *dt* passed, especially if the "tzinfo" class is
   accounting for daylight time.

   The default implementation of "tzname()" raises
   "NotImplementedError".

These methods are called by a "datetime" or "time" object, in response
to their methods of the same names.  A "datetime" object passes itself
as the argument, and a "time" object passes "None" as the argument.  A
"tzinfo" subclass's methods should therefore be prepared to accept a
*dt* argument of "None", or of class "datetime".

When "None" is passed, it's up to the class designer to decide the
best response.  For example, returning "None" is appropriate if the
class wishes to say that time objects don't participate in the
"tzinfo" protocols.  It may be more useful for "utcoffset(None)" to
return the standard UTC offset, as there is no other convention for
discovering the standard offset.

When a "datetime" object is passed in response to a "datetime" method,
"dt.tzinfo" is the same object as *self*.  "tzinfo" methods can rely
on this, unless user code calls "tzinfo" methods directly.  The intent
is that the "tzinfo" methods interpret *dt* as being in local time,
and not need worry about objects in other timezones.

There is one more "tzinfo" method that a subclass may wish to
override:

tzinfo.fromutc(dt)

   This is called from the default "datetime.astimezone()"
   implementation.  When called from that, "dt.tzinfo" is *self*, and
   *dt*'s date and time data are to be viewed as expressing a UTC
   time.  The purpose of "fromutc()" is to adjust the date and time
   data, returning an equivalent datetime in *self*'s local time.

   Most "tzinfo" subclasses should be able to inherit the default
   "fromutc()" implementation without problems.  It's strong enough to
   handle fixed-offset time zones, and time zones accounting for both
   standard and daylight time, and the latter even if the DST
   transition times differ in different years.  An example of a time
   zone the default "fromutc()" implementation may not handle
   correctly in all cases is one where the standard offset (from UTC)
   depends on the specific date and time passed, which can happen for
   political reasons. The default implementations of "astimezone()"
   and "fromutc()" may not produce the result you want if the result
   is one of the hours straddling the moment the standard offset
   changes.

   Skipping code for error cases, the default "fromutc()"
   implementation acts like:

      def fromutc(self, dt):
          # raise ValueError error if dt.tzinfo is not self
          dtoff = dt.utcoffset()
          dtdst = dt.dst()
          # raise ValueError if dtoff is None or dtdst is None
          delta = dtoff - dtdst  # this is self's standard offset
          if delta:
              dt += delta   # convert to standard local time
              dtdst = dt.dst()
              # raise ValueError if dtdst is None
          if dtdst:
              return dt + dtdst
          else:
              return dt

In the following "tzinfo_examples.py" file there are some examples of
"tzinfo" classes:

   from datetime import tzinfo, timedelta, datetime

   ZERO = timedelta(0)
   HOUR = timedelta(hours=1)
   SECOND = timedelta(seconds=1)

   # A class capturing the platform's idea of local time.
   # (May result in wrong values on historical times in
   #  timezones where UTC offset and/or the DST rules had
   #  changed in the past.)
   import time as _time

   STDOFFSET = timedelta(seconds = -_time.timezone)
   if _time.daylight:
       DSTOFFSET = timedelta(seconds = -_time.altzone)
   else:
       DSTOFFSET = STDOFFSET

   DSTDIFF = DSTOFFSET - STDOFFSET

   class LocalTimezone(tzinfo):

       def fromutc(self, dt):
           assert dt.tzinfo is self
           stamp = (dt - datetime(1970, 1, 1, tzinfo=self)) // SECOND
           args = _time.localtime(stamp)[:6]
           dst_diff = DSTDIFF // SECOND
           # Detect fold
           fold = (args == _time.localtime(stamp - dst_diff))
           return datetime(*args, microsecond=dt.microsecond,
                           tzinfo=self, fold=fold)

       def utcoffset(self, dt):
           if self._isdst(dt):
               return DSTOFFSET
           else:
               return STDOFFSET

       def dst(self, dt):
           if self._isdst(dt):
               return DSTDIFF
           else:
               return ZERO

       def tzname(self, dt):
           return _time.tzname[self._isdst(dt)]

       def _isdst(self, dt):
           tt = (dt.year, dt.month, dt.day,
                 dt.hour, dt.minute, dt.second,
                 dt.weekday(), 0, 0)
           stamp = _time.mktime(tt)
           tt = _time.localtime(stamp)
           return tt.tm_isdst > 0

   Local = LocalTimezone()


   # A complete implementation of current DST rules for major US time zones.

   def first_sunday_on_or_after(dt):
       days_to_go = 6 - dt.weekday()
       if days_to_go:
           dt += timedelta(days_to_go)
       return dt


   # US DST Rules
   #
   # This is a simplified (i.e., wrong for a few cases) set of rules for US
   # DST start and end times. For a complete and up-to-date set of DST rules
   # and timezone definitions, visit the Olson Database (or try pytz):
   # http://www.twinsun.com/tz/tz-link.htm
   # http://sourceforge.net/projects/pytz/ (might not be up-to-date)
   #
   # In the US, since 2007, DST starts at 2am (standard time) on the second
   # Sunday in March, which is the first Sunday on or after Mar 8.
   DSTSTART_2007 = datetime(1, 3, 8, 2)
   # and ends at 2am (DST time) on the first Sunday of Nov.
   DSTEND_2007 = datetime(1, 11, 1, 2)
   # From 1987 to 2006, DST used to start at 2am (standard time) on the first
   # Sunday in April and to end at 2am (DST time) on the last
   # Sunday of October, which is the first Sunday on or after Oct 25.
   DSTSTART_1987_2006 = datetime(1, 4, 1, 2)
   DSTEND_1987_2006 = datetime(1, 10, 25, 2)
   # From 1967 to 1986, DST used to start at 2am (standard time) on the last
   # Sunday in April (the one on or after April 24) and to end at 2am (DST time)
   # on the last Sunday of October, which is the first Sunday
   # on or after Oct 25.
   DSTSTART_1967_1986 = datetime(1, 4, 24, 2)
   DSTEND_1967_1986 = DSTEND_1987_2006

   def us_dst_range(year):
       # Find start and end times for US DST. For years before 1967, return
       # start = end for no DST.
       if 2006 < year:
           dststart, dstend = DSTSTART_2007, DSTEND_2007
       elif 1986 < year < 2007:
           dststart, dstend = DSTSTART_1987_2006, DSTEND_1987_2006
       elif 1966 < year < 1987:
           dststart, dstend = DSTSTART_1967_1986, DSTEND_1967_1986
       else:
           return (datetime(year, 1, 1), ) * 2

       start = first_sunday_on_or_after(dststart.replace(year=year))
       end = first_sunday_on_or_after(dstend.replace(year=year))
       return start, end


   class USTimeZone(tzinfo):

       def __init__(self, hours, reprname, stdname, dstname):
           self.stdoffset = timedelta(hours=hours)
           self.reprname = reprname
           self.stdname = stdname
           self.dstname = dstname

       def __repr__(self):
           return self.reprname

       def tzname(self, dt):
           if self.dst(dt):
               return self.dstname
           else:
               return self.stdname

       def utcoffset(self, dt):
           return self.stdoffset + self.dst(dt)

       def dst(self, dt):
           if dt is None or dt.tzinfo is None:
               # An exception may be sensible here, in one or both cases.
               # It depends on how you want to treat them.  The default
               # fromutc() implementation (called by the default astimezone()
               # implementation) passes a datetime with dt.tzinfo is self.
               return ZERO
           assert dt.tzinfo is self
           start, end = us_dst_range(dt.year)
           # Can't compare naive to aware objects, so strip the timezone from
           # dt first.
           dt = dt.replace(tzinfo=None)
           if start + HOUR <= dt < end - HOUR:
               # DST is in effect.
               return HOUR
           if end - HOUR <= dt < end:
               # Fold (an ambiguous hour): use dt.fold to disambiguate.
               return ZERO if dt.fold else HOUR
           if start <= dt < start + HOUR:
               # Gap (a non-existent hour): reverse the fold rule.
               return HOUR if dt.fold else ZERO
           # DST is off.
           return ZERO

       def fromutc(self, dt):
           assert dt.tzinfo is self
           start, end = us_dst_range(dt.year)
           start = start.replace(tzinfo=self)
           end = end.replace(tzinfo=self)
           std_time = dt + self.stdoffset
           dst_time = std_time + HOUR
           if end <= dst_time < end + HOUR:
               # Repeated hour
               return std_time.replace(fold=1)
           if std_time < start or dst_time >= end:
               # Standard time
               return std_time
           if start <= std_time < end - HOUR:
               # Daylight saving time
               return dst_time


   Eastern  = USTimeZone(-5, "Eastern",  "EST", "EDT")
   Central  = USTimeZone(-6, "Central",  "CST", "CDT")
   Mountain = USTimeZone(-7, "Mountain", "MST", "MDT")
   Pacific  = USTimeZone(-8, "Pacific",  "PST", "PDT")

Note that there are unavoidable subtleties twice per year in a
"tzinfo" subclass accounting for both standard and daylight time, at
the DST transition points.  For concreteness, consider US Eastern (UTC
-0500), where EDT begins the minute after 1:59 (EST) on the second
Sunday in March, and ends the minute after 1:59 (EDT) on the first
Sunday in November:

     UTC   3:MM  4:MM  5:MM  6:MM  7:MM  8:MM
     EST  22:MM 23:MM  0:MM  1:MM  2:MM  3:MM
     EDT  23:MM  0:MM  1:MM  2:MM  3:MM  4:MM

   start  22:MM 23:MM  0:MM  1:MM  3:MM  4:MM

     end  23:MM  0:MM  1:MM  1:MM  2:MM  3:MM

When DST starts (the "start" line), the local wall clock leaps from
1:59 to 3:00.  A wall time of the form 2:MM doesn't really make sense
on that day, so "astimezone(Eastern)" won't deliver a result with
"hour == 2" on the day DST begins.  For example, at the Spring forward
transition of 2016, we get

>>> from datetime import datetime, timezone
>>> from tzinfo_examples import HOUR, Eastern
>>> u0 = datetime(2016, 3, 13, 5, tzinfo=timezone.utc)
>>> for i in range(4):
...     u = u0 + i*HOUR
...     t = u.astimezone(Eastern)
...     print(u.time(), 'UTC =', t.time(), t.tzname())
...
05:00:00 UTC = 00:00:00 EST
06:00:00 UTC = 01:00:00 EST
07:00:00 UTC = 03:00:00 EDT
08:00:00 UTC = 04:00:00 EDT

When DST ends (the "end" line), there's a potentially worse problem:
there's an hour that can't be spelled unambiguously in local wall
time: the last hour of daylight time.  In Eastern, that's times of the
form 5:MM UTC on the day daylight time ends.  The local wall clock
leaps from 1:59 (daylight time) back to 1:00 (standard time) again.
Local times of the form 1:MM are ambiguous. "astimezone()" mimics the
local clock's behavior by mapping two adjacent UTC hours into the same
local hour then.  In the Eastern example, UTC times of the form 5:MM
and 6:MM both map to 1:MM when converted to Eastern, but earlier times
have the "fold" attribute set to 0 and the later times have it set to
1. For example, at the Fall back transition of 2016, we get

>>> u0 = datetime(2016, 11, 6, 4, tzinfo=timezone.utc)
>>> for i in range(4):
...     u = u0 + i*HOUR
...     t = u.astimezone(Eastern)
...     print(u.time(), 'UTC =', t.time(), t.tzname(), t.fold)
...
04:00:00 UTC = 00:00:00 EDT 0
05:00:00 UTC = 01:00:00 EDT 0
06:00:00 UTC = 01:00:00 EST 1
07:00:00 UTC = 02:00:00 EST 0

Note that the "datetime" instances that differ only by the value of
the "fold" attribute are considered equal in comparisons.

Applications that can't bear wall-time ambiguities should explicitly
check the value of the "fold" attribute or avoid using hybrid "tzinfo"
subclasses; there are no ambiguities when using "timezone", or any
other fixed-offset "tzinfo" subclass (such as a class representing
only EST (fixed offset -5 hours), or only EDT (fixed offset -4
hours)).

参见:

  dateutil.tz
     The standard library has "timezone" class for handling arbitrary
     fixed offsets from UTC and "timezone.utc" as UTC timezone
     instance.

     *dateutil.tz* library brings the *IANA timezone database* (also
     known as the Olson database) to Python and its usage is
     recommended.

  IANA timezone database
     The Time Zone Database (often called tz, tzdata or zoneinfo)
     contains code and data that represent the history of local time
     for many representative locations around the globe. It is updated
     periodically to reflect changes made by political bodies to time
     zone boundaries, UTC offsets, and daylight-saving rules.


"timezone" Objects
==================

The "timezone" class is a subclass of "tzinfo", each instance of which
represents a timezone defined by a fixed offset from UTC.  Note that
objects of this class cannot be used to represent timezone information
in the locations where different offsets are used in different days of
the year or where historical changes have been made to civil time.

class datetime.timezone(offset, name=None)

   The *offset* argument must be specified as a "timedelta" object
   representing the difference between the local time and UTC.  It
   must be strictly between "-timedelta(hours=24)" and
   "timedelta(hours=24)", otherwise "ValueError" is raised.

   The *name* argument is optional.  If specified it must be a string
   that will be used as the value returned by the "datetime.tzname()"
   method.

   3.2 新版功能.

   在 3.7 版更改: The UTC offset is not restricted to a whole number
   of minutes.

timezone.utcoffset(dt)

   Return the fixed value specified when the "timezone" instance is
   constructed.  The *dt* argument is ignored.  The return value is a
   "timedelta" instance equal to the difference between the local time
   and UTC.

   在 3.7 版更改: The UTC offset is not restricted to a whole number
   of minutes.

timezone.tzname(dt)

   Return the fixed value specified when the "timezone" instance is
   constructed.  If *name* is not provided in the constructor, the
   name returned by "tzname(dt)" is generated from the value of the
   "offset" as follows.  If *offset* is "timedelta(0)", the name is
   "UTC", otherwise it is a string 'UTC±HH:MM', where ± is the sign of
   "offset", HH and MM are two digits of "offset.hours" and
   "offset.minutes" respectively.

   在 3.6 版更改: Name generated from "offset=timedelta(0)" is now
   plain 'UTC', not 'UTC+00:00'.

timezone.dst(dt)

   Always returns "None".

timezone.fromutc(dt)

   Return "dt + offset".  The *dt* argument must be an aware
   "datetime" instance, with "tzinfo" set to "self".

类属性：

timezone.utc

   The UTC timezone, "timezone(timedelta(0))".


"strftime()" and "strptime()" Behavior
======================================

"date", "datetime", and "time" objects all support a
"strftime(format)" method, to create a string representing the time
under the control of an explicit format string.  Broadly speaking,
"d.strftime(fmt)" acts like the "time" module's "time.strftime(fmt,
d.timetuple())" although not all objects support a "timetuple()"
method.

Conversely, the "datetime.strptime()" class method creates a
"datetime" object from a string representing a date and time and a
corresponding format string. "datetime.strptime(date_string, format)"
is equivalent to "datetime(*(time.strptime(date_string,
format)[0:6]))", except when the format includes sub-second components
or timezone offset information, which are supported in
"datetime.strptime" but are discarded by "time.strptime".

For "time" objects, the format codes for year, month, and day should
not be used, as time objects have no such values.  If they're used
anyway, "1900" is substituted for the year, and "1" for the month and
day.

For "date" objects, the format codes for hours, minutes, seconds, and
microseconds should not be used, as "date" objects have no such
values.  If they're used anyway, "0" is substituted for them.

For the "datetime.strptime()" class method, the default value is
"1900-01-01T00:00:00.000": any components not specified in the format
string will be pulled from the default value. [2]

The full set of format codes supported varies across platforms,
because Python calls the platform C library's "strftime()" function,
and platform variations are common.  To see the full set of format
codes supported on your platform, consult the *strftime(3)*
documentation.

For the same reason, handling of format strings containing Unicode
code points that can't be represented in the charset of the current
locale is also platform-dependent. On some platforms such code points
are preserved intact in the output, while on others "strftime" may
raise "UnicodeError" or return an empty string instead.

The following is a list of all the format codes that the C standard
(1989 version) requires, and these work on all platforms with a
standard C implementation.  Note that the 1999 version of the C
standard added additional format codes.

+-------------+----------------------------------+--------------------------+---------+
| 指令        | 意义                             | 示例                     | 注释    |
|=============|==================================|==========================|=========|
| "%a"        | 当地工作日的缩写。               | Sun, Mon, ..., Sat (美国 | (1)     |
|             |                                  | ); So, Mo, ..., Sa (德国 |         |
|             |                                  | )                        |         |
+-------------+----------------------------------+--------------------------+---------+
| "%A"        | 当地工作日的全名。               | Sunday, Monday, ...,     | (1)     |
|             |                                  | Saturday (美国);         |         |
|             |                                  | Sonntag, Montag, ...,    |         |
|             |                                  | Samstag (德国)           |         |
+-------------+----------------------------------+--------------------------+---------+
| "%w"        | 以十进制数显示的工作日，其中0表  | 0, 1, ..., 6             |         |
|             | 示星期日，6表示星期六。          |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%d"        | 补零后，以十进制数显示的月份中的 | 01, 02, ..., 31          | (9)     |
|             | 一天。                           |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%b"        | 当地月份的缩写。                 | Jan, Feb, ..., Dec (美国 | (1)     |
|             |                                  | ); Jan, Feb, ..., Dez (  |         |
|             |                                  | 德国)                    |         |
+-------------+----------------------------------+--------------------------+---------+
| "%B"        | 当地月份的全名。                 | January, February, ...,  | (1)     |
|             |                                  | December (美国); Januar, |         |
|             |                                  | Februar, ..., Dezember ( |         |
|             |                                  | 德国)                    |         |
+-------------+----------------------------------+--------------------------+---------+
| "%m"        | 补零后，以十进制数显示的月份。   | 01, 02, ..., 12          | (9)     |
+-------------+----------------------------------+--------------------------+---------+
| "%y"        | 补零后，以十进制数表示的，不带世 | 00, 01, ..., 99          | (9)     |
|             | 纪的年份。                       |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%Y"        | 十进制数表示的带世纪的年份。     | 0001, 0002, ..., 2013,   | (2)     |
|             |                                  | 2014, ..., 9998, 9999    |         |
+-------------+----------------------------------+--------------------------+---------+
| "%H"        | Hour (24-hour clock) as a zero-  | 00, 01, ..., 23          | (9)     |
|             | padded decimal number.           |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%I"        | Hour (12-hour clock) as a zero-  | 01, 02, ..., 12          | (9)     |
|             | padded decimal number.           |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%p"        | 本地化的 AM 或 PM 。             | AM, PM (美国); am, pm (  | (1),    |
|             |                                  | 德国)                    | (3)     |
+-------------+----------------------------------+--------------------------+---------+
| "%M"        | 补零后，以十进制数显示的分钟。   | 00, 01, ..., 59          | (9)     |
+-------------+----------------------------------+--------------------------+---------+
| "%S"        | 补零后，以十进制数显示的秒。     | 00, 01, ..., 59          | (4),    |
|             |                                  |                          | (9)     |
+-------------+----------------------------------+--------------------------+---------+
| "%f"        | Microsecond as a decimal number, | 000000, 000001, ...,     | (5)     |
|             | zero-padded on the left.         | 999999                   |         |
+-------------+----------------------------------+--------------------------+---------+
| "%z"        | UTC offset in the form           | (empty), +0000, -0400,   | (6)     |
|             | ±HHMM[SS[.ffffff]] (empty string | +1030, +063415,          |         |
|             | if the object is naive).         | -030712.345216           |         |
+-------------+----------------------------------+--------------------------+---------+
| "%Z"        | Time zone name (empty string if  | (empty), UTC, EST, CST   |         |
|             | the object is naive).            |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%j"        | Day of the year as a zero-padded | 001, 002, ..., 366       | (9)     |
|             | decimal number.                  |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%U"        | Week number of the year (Sunday  | 00, 01, ..., 53          | (7),    |
|             | as the first day of the week) as |                          | (9)     |
|             | a zero padded decimal number.    |                          |         |
|             | All days in a new year preceding |                          |         |
|             | the first Sunday are considered  |                          |         |
|             | to be in week 0.                 |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%W"        | Week number of the year (Monday  | 00, 01, ..., 53          | (7),    |
|             | as the first day of the week) as |                          | (9)     |
|             | a decimal number. All days in a  |                          |         |
|             | new year preceding the first     |                          |         |
|             | Monday are considered to be in   |                          |         |
|             | week 0.                          |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%c"        | 本地化的适当日期和时间表示。     | Tue Aug 16 21:30:00 1988 | (1)     |
|             |                                  | (美国); Di 16 Aug        |         |
|             |                                  | 21:30:00 1988 (德国)     |         |
+-------------+----------------------------------+--------------------------+---------+
| "%x"        | 本地化的适当日期表示。           | 08/16/88 (None);         | (1)     |
|             |                                  | 08/16/1988 (en_US);      |         |
|             |                                  | 16.08.1988 (de_DE)       |         |
+-------------+----------------------------------+--------------------------+---------+
| "%X"        | 本地化的适当时间表示。           | 21:30:00 (en_US);        | (1)     |
|             |                                  | 21:30:00 (de_DE)         |         |
+-------------+----------------------------------+--------------------------+---------+
| "%%"        | 字面的 "'%'" 字符。              | %                        |         |
+-------------+----------------------------------+--------------------------+---------+

Several additional directives not required by the C89 standard are
included for convenience. These parameters all correspond to ISO 8601
date values. These may not be available on all platforms when used
with the "strftime()" method. The ISO 8601 year and ISO 8601 week
directives are not interchangeable with the year and week number
directives above. Calling "strptime()" with incomplete or ambiguous
ISO 8601 directives will raise a "ValueError".

+-------------+----------------------------------+--------------------------+---------+
| 指令        | 意义                             | 示例                     | 注释    |
|=============|==================================|==========================|=========|
| "%G"        | ISO 8601 year with century       | 0001, 0002, ..., 2013,   | (8)     |
|             | representing the year that       | 2014, ..., 9998, 9999    |         |
|             | contains the greater part of the |                          |         |
|             | ISO week ("%V").                 |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%u"        | ISO 8601 weekday as a decimal    | 1, 2, ..., 7             |         |
|             | number where 1 is Monday.        |                          |         |
+-------------+----------------------------------+--------------------------+---------+
| "%V"        | ISO 8601 week as a decimal       | 01, 02, ..., 53          | (8),    |
|             | number with Monday as the first  |                          | (9)     |
|             | day of the week. Week 01 is the  |                          |         |
|             | week containing Jan 4.           |                          |         |
+-------------+----------------------------------+--------------------------+---------+

3.6 新版功能: 增加了 "%G",  "%u"  和 "%V"。

注释:

1. Because the format depends on the current locale, care should be
   taken when making assumptions about the output value. Field
   orderings will vary (for example, "month/day/year" versus
   "day/month/year"), and the output may contain Unicode characters
   encoded using the locale's default encoding (for example, if the
   current locale is "ja_JP", the default encoding could be any one of
   "eucJP", "SJIS", or "utf-8"; use "locale.getlocale()" to determine
   the current locale's encoding).

2. The "strptime()" method can parse years in the full [1, 9999]
   range, but years < 1000 must be zero-filled to 4-digit width.

   在 3.2 版更改: In previous versions, "strftime()" method was
   restricted to years >= 1900.

   在 3.3 版更改: 在版本3.2中，"strftime()" 方法只限于 years >= 1000。

3. When used with the "strptime()" method, the "%p" directive only
   affects the output hour field if the "%I" directive is used to
   parse the hour.

4. 与 "time" 模块不同的是， "datetime" 模块不支持闰秒。

5. When used with the "strptime()" method, the "%f" directive
   accepts from one to six digits and zero pads on the right.  "%f" is
   an extension to the set of format characters in the C standard (but
   implemented separately in datetime objects, and therefore always
   available).

6. For a naive object, the "%z" and "%Z" format codes are replaced
   by empty strings.

   对于一个觉悟型对象而言：

   "%z"
      "utcoffset()" is transformed into a string of the form
      ±HHMM[SS[.ffffff]], where HH is a 2-digit string giving the
      number of UTC offset hours, MM is a 2-digit string giving the
      number of UTC offset minutes, SS is a 2-digit string giving the
      number of UTC offset seconds and ffffff is a 6-digit string
      giving the number of UTC offset microseconds.  The ffffff part
      is omitted when the offset is a whole number of seconds and both
      the ffffff and the SS part is omitted when the offset is a whole
      number of minutes.  For example, if "utcoffset()" returns
      "timedelta(hours=-3, minutes=-30)", "%z" is replaced with the
      string "'-0330'".

   在 3.7 版更改: The UTC offset is not restricted to a whole number
   of minutes.

   在 3.7 版更改: When the "%z" directive is provided to the
   "strptime()" method, the UTC offsets can have a colon as a
   separator between hours, minutes and seconds. For example,
   "'+01:00:00'" will be parsed as an offset of one hour. In addition,
   providing "'Z'" is identical to "'+00:00'".

   "%Z"
      If "tzname()" returns "None", "%Z" is replaced by an empty
      string.  Otherwise "%Z" is replaced by the returned value, which
      must be a string.

   在 3.2 版更改: When the "%z" directive is provided to the
   "strptime()" method, an aware "datetime" object will be produced.
   The "tzinfo" of the result will be set to a "timezone" instance.

7. When used with the "strptime()" method, "%U" and "%W" are only
   used in calculations when the day of the week and the calendar year
   ("%Y") are specified.

8. Similar to "%U" and "%W", "%V" is only used in calculations when
   the day of the week and the ISO year ("%G") are specified in a
   "strptime()" format string. Also note that "%G" and "%Y" are not
   interchangeable.

9. When used with the "strptime()" method, the leading zero is
   optional for  formats "%d", "%m", "%H", "%I", "%M", "%S", "%J",
   "%U", "%W", and "%V". Format "%y" does require a leading zero.

-[ 脚注 ]-

[1] If, that is, we ignore the effects of Relativity

[2] Passing "datetime.strptime('Feb 29', '%b %d')" will fail since
    "1900" is not a leap year.
