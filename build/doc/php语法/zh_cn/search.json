[{"type":1,"line":"1. 基本语法"},{"type":3,"line":"1.1 PHP 标记"},{"type":4,"line":"当解析一个文件时，PHP 会寻找起始和结束标记，也就是 _<?php_ 和 _?>_，这告诉 PHP 开始和停止解析二者之间的代码。此种解析方式使得 PHP 可以被嵌入到各种不同的文档中去，而任何起始和结束标记之外的部分都会被 PHP 解析器忽略。"},{"type":4,"line":"PHP 也允许使用短标记 _<?_ 和 _?>_，但不鼓励使用。只有通过激活 php.ini 中的 [short\\_open\\_tag](ini.core.html#ini.short-open-tag) 配置指令或者在编译 PHP 时使用了配置选项 **\\--enable-short-tags** 时才能使用短标记。"},{"type":4,"line":"如果文件内容是纯 PHP 代码，最好在文件末尾删除 PHP 结束标记。这可以避免在 PHP 结束标记之后万一意外加入了空格或者换行符，会导致 PHP 开始输出这些空白，而脚本中此时并无输出的意图。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo \"Hello world\";  "},{"type":4,"line":"  "},{"type":4,"line":"// ... more code  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"Last statement\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 脚本至此结束，并无 PHP 结束标记"},{"type":4,"line":"```"},{"type":3,"line":"1.2 从 HTML 中分离"},{"type":4,"line":"凡是在一对开始和结束标记之外的内容都会被 PHP 解析器忽略，这使得 PHP 文件可以具备混合内容。 可以使 PHP 嵌入到 HTML 文档中去，如下例所示。"},{"type":4,"line":"```php"},{"type":4,"line":"<p>This is going to be ignored by PHP and displayed by the browser.</p>  "},{"type":4,"line":"<?php echo 'While this is going to be parsed.'; ?>  "},{"type":4,"line":"<p>This will also be ignored by PHP and displayed by the browser.</p>"},{"type":4,"line":"```"},{"type":4,"line":"这将如预期中的运行，因为当 PHP 解释器碰到 ?> 结束标记时就简单地将其后内容原样输出（除非马上紧接换行 - 见[指令分隔符](language.basic-syntax.instruction-separation.html)）直到碰到下一个开始标记；例外是处于条件语句中间时，此时 PHP 解释器会根据条件判断来决定哪些输出，哪些跳过。见下例。"},{"type":4,"line":"使用条件结构："},{"type":4,"line":"**Example #1 使用条件的高级分离术**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php if ($expression == true): ?>  "},{"type":4,"line":"  This will show if the expression is true.  "},{"type":4,"line":"<?php else: ?>  "},{"type":4,"line":"  Otherwise this will show.  "},{"type":4,"line":"<?php endif; ?>"},{"type":4,"line":"```"},{"type":4,"line":"上例中 PHP 将跳过条件语句未达成的段落，即使该段落位于 PHP 开始和结束标记之外。由于 PHP 解释器会在条件未达成时直接跳过该段条件语句块，因此 PHP 会根据条件来忽略之。"},{"type":4,"line":"要输出大段文本时，跳出 PHP 解析模式通常比将文本通过 [echo](function.echo.html) 或 [print](function.print.html) 输出更有效率。"},{"type":4,"line":"可以在 PHP 中使用四对不同的开始和结束标记。其中两种，<?php ?> 和 <script language=\"php\"> </script> 总是可用的。另两种是短标记和 ASP 风格标记，可以在 php.ini 配置文件中打开或关闭。尽管有些人觉得短标记和 ASP 风格标记很方便，但移植性较差，通常不推荐使用。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 此外注意如果将 PHP 嵌入到 XML 或 XHTML 中则需要使用 <?php ?> 标记以保持符合标准。"},{"type":4,"line":"**Example #2 PHP 开始和结束标记**"},{"type":4,"line":"```"},{"type":4,"line":"1.  <?php echo 'if you want to serve XHTML or XML documents, do it like this'; ?>  "},{"type":4,"line":"  "},{"type":5,"line":"2.  <script language=\"php\">  "},{"type":5,"line":"        echo 'some editors (like FrontPage) don\\'t  "},{"type":5,"line":"              like processing instructions';  "},{"type":4,"line":"    </script>  "},{"type":4,"line":"  "},{"type":5,"line":"3.  <? echo 'this is the simplest, an SGML processing instruction'; ?>  "},{"type":4,"line":"    <?= expression ?> This is a shortcut for \"<? echo expression ?>\"  "},{"type":4,"line":"  "},{"type":5,"line":"4.  <% echo 'You may optionally use ASP-style tags'; %>  "},{"type":4,"line":"    <%= $variable; # This is a shortcut for \"<% echo . . .\" %>"},{"type":4,"line":"```"},{"type":4,"line":"上例中的 1 和 2 中使用的标记总是可用的，其中示例 1 中是最常用，并建议使用的。"},{"type":4,"line":"短标记（上例 3）仅在通过 php.ini 配置文件中的指令 [short\\_open\\_tag](ini.core.html#ini.short-open-tag) 打开后才可用，或者在 PHP 编译时加入了 **\\--enable-short-tags** 选项。"},{"type":4,"line":"ASP 风格标记（上例 4）仅在通过 php.ini 配置文件中的指令 [asp\\_tags](ini.core.html#ini.asp-tags) 打开后才可用。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在以下情况应避免使用短标记：开发需要再次发布的程序或者库，或者在用户不能控制的服务器上开发。因为目标服务器可能不支持短标记。为了代码的移植及发行，确保不要使用短标记。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在 PHP 5.2 和之前的版本中，解释器不允许一个文件的全部内容就是一个开始标记 _<?php_。自 PHP 5.3 起则允许此种文件，但要开始标记后有一个或更多白空格符。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 自 PHP 5.4 起，短格式的 echo 标记 _<?=_ 总会被识别并且合法，而不管 [short\\_open\\_tag](ini.core.html#ini.short-open-tag) 的设置是什么。"},{"type":3,"line":"1.3 指令分隔符"},{"type":4,"line":"同 C 或 Perl 一样，PHP 需要在每个语句后用分号结束指令。一段 PHP 代码中的结束标记隐含表示了一个分号；在一个 PHP 代码段中的最后一行可以不用分号结束。如果后面还有新行，则代码段的结束标记包含了行结束。"},{"type":4,"line":"```php"},{"type":5,"line":"<?php  "},{"type":4,"line":"    echo \"This is a test\";  "},{"type":4,"line":"?>  "},{"type":4,"line":"  "},{"type":4,"line":"<?php echo \"This is a test\" ?>  "},{"type":4,"line":"  "},{"type":4,"line":"<?php echo 'We omitted the last closing tag';"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 文件末尾的 PHP 代码段结束标记可以不要，有些情况下当使用 [include](function.include.html) 或者 [require](function.require.html) 时省略掉会更好些，这样不期望的空白符就不会出现在文件末尾，之后仍然可以输出响应标头。在使用输出缓冲时也很便利，就不会看到由包含文件生成的不期望的空白符。"},{"type":4,"line":"1.4 注释"},{"type":4,"line":"--"},{"type":4,"line":"PHP 支持 C，C++ 和 Unix Shell 风格（Perl 风格）的注释。例如:"},{"type":4,"line":"```php"},{"type":5,"line":"<?php  "},{"type":5,"line":"    echo \"This is a test\"; // This is a one-line c++ style comment  "},{"type":5,"line":"    /* This is a multi line comment  "},{"type":5,"line":"       yet another line of comment */  "},{"type":5,"line":"    echo \"This is yet another test\";  "},{"type":4,"line":"    echo 'One Final Test'; # This is a one-line shell-style comment  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"单行注释仅仅注释到行末或者当前的 PHP 代码块，视乎哪个首先出现。这意味着在 _// ... ?>_ 或者 _\\# ... ?>_ 之后的 HTML 代码将被显示出来：?> 跳出了 PHP 模式并返回了 HTML 模式，_//_ 或 _#_ 并不能影响到这一点。如果启用了 [asp\\_tags](ini.core.html#ini.asp-tags) 配置选项，其行为和 _// %>_ 或 _\\# %>_ 相同。不过，_</script>_ 标记在单行注释中不会跳出 PHP 模式。"},{"type":4,"line":"```php"},{"type":4,"line":"<h1>This is an <?php # echo 'simple';?> example</h1>  "},{"type":4,"line":"<p>The header above will say 'This is an  example'.</p>"},{"type":4,"line":"```"},{"type":4,"line":"C 风格的注释在碰到第一个 _\\*/_ 时结束。要确保不要嵌套 C 风格的注释。试图注释掉一大块代码时很容易出现该错误。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":" /*  "},{"type":4,"line":"    echo \"This is a test\"; /* This comment will cause a problem */  "},{"type":4,"line":" */  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":1,"line":"10. 命名空间"},{"type":3,"line":"10.1 命名空间概述"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件 _foo.txt_ 可以同时在目录_/home/greg_ 和 _/home/other_ 中存在，但在同一个目录中不能存在两个 _foo.txt_ 文件。另外，在目录 _/home/greg_ 外访问 _foo.txt_ 文件时，我们必须将目录名以及目录分隔符放在文件名之前得到 _/home/greg/foo.txt_。这个原理应用到程序设计领域就是命名空间的概念。"},{"type":4,"line":"在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题："},{"type":4,"line":"1.  用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。"},{"type":4,"line":"2.  为很长的标识符名称(通常是为了缓解第一类问题而定义的)创建一个别名（或简短）的名称，提高源代码的可读性。"},{"type":4,"line":"PHP 命名空间提供了一种将相关的类、函数和常量组合到一起的途径。下面是一个说明 PHP 命名空间语法的示例："},{"type":4,"line":"**Example #1 命名空间语法示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace my\\name; // 参考 \"定义命名空间\" 小节  "},{"type":4,"line":"  "},{"type":4,"line":"class MyClass {}  "},{"type":4,"line":"function myfunction() {}  "},{"type":4,"line":"const MYCONST = 1;  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"$c = new \\my\\name\\MyClass; // 参考 \"全局空间\" 小节  "},{"type":4,"line":"  "},{"type":4,"line":"$a = strlen('hi'); // 参考 \"使用命名空间：后备全局函数/常量\" 小节  "},{"type":4,"line":"  "},{"type":4,"line":"$d = namespace\\MYCONST; // 参考 \"namespace操作符和__NAMESPACE__常量” 小节  "},{"type":4,"line":"  "},{"type":4,"line":"$d = __NAMESPACE__ . '\\MYCONST';  "},{"type":4,"line":"echo constant($d); // 参考 \"命名空间和动态语言特征\" 小节  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 名为_PHP_或_php_的命名空间，以及以这些名字开头的命名空间（例如_PHP\\\\Classes_）被保留用作语言内核使用，而不应该在用户空间的代码中使用。"},{"type":3,"line":"10.2 定义命名空间"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"虽然任意合法的PHP代码都可以包含在命名空间中，但只有以下类型的代码受命名空间的影响，它们是：类（包括抽象类和traits）、接口、函数和常量。"},{"type":4,"line":"命名空间通过关键字_namespace_ 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：[declare](control-structures.declare.html)关键字。"},{"type":4,"line":"**Example #1 声明单个命名空间**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject;  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在声明命名空间之前唯一合法的代码是用于定义源文件编码方式的 _declare_ 语句。另外，所有非 PHP 代码包括空白符都不能出现在命名空间的声明之前："},{"type":4,"line":"**Example #2 声明单个命名空间**"},{"type":4,"line":"```php"},{"type":4,"line":"<html>  "},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject; // 致命错误 -　命名空间必须是程序脚本的第一条语句  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"另外，与PHP其它的语言特征不同，同一个命名空间可以定义在多个文件中，即允许将同一个命名空间的内容分割存放在不同的文件中。"},{"type":3,"line":"10.3 定义子命名空间"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"与目录和文件的关系很象，PHP 命名空间也允许指定层次化的命名空间的名称。因此，命名空间的名字可以使用分层次的方式定义："},{"type":4,"line":"**Example #1 声明分层次的单个命名空间**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject\\Sub\\Level;  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"上面的例子创建了常量_MyProject\\\\Sub\\\\Level\\\\CONNECT\\_OK_，类 _MyProject\\\\Sub\\\\Level\\\\Connection_和函数 _MyProject\\\\Sub\\\\Level\\\\connect_。"},{"type":3,"line":"10.4 在同一个文件中定义多个命名空间"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"也可以在同一个文件中定义多个命名空间。在同一个文件中定义多个命名空间有两种语法形式。"},{"type":4,"line":"**Example #1 定义多个命名空间，简单组合语法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject;  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"  "},{"type":4,"line":"namespace AnotherProject;  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"不建议使用这种语法在单个文件中定义多个命名空间。建议使用下面的大括号形式的语法。"},{"type":4,"line":"**Example #2 定义多个命名空间，大括号语法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject {  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"namespace AnotherProject {  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在实际的编程实践中，非常不提倡在同一个文件中定义多个命名空间。这种方式的主要用于将多个 PHP 脚本合并在同一个文件中。"},{"type":4,"line":"将全局的非命名空间中的代码与命名空间中的代码组合在一起，只能使用大括号形式的语法。全局代码必须用一个不带名称的 namespace 语句加上大括号括起来，例如："},{"type":4,"line":"**Example #3 定义多个命名空间和不包含在命名空间中的代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject {  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"namespace { // global code  "},{"type":4,"line":"session_start();  "},{"type":4,"line":"$a = MyProject\\connect();  "},{"type":4,"line":"echo MyProject\\Connection::start();  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"除了开始的declare语句外，命名空间的括号外不得有任何PHP代码。"},{"type":4,"line":"**Example #4 定义多个命名空间和不包含在命名空间中的代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"declare(encoding='UTF-8');  "},{"type":4,"line":"namespace MyProject {  "},{"type":4,"line":"  "},{"type":4,"line":"const CONNECT_OK = 1;  "},{"type":4,"line":"class Connection { /* ... */ }  "},{"type":4,"line":"function connect() { /* ... */  }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"namespace { // 全局代码  "},{"type":4,"line":"session_start();  "},{"type":4,"line":"$a = MyProject\\connect();  "},{"type":4,"line":"echo MyProject\\Connection::start();  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"10.5 使用命名空间：基础"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"在讨论如何使用命名空间之前，必须了解 PHP 是如何知道要使用哪一个命名空间中的元素的。可以将 PHP 命名空间与文件系统作一个简单的类比。在文件系统中访问一个文件有三种方式："},{"type":4,"line":"1.  相对文件名形式如_foo.txt_。它会被解析为 _currentdirectory/foo.txt_，其中 currentdirectory 表示当前目录。因此如果当前目录是 _/home/foo_，则该文件名被解析为_/home/foo/foo.txt_。"},{"type":4,"line":"2.  相对路径名形式如_subdirectory/foo.txt_。它会被解析为 _currentdirectory/subdirectory/foo.txt_。"},{"type":4,"line":"3.  绝对路径名形式如_/main/foo.txt_。它会被解析为_/main/foo.txt_。"},{"type":4,"line":"PHP 命名空间中的元素使用同样的原理。例如，类名可以通过三种方式引用："},{"type":4,"line":"1.  非限定名称，或不包含前缀的类名称，例如 _$a=new foo();_ 或 _foo::staticmethod();_。如果当前命名空间是 _currentnamespace_，foo 将被解析为 _currentnamespace\\\\foo_。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，则 foo 会被解析为_foo_。 警告：如果命名空间中的函数或常量未定义，则该非限定的函数名称或常量名称会被解析为全局函数名称或常量名称。详情参见 [使用命名空间：后备全局函数名称/常量名称](language.namespaces.fallback.html)。"},{"type":4,"line":"2.  限定名称,或包含前缀的名称，例如 _$a = new subnamespace\\\\foo();_ 或 _subnamespace\\\\foo::staticmethod();_。如果当前的命名空间是 _currentnamespace_，则 foo 会被解析为 _currentnamespace\\\\subnamespace\\\\foo_。如果使用 foo 的代码是全局的，不包含在任何命名空间中的代码，foo 会被解析为_subnamespace\\\\foo_。"},{"type":4,"line":"3.  完全限定名称，或包含了全局前缀操作符的名称，例如， _$a = new \\\\currentnamespace\\\\foo();_ 或 _\\\\currentnamespace\\\\foo::staticmethod();_。在这种情况下，foo 总是被解析为代码中的文字名(literal name)_currentnamespace\\\\foo_。"},{"type":4,"line":"下面是一个使用这三种方式的实例："},{"type":4,"line":"file1.php"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace Foo\\Bar\\subnamespace;  "},{"type":4,"line":"  "},{"type":4,"line":"const FOO = 1;  "},{"type":4,"line":"function foo() {}  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":4,"line":"    static function staticmethod() {}  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"file2.php"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace Foo\\Bar;  "},{"type":4,"line":"include 'file1.php';  "},{"type":4,"line":"  "},{"type":4,"line":"const FOO = 2;  "},{"type":4,"line":"function foo() {}  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":4,"line":"    static function staticmethod() {}  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* 非限定名称 */  "},{"type":4,"line":"foo(); // 解析为 Foo\\Bar\\foo resolves to function Foo\\Bar\\foo  "},{"type":4,"line":"foo::staticmethod(); // 解析为类 Foo\\Bar\\foo的静态方法staticmethod。resolves to class Foo\\Bar\\foo, method staticmethod  "},{"type":4,"line":"echo FOO; // resolves to constant Foo\\Bar\\FOO  "},{"type":4,"line":"  "},{"type":4,"line":"/* 限定名称 */  "},{"type":4,"line":"subnamespace\\foo(); // 解析为函数 Foo\\Bar\\subnamespace\\foo  "},{"type":5,"line":"subnamespace\\foo::staticmethod(); // 解析为类 Foo\\Bar\\subnamespace\\foo,  "},{"type":4,"line":"                                  // 以及类的方法 staticmethod  "},{"type":5,"line":"echo subnamespace\\FOO; // 解析为常量 Foo\\Bar\\subnamespace\\FOO  "},{"type":4,"line":"                                    "},{"type":4,"line":"/* 完全限定名称 */  "},{"type":4,"line":"\\Foo\\Bar\\foo(); // 解析为函数 Foo\\Bar\\foo  "},{"type":4,"line":"\\Foo\\Bar\\foo::staticmethod(); // 解析为类 Foo\\Bar\\foo, 以及类的方法 staticmethod  "},{"type":4,"line":"echo \\Foo\\Bar\\FOO; // 解析为常量 Foo\\Bar\\FOO  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"注意访问任意全局类、函数或常量，都可以使用完全限定名称，例如 **\\\\strlen()** 或 **\\\\Exception** 或 _\\\\INI\\_ALL_。"},{"type":4,"line":"**Example #1 在命名空间内部访问全局类、函数和常量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace Foo;  "},{"type":4,"line":"  "},{"type":4,"line":"function strlen() {}  "},{"type":4,"line":"const INI_ALL = 3;  "},{"type":4,"line":"class Exception {}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = \\strlen('hi'); // 调用全局函数strlen  "},{"type":4,"line":"$b = \\INI_ALL; // 访问全局常量 INI_ALL  "},{"type":4,"line":"$c = new \\Exception('error'); // 实例化全局类 Exception  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"10.6 命名空间和动态语言特征"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"PHP 命名空间的实现受到其语言自身的动态特征的影响。因此，如果要将下面的代码转换到命名空间中："},{"type":4,"line":"**Example #1 动态访问元素**"},{"type":4,"line":"example1.php:"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class classname  "},{"type":5,"line":"{  "},{"type":5,"line":"    function __construct()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo __METHOD__,\"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"function funcname()  "},{"type":5,"line":"{  "},{"type":4,"line":"    echo __FUNCTION__,\"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"const constname = \"global\";  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 'classname';  "},{"type":4,"line":"$obj = new $a; // prints classname::__construct  "},{"type":4,"line":"$b = 'funcname';  "},{"type":4,"line":"$b(); // prints funcname  "},{"type":4,"line":"echo constant('constname'), \"\\n\"; // prints global  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"必须使用完全限定名称（包括命名空间前缀的类名称）。注意因为在动态的类名称、函数名称或常量名称中，限定名称和完全限定名称没有区别，因此其前导的反斜杠是不必要的。"},{"type":4,"line":"**Example #2 动态访问命名空间的元素**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace namespacename;  "},{"type":4,"line":"class classname  "},{"type":5,"line":"{  "},{"type":5,"line":"    function __construct()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo __METHOD__,\"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"function funcname()  "},{"type":5,"line":"{  "},{"type":4,"line":"    echo __FUNCTION__,\"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"const constname = \"namespaced\";  "},{"type":4,"line":"  "},{"type":4,"line":"include 'example1.php';  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 'classname';  "},{"type":4,"line":"$obj = new $a; // prints classname::__construct  "},{"type":4,"line":"$b = 'funcname';  "},{"type":4,"line":"$b(); // prints funcname  "},{"type":4,"line":"echo constant('constname'), \"\\n\"; // prints global  "},{"type":4,"line":"  "},{"type":4,"line":"/* note that if using double quotes, \"\\\\namespacename\\\\classname\" must be used */  "},{"type":4,"line":"$a = '\\namespacename\\classname';  "},{"type":4,"line":"$obj = new $a; // prints namespacename\\classname::__construct  "},{"type":4,"line":"$a = 'namespacename\\classname';  "},{"type":4,"line":"$obj = new $a; // also prints namespacename\\classname::__construct  "},{"type":4,"line":"$b = 'namespacename\\funcname';  "},{"type":4,"line":"$b(); // prints namespacename\\funcname  "},{"type":4,"line":"$b = '\\namespacename\\funcname';  "},{"type":4,"line":"$b(); // also prints namespacename\\funcname  "},{"type":4,"line":"echo constant('\\namespacename\\constname'), \"\\n\"; // prints namespaced  "},{"type":4,"line":"echo constant('namespacename\\constname'), \"\\n\"; // also prints namespaced  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"请一定别忘了阅读 [对字符串中的命名空间名称转义的注解](language.namespaces.faq.html#language.namespaces.faq.quote)."},{"type":3,"line":"10.7 namespace关键字和`__NAMESPACE__`常量"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"PHP支持两种抽象的访问当前命名空间内部元素的方法，**`__NAMESPACE__`** 魔术常量和_namespace_关键字。"},{"type":4,"line":"常量**`__NAMESPACE__`**的值是包含当前命名空间名称的字符串。在全局的，不包括在任何命名空间中的代码，它包含一个空的字符串。"},{"type":4,"line":"**Example #1 \\_\\_NAMESPACE\\_\\_ 示例, 在命名空间中的代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject;  "},{"type":4,"line":"  "},{"type":4,"line":"echo '\"', __NAMESPACE__, '\"'; // 输出 \"MyProject\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 \\_\\_NAMESPACE\\_\\_ 示例，全局代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"echo '\"', __NAMESPACE__, '\"'; // 输出 \"\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"常量 **`__NAMESPACE__`** 在动态创建名称时很有用，例如："},{"type":4,"line":"**Example #3 使用\\_\\_NAMESPACE\\_\\_动态创建名称**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject;  "},{"type":4,"line":"  "},{"type":4,"line":"function get($classname)  "},{"type":5,"line":"{  "},{"type":5,"line":"    $a = __NAMESPACE__ . '\\\\' . $classname;  "},{"type":4,"line":"    return new $a;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"关键字 _namespace_ 可用来显式访问当前命名空间或子命名空间中的元素。它等价于类中的 _self_ 操作符。"},{"type":4,"line":"**Example #4 namespace操作符，命名空间中的代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace MyProject;  "},{"type":4,"line":"  "},{"type":4,"line":"use blah\\blah as mine; // see \"Using namespaces: importing/aliasing\"  "},{"type":4,"line":"  "},{"type":4,"line":"blah\\mine(); // calls function MyProject\\blah\\mine()  "},{"type":4,"line":"namespace\\blah\\mine(); // calls function MyProject\\blah\\mine()  "},{"type":4,"line":"  "},{"type":4,"line":"namespace\\func(); // calls function MyProject\\func()  "},{"type":4,"line":"namespace\\sub\\func(); // calls function MyProject\\sub\\func()  "},{"type":4,"line":"namespace\\cname::method(); // calls static method \"method\" of class MyProject\\cname  "},{"type":4,"line":"$a = new namespace\\sub\\cname(); // instantiates object of class MyProject\\sub\\cname  "},{"type":4,"line":"$b = namespace\\CONSTANT; // assigns value of constant MyProject\\CONSTANT to $b  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #5 namespace操作符, 全局代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"namespace\\func(); // calls function func()  "},{"type":4,"line":"namespace\\sub\\func(); // calls function sub\\func()  "},{"type":4,"line":"namespace\\cname::method(); // calls static method \"method\" of class cname  "},{"type":4,"line":"$a = new namespace\\sub\\cname(); // instantiates object of class sub\\cname  "},{"type":4,"line":"$b = namespace\\CONSTANT; // assigns value of constant CONSTANT to $b  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"10.8 使用命名空间：别名/导入"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"允许通过别名引用或导入外部的完全限定名称，是命名空间的一个重要特征。这有点类似于在类 unix 文件系统中可以创建对其它的文件或目录的符号连接。"},{"type":4,"line":"所有支持命名空间的PHP版本支持三种别名或导入方式：为类名称使用别名、为接口使用别名或为命名空间名称使用别名。PHP 5.6开始允许导入函数或常量或者为它们设置别名。"},{"type":4,"line":"在PHP中，别名是通过操作符 _use_ 来实现的. 下面是一个使用所有可能的五种导入方式的例子："},{"type":4,"line":"**Example #1 使用use操作符导入/使用别名**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"use My\\Full\\Classname as Another;  "},{"type":4,"line":"  "},{"type":4,"line":"// 下面的例子与 use My\\Full\\NSname as NSname 相同  "},{"type":4,"line":"use My\\Full\\NSname;  "},{"type":4,"line":"  "},{"type":4,"line":"// 导入一个全局类  "},{"type":4,"line":"use ArrayObject;  "},{"type":4,"line":"  "},{"type":4,"line":"// importing a function (PHP 5.6+)  "},{"type":4,"line":"use function My\\Full\\functionName;  "},{"type":4,"line":"  "},{"type":4,"line":"// aliasing a function (PHP 5.6+)  "},{"type":4,"line":"use function My\\Full\\functionName as func;  "},{"type":4,"line":"  "},{"type":4,"line":"// importing a constant (PHP 5.6+)  "},{"type":4,"line":"use const My\\Full\\CONSTANT;  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new namespace\\Another; // 实例化 foo\\Another 对象  "},{"type":4,"line":"$obj = new Another; // 实例化 My\\Full\\Classname　对象  "},{"type":4,"line":"NSname\\subns\\func(); // 调用函数 My\\Full\\NSname\\subns\\func  "},{"type":4,"line":"$a = new ArrayObject(array(1)); // 实例化 ArrayObject 对象  "},{"type":4,"line":"// 如果不使用 \"use \\ArrayObject\" ，则实例化一个 foo\\ArrayObject 对象  "},{"type":4,"line":"func(); // calls function My\\Full\\functionName  "},{"type":4,"line":"echo CONSTANT; // echoes the value of My\\Full\\CONSTANT  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"注意对命名空间中的名称（包含命名空间分隔符的完全限定名称如 _Foo\\\\Bar_以及相对的不包含命名空间分隔符的全局名称如 _FooBar_）来说，前导的反斜杠是不必要的也不推荐的，因为导入的名称必须是完全限定的，不会根据当前的命名空间作相对解析。"},{"type":4,"line":"为了简化操作，PHP还支持在一行中使用多个use语句"},{"type":4,"line":"**Example #2 通过use操作符导入/使用别名，一行中包含多个use语句**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"use My\\Full\\Classname as Another, My\\Full\\NSname;  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new Another; // 实例化 My\\Full\\Classname 对象  "},{"type":4,"line":"NSname\\subns\\func(); // 调用函数 My\\Full\\NSname\\subns\\func  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"导入操作是在编译执行的，但动态的类名称、函数名称或常量名称则不是。"},{"type":4,"line":"**Example #3 导入和动态名称**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"use My\\Full\\Classname as Another, My\\Full\\NSname;  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new Another; // 实例化一个 My\\Full\\Classname 对象  "},{"type":4,"line":"$a = 'Another';  "},{"type":4,"line":"$obj = new $a;      // 实际化一个 Another 对象  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"另外，导入操作只影响非限定名称和限定名称。完全限定名称由于是确定的，故不受导入的影响。"},{"type":4,"line":"**Example #4 导入和完全限定名称**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"use My\\Full\\Classname as Another, My\\Full\\NSname;  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new Another; // instantiates object of class My\\Full\\Classname  "},{"type":4,"line":"$obj = new \\Another; // instantiates object of class Another  "},{"type":4,"line":"$obj = new Another\\thing; // instantiates object of class My\\Full\\Classname\\thing  "},{"type":4,"line":"$obj = new \\Another\\thing; // instantiates object of class Another\\thing  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Scoping rules for importing"},{"type":4,"line":"The _use_ keyword must be declared in the outermost scope of a file (the global scope) or inside namespace declarations. This is because the importing is done at compile time and not runtime, so it cannot be block scoped. The following example will show an illegal use of the _use_ keyword:"},{"type":4,"line":"**Example #5 Illegal importing rule**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace Languages;  "},{"type":4,"line":"  "},{"type":4,"line":"class Greenlandic  "},{"type":5,"line":"{  "},{"type":4,"line":"    use Languages\\Danish;  "},{"type":5,"line":"  "},{"type":4,"line":"    ...  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> Importing rules are per file basis, meaning included files will _NOT_ inherit the parent file's importing rules."},{"type":3,"line":"10.9 全局空间"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"如果没有定义任何命名空间，所有的类与函数的定义都是在全局空间，与 PHP 引入命名空间概念前一样。在名称前加上前缀 _\\\\_ 表示该名称是全局空间中的名称，即使该名称位于其它的命名空间中时也是如此。"},{"type":4,"line":"**Example #1 使用全局空间说明**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace A\\B\\C;  "},{"type":4,"line":"  "},{"type":4,"line":"/* 这个函数是 A\\B\\C\\fopen */  "},{"type":5,"line":"function fopen() {   "},{"type":5,"line":"     /* ... */  "},{"type":5,"line":"     $f = \\fopen(...); // 调用全局的fopen函数  "},{"type":4,"line":"     return $f;  "},{"type":4,"line":"}   "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"10.10 使用命名空间：后备全局函数/常量"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"在一个命名空间中，当 PHP 遇到一个非限定的类、函数或常量名称时，它使用不同的优先策略来解析该名称。类名称总是解析到当前命名空间中的名称。因此在访问系统内部或不包含在命名空间中的类名称时，必须使用完全限定名称，例如："},{"type":4,"line":"**Example #1 在命名空间中访问全局类**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace A\\B\\C;  "},{"type":4,"line":"class Exception extends \\Exception {}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new Exception('hi'); // $a 是类 A\\B\\C\\Exception 的一个对象  "},{"type":4,"line":"$b = new \\Exception('hi'); // $b 是类 Exception 的一个对象  "},{"type":4,"line":"  "},{"type":4,"line":"$c = new ArrayObject; // 致命错误, 找不到 A\\B\\C\\ArrayObject 类  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"对于函数和常量来说，如果当前命名空间中不存在该函数或常量，PHP 会退而使用全局空间中的函数或常量。 For functions and constants, PHP will fall back to global functions or constants if a namespaced function or constant does not exist."},{"type":4,"line":"**Example #2 命名空间中后备的全局函数/常量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace A\\B\\C;  "},{"type":4,"line":"  "},{"type":4,"line":"const E_ERROR = 45;  "},{"type":4,"line":"function strlen($str)  "},{"type":5,"line":"{  "},{"type":4,"line":"    return \\strlen($str) - 1;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo E_ERROR, \"\\n\"; // 输出 \"45\"  "},{"type":4,"line":"echo INI_ALL, \"\\n\"; // 输出 \"7\" - 使用全局常量 INI_ALL  "},{"type":4,"line":"  "},{"type":4,"line":"echo strlen('hi'), \"\\n\"; // 输出 \"1\"  "},{"type":5,"line":"if (is_array('hi')) { // 输出 \"is not array\"  "},{"type":4,"line":"    echo \"is array\\n\";  "},{"type":5,"line":"} else {  "},{"type":4,"line":"    echo \"is not array\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"10.11 名称解析规则"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"在说明名称解析规则之前，我们先看一些重要的定义："},{"type":4,"line":"**命名空间名称定义**"},{"type":4,"line":"非限定名称Unqualified name"},{"type":4,"line":"名称中不包含命名空间分隔符的标识符，例如 _Foo_"},{"type":4,"line":"限定名称Qualified name"},{"type":4,"line":"名称中含有命名空间分隔符的标识符，例如 _Foo\\\\Bar_"},{"type":4,"line":"完全限定名称Fully qualified name"},{"type":4,"line":"名称中包含命名空间分隔符，并以命名空间分隔符开始的标识符，例如 _\\\\Foo\\\\Bar_。 _namespace\\\\Foo_ 也是一个完全限定名称。"},{"type":4,"line":"名称解析遵循下列规则："},{"type":4,"line":"1.  对完全限定名称的函数，类和常量的调用在编译时解析。例如 _new \\\\A\\\\B_ 解析为类 _A\\\\B_。"},{"type":4,"line":"2.  所有的非限定名称和限定名称（非完全限定名称）根据当前的导入规则在编译时进行转换。例如，如果命名空间 _A\\\\B\\\\C_ 被导入为 _C_，那么对 _C\\\\D\\\\e()_ 的调用就会被转换为 _A\\\\B\\\\C\\\\D\\\\e()_。"},{"type":4,"line":"3.  在命名空间内部，所有的没有根据导入规则转换的限定名称均会在其前面加上当前的命名空间名称。例如，在命名空间 _A\\\\B_ 内部调用 _C\\\\D\\\\e()_，则 _C\\\\D\\\\e()_ 会被转换为 _A\\\\B\\\\C\\\\D\\\\e()_ 。"},{"type":4,"line":"4.  非限定类名根据当前的导入规则在编译时转换（用全名代替短的导入名称）。例如，如果命名空间 _A\\\\B\\\\C_ 导入为C，则 _new C()_ 被转换为 _new A\\\\B\\\\C()_ 。"},{"type":5,"line":"5.  在命名空间内部（例如A\\\\B），对非限定名称的函数调用是在运行时解析的。例如对函数 _foo()_ 的调用是这样解析的："},{"type":5,"line":"    1.  在当前命名空间中查找名为 _A\\\\B\\\\foo()_ 的函数"},{"type":4,"line":"    2.  尝试查找并调用 _全局(global)_ 空间中的函数 _foo()_。"},{"type":5,"line":"6.  在命名空间（例如_A\\\\B_）内部对非限定名称或限定名称类（非完全限定名称）的调用是在运行时解析的。下面是调用 _new C()_ 及 _new D\\\\E()_ 的解析过程： _new C()_的解析:"},{"type":5,"line":"    "},{"type":5,"line":"    1.  在当前命名空间中查找_A\\\\B\\\\C_类。"},{"type":5,"line":"    2.  尝试自动装载类_A\\\\B\\\\C_。"},{"type":5,"line":"    "},{"type":5,"line":"    _new D\\\\E()_的解析:"},{"type":5,"line":"    "},{"type":5,"line":"    1.  在类名称前面加上当前命名空间名称变成：_A\\\\B\\\\D\\\\E_，然后查找该类。"},{"type":5,"line":"    2.  尝试自动装载类 _A\\\\B\\\\D\\\\E_。"},{"type":5,"line":"    "},{"type":4,"line":"    为了引用全局命名空间中的全局类，必须使用完全限定名称 _new \\\\C()_。"},{"type":4,"line":"**Example #1 名称解析示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace A;  "},{"type":4,"line":"use B\\D, C\\E as F;  "},{"type":4,"line":"  "},{"type":4,"line":"// 函数调用  "},{"type":4,"line":"  "},{"type":5,"line":"foo();      // 首先尝试调用定义在命名空间\"A\"中的函数foo()  "},{"type":4,"line":"            // 再尝试调用全局函数 \"foo\"  "},{"type":4,"line":"  "},{"type":4,"line":"\\foo();     // 调用全局空间函数 \"foo\"   "},{"type":4,"line":"  "},{"type":4,"line":"my\\foo();   // 调用定义在命名空间\"A\\my\"中函数 \"foo\"   "},{"type":4,"line":"  "},{"type":5,"line":"F();        // 首先尝试调用定义在命名空间\"A\"中的函数 \"F\"   "},{"type":4,"line":"            // 再尝试调用全局函数 \"F\"  "},{"type":4,"line":"  "},{"type":4,"line":"// 类引用  "},{"type":4,"line":"  "},{"type":5,"line":"new B();    // 创建命名空间 \"A\" 中定义的类 \"B\" 的一个对象  "},{"type":4,"line":"            // 如果未找到，则尝试自动装载类 \"A\\B\"  "},{"type":4,"line":"  "},{"type":5,"line":"new D();    // 使用导入规则，创建命名空间 \"B\" 中定义的类 \"D\" 的一个对象  "},{"type":4,"line":"            // 如果未找到，则尝试自动装载类 \"B\\D\"  "},{"type":4,"line":"  "},{"type":5,"line":"new F();    // 使用导入规则，创建命名空间 \"C\" 中定义的类 \"E\" 的一个对象  "},{"type":4,"line":"            // 如果未找到，则尝试自动装载类 \"C\\E\"  "},{"type":4,"line":"  "},{"type":5,"line":"new \\B();   // 创建定义在全局空间中的类 \"B\" 的一个对象  "},{"type":4,"line":"            // 如果未发现，则尝试自动装载类 \"B\"  "},{"type":4,"line":"  "},{"type":5,"line":"new \\D();   // 创建定义在全局空间中的类 \"D\" 的一个对象  "},{"type":4,"line":"            // 如果未发现，则尝试自动装载类 \"D\"  "},{"type":4,"line":"  "},{"type":5,"line":"new \\F();   // 创建定义在全局空间中的类 \"F\" 的一个对象  "},{"type":4,"line":"            // 如果未发现，则尝试自动装载类 \"F\"  "},{"type":4,"line":"  "},{"type":4,"line":"// 调用另一个命名空间中的静态方法或命名空间函数  "},{"type":4,"line":"  "},{"type":4,"line":"B\\foo();    // 调用命名空间 \"A\\B\" 中函数 \"foo\"  "},{"type":4,"line":"  "},{"type":5,"line":"B::foo();   // 调用命名空间 \"A\" 中定义的类 \"B\" 的 \"foo\" 方法  "},{"type":4,"line":"            // 如果未找到类 \"A\\B\" ，则尝试自动装载类 \"A\\B\"  "},{"type":4,"line":"  "},{"type":5,"line":"D::foo();   // 使用导入规则，调用命名空间 \"B\" 中定义的类 \"D\" 的 \"foo\" 方法  "},{"type":4,"line":"            // 如果类 \"B\\D\" 未找到，则尝试自动装载类 \"B\\D\"  "},{"type":4,"line":"  "},{"type":4,"line":"\\B\\foo();   // 调用命名空间 \"B\" 中的函数 \"foo\"   "},{"type":4,"line":"  "},{"type":5,"line":"\\B::foo();  // 调用全局空间中的类 \"B\" 的 \"foo\" 方法  "},{"type":4,"line":"            // 如果类 \"B\" 未找到，则尝试自动装载类 \"B\"  "},{"type":4,"line":"  "},{"type":4,"line":"// 当前命名空间中的静态方法或函数  "},{"type":4,"line":"  "},{"type":5,"line":"A\\B::foo();   // 调用命名空间 \"A\\A\" 中定义的类 \"B\" 的 \"foo\" 方法  "},{"type":4,"line":"              // 如果类 \"A\\A\\B\" 未找到，则尝试自动装载类 \"A\\A\\B\"  "},{"type":4,"line":"  "},{"type":5,"line":"\\A\\B::foo();  // 调用命名空间 \"A\\B\" 中定义的类 \"B\" 的 \"foo\" 方法  "},{"type":4,"line":"              // 如果类 \"A\\B\" 未找到，则尝试自动装载类 \"A\\B\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"10.12 FAQ: things you need to know about namespaces"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"This FAQ is split into two sections: common questions, and some specifics of implementation that are helpful to understand fully."},{"type":4,"line":"First, the common questions."},{"type":4,"line":"1.  [If I don't use namespaces, should I care about any of this?](language.namespaces.faq.html#language.namespaces.faq.shouldicare)"},{"type":4,"line":"2.  [How do I use internal or global classes in a namespace?](language.namespaces.faq.html#language.namespaces.faq.globalclass)"},{"type":4,"line":"3.  [How do I use namespaces classes functions, or constants in their own namespace?](language.namespaces.faq.html#language.namespaces.faq.innamespace)"},{"type":4,"line":"4.  [How does a name like _\\\\my\\\\name_ or _\\\\name_ resolve?](language.namespaces.faq.html#language.namespaces.faq.full)"},{"type":4,"line":"5.  [How does a name like _my\\\\name_ resolve?](language.namespaces.faq.html#language.namespaces.faq.qualified)"},{"type":4,"line":"6.  [How does an unqualified class name like _name_ resolve?](language.namespaces.faq.html#language.namespaces.faq.shortname1)"},{"type":4,"line":"7.  [How does an unqualified function name or unqualified constant name like _name_ resolve?](language.namespaces.faq.html#language.namespaces.faq.shortname2)"},{"type":4,"line":"There are a few implementation details of the namespace implementations that are helpful to understand."},{"type":4,"line":"1.  [Import names cannot conflict with classes defined in the same file.](language.namespaces.faq.html#language.namespaces.faq.conflict)"},{"type":4,"line":"2.  [Nested namespaces are not allowed.](language.namespaces.faq.html#language.namespaces.faq.nested)"},{"type":4,"line":"3.  [Neither functions nor constants can be imported via the _use_ statement.](language.namespaces.faq.html#language.namespaces.faq.nofuncconstantuse)"},{"type":4,"line":"4.  [Dynamic namespace names (quoted identifiers) should escape backslash.](language.namespaces.faq.html#language.namespaces.faq.quote)"},{"type":4,"line":"5.  [Undefined Constants referenced using any backslash die with fatal error](language.namespaces.faq.html#language.namespaces.faq.constants)"},{"type":4,"line":"6.  [Cannot override special constants NULL, TRUE, FALSE, ZEND\\_THREAD\\_SAFE or ZEND\\_DEBUG\\_BUILD](language.namespaces.faq.html#language.namespaces.faq.builtinconst)"},{"type":4,"line":"### If I don't use namespaces, should I care about any of this?"},{"type":4,"line":"No. Namespaces do not affect any existing code in any way, or any as-yet-to-be-written code that does not contain namespaces. You can write this code if you wish:"},{"type":4,"line":"**Example #1 Accessing global classes outside a namespace**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = new \\stdClass;`"},{"type":4,"line":"This is functionally equivalent to:"},{"type":4,"line":"**Example #2 Accessing global classes outside a namespace**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = new stdClass;`"},{"type":4,"line":"### How do I use internal or global classes in a namespace?"},{"type":4,"line":"**Example #3 Accessing internal classes in namespaces**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"$a = new \\stdClass;  "},{"type":4,"line":"  "},{"type":4,"line":"function test(\\ArrayObject $typehintexample = null) {}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = \\DirectoryIterator::CURRENT_AS_FILEINFO;  "},{"type":4,"line":"  "},{"type":4,"line":"// extending an internal or global class  "},{"type":4,"line":"class MyException extends \\Exception {}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### How do I use namespaces classes, functions, or constants in their own namespace?"},{"type":4,"line":"**Example #4 Accessing internal classes, functions or constants in namespaces**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"  "},{"type":4,"line":"class MyClass {}  "},{"type":4,"line":"  "},{"type":4,"line":"// using a class from the current namespace as a type hint  "},{"type":4,"line":"function test(MyClass $typehintexample = null) {}  "},{"type":4,"line":"// another way to use a class from the current namespace as a type hint  "},{"type":4,"line":"function test(\\foo\\MyClass $typehintexample = null) {}  "},{"type":4,"line":"  "},{"type":4,"line":"// extending a class from the current namespace  "},{"type":4,"line":"class Extended extends MyClass {}  "},{"type":4,"line":"  "},{"type":4,"line":"// accessing a global function  "},{"type":4,"line":"$a = \\globalfunc();  "},{"type":4,"line":"  "},{"type":4,"line":"// accessing a global constant  "},{"type":4,"line":"$b = \\INI_ALL;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### How does a name like _\\\\my\\\\name_ or _\\\\name_ resolve?"},{"type":4,"line":"Names that begin with a _\\\\_ always resolve to what they look like, so _\\\\my\\\\name_ is in fact _my\\\\name_, and _\\\\Exception_ is _Exception_."},{"type":4,"line":"**Example #5 Fully Qualified names**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"$a = new \\my\\name(); // instantiates \"my\\name\" class  "},{"type":4,"line":"echo \\strlen('hi'); // calls function \"strlen\"  "},{"type":4,"line":"$a = \\INI_ALL; // $a is set to the value of constant \"INI_ALL\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### How does a name like _my\\\\name_ resolve?"},{"type":4,"line":"Names that contain a backslash but do not begin with a backslash like _my\\\\name_ can be resolved in 2 different ways."},{"type":4,"line":"If there is an import statement that aliases another name to _my_, then the import alias is applied to the _my_ in _my\\\\name_."},{"type":4,"line":"Otherwise, the current namespace name is prepended to _my\\\\name_."},{"type":4,"line":"**Example #6 Qualified names**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"use blah\\blah as foo;  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new my\\name(); // instantiates \"foo\\my\\name\" class  "},{"type":4,"line":"foo\\bar::name(); // calls static method \"name\" in class \"blah\\blah\\bar\"  "},{"type":4,"line":"my\\bar(); // calls function \"foo\\my\\bar\"  "},{"type":4,"line":"$a = my\\BAR; // sets $a to the value of constant \"foo\\my\\BAR\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### How does an unqualified class name like _name_ resolve?"},{"type":4,"line":"Class names that do not contain a backslash like _name_ can be resolved in 2 different ways."},{"type":4,"line":"If there is an import statement that aliases another name to _name_, then the import alias is applied."},{"type":4,"line":"Otherwise, the current namespace name is prepended to _name_."},{"type":4,"line":"**Example #7 Unqualified class names**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"use blah\\blah as foo;  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new name(); // instantiates \"foo\\name\" class  "},{"type":4,"line":"foo::name(); // calls static method \"name\" in class \"blah\\blah\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### How does an unqualified function name or unqualified constant name like _name_ resolve?"},{"type":4,"line":"Function or constant names that do not contain a backslash like _name_ can be resolved in 2 different ways."},{"type":4,"line":"First, the current namespace name is prepended to _name_."},{"type":4,"line":"Finally, if the constant or function _name_ does not exist in the current namespace, a global constant or function _name_ is used if it exists."},{"type":4,"line":"**Example #8 Unqualified function or constant names**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace foo;  "},{"type":4,"line":"use blah\\blah as foo;  "},{"type":4,"line":"  "},{"type":4,"line":"const FOO = 1;  "},{"type":4,"line":"  "},{"type":4,"line":"function my() {}  "},{"type":4,"line":"function foo() {}  "},{"type":4,"line":"function sort(&$a)  "},{"type":5,"line":"{  "},{"type":5,"line":"    sort($a);  "},{"type":5,"line":"    $a = array_flip($a);  "},{"type":4,"line":"    return $a;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"my(); // calls \"foo\\my\"  "},{"type":4,"line":"$a = strlen('hi'); // calls global function \"strlen\" because \"foo\\strlen\" does not exist  "},{"type":4,"line":"$arr = array(1,3,2);  "},{"type":4,"line":"$b = sort($arr); // calls function \"foo\\sort\"  "},{"type":4,"line":"$c = foo(); // calls function \"foo\\foo\" - import is not applied  "},{"type":4,"line":"  "},{"type":4,"line":"$a = FOO; // sets $a to value of constant \"foo\\FOO\" - import is not applied  "},{"type":4,"line":"$b = INI_ALL; // sets $b to value of global constant \"INI_ALL\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Import names cannot conflict with classes defined in the same file."},{"type":4,"line":"The following script combinations are legal:"},{"type":4,"line":"file1.php"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace my\\stuff;  "},{"type":4,"line":"class MyClass {}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"another.php"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace another;  "},{"type":4,"line":"class thing {}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"file2.php"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace my\\stuff;  "},{"type":4,"line":"include 'file1.php';  "},{"type":4,"line":"include 'another.php';  "},{"type":4,"line":"  "},{"type":4,"line":"use another\\thing as MyClass;  "},{"type":4,"line":"$a = new MyClass; // instantiates class \"thing\" from namespace another  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"There is no name conflict, even though the class _MyClass_ exists within the _my\\\\stuff_ namespace, because the MyClass definition is in a separate file. However, the next example causes a fatal error on name conflict because MyClass is defined in the same file as the use statement."},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace my\\stuff;  "},{"type":4,"line":"use another\\thing as MyClass;  "},{"type":4,"line":"class MyClass {} // fatal error: MyClass conflicts with import statement  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Nested namespaces are not allowed."},{"type":4,"line":"PHP does not allow nesting namespaces"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"namespace my\\stuff {  "},{"type":5,"line":"    namespace nested {  "},{"type":5,"line":"        class foo {}  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"However, it is easy to simulate nested namespaces like so:"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"namespace my\\stuff\\nested {  "},{"type":4,"line":"    class foo {}  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Neither functions nor constants can be imported via the _use_ statement."},{"type":4,"line":"The only elements that are affected by _use_ statements are namespaces and class names. In order to shorten a long constant or function, import its containing namespace"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace mine;  "},{"type":4,"line":"use ultra\\long\\ns\\name;  "},{"type":4,"line":"  "},{"type":4,"line":"$a = name\\CONSTANT;  "},{"type":4,"line":"name\\func();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Dynamic namespace names (quoted identifiers) should escape backslash"},{"type":4,"line":"It is very important to realize that because the backslash is used as an escape character within strings, it should always be doubled when used inside a string. Otherwise there is a risk of unintended consequences:"},{"type":4,"line":"**Example #9 Dangers of using namespaced names inside a double-quoted string**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = new \"dangerous\\name\"; // \\n is a newline inside double quoted strings!  "},{"type":4,"line":"$obj = new $a;  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new 'not\\at\\all\\dangerous'; // no problems here.  "},{"type":4,"line":"$obj = new $a;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"Inside a single-quoted string, the backslash escape sequence is much safer to use, but it is still recommended practice to escape backslashes in all strings as a best practice."},{"type":4,"line":"### Undefined Constants referenced using any backslash die with fatal error"},{"type":4,"line":"Any undefined constant that is unqualified like _FOO_ will produce a notice explaining that PHP assumed _FOO_ was the value of the constant. Any constant, qualified or fully qualified, that contains a backslash will produce a fatal error if not found."},{"type":4,"line":"**Example #10 Undefined constants**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace bar;  "},{"type":4,"line":"$a = FOO; // produces notice - undefined constants \"FOO\" assumed \"FOO\";  "},{"type":4,"line":"$a = \\FOO; // fatal error, undefined namespace constant FOO  "},{"type":4,"line":"$a = Bar\\FOO; // fatal error, undefined namespace constant bar\\Bar\\FOO  "},{"type":4,"line":"$a = \\Bar\\FOO; // fatal error, undefined namespace constant Bar\\FOO  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Cannot override special constants NULL, TRUE, FALSE, ZEND\\_THREAD\\_SAFE or ZEND\\_DEBUG\\_BUILD"},{"type":4,"line":"Any attempt to define a namespaced constant that is a special, built-in constant results in a fatal error"},{"type":4,"line":"**Example #11 Undefined constants**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace bar;  "},{"type":4,"line":"const NULL = 0; // fatal error;  "},{"type":4,"line":"const true = 'stupid'; // also fatal error;  "},{"type":4,"line":"// etc.  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":1,"line":"11. Errors"},{"type":3,"line":"11.1 Basics"},{"type":4,"line":"PHP reports errors in response to a number of internal error conditions. These may be used to signal a number of different conditions, and can be displayed and/or logged as required."},{"type":4,"line":"Every error that PHP generates includes a type. A [list of these types](errorfunc.constants.html) is available, along with a short description of their behaviour and how they can be caused."},{"type":4,"line":"### Handling errors with PHP"},{"type":4,"line":"If no error handler is set, then PHP will handle any errors that occur according to its configuration. Which errors are reported and which are ignored is controlled by the [`error_reporting`](errorfunc.configuration.html#ini.error-reporting) php.ini directive, or at runtime by calling [error\\_reporting()](function.error-reporting.html). It is strongly recommended that the configuration directive be set, however, as some errors can occur before execution of your script begins."},{"type":4,"line":"In a development environment, you should always set [`error_reporting`](errorfunc.configuration.html#ini.error-reporting) to **`E_ALL`**, as you need to be aware of and fix the issues raised by PHP. In production, you may wish to set this to a less verbose level such as `E_ALL & ~E_NOTICE & ~E_STRICT & ~E_DEPRECATED`, but in many cases **`E_ALL`** is also appropriate, as it may provide early warning of potential issues."},{"type":4,"line":"What PHP does with these errors depends on two further php.ini directives. [`display_errors`](errorfunc.configuration.html#ini.display-errors) controls whether the error is shown as part of the script's output. This should always be disabled in a production environment, as it can include confidential information such as database passwords, but is often useful to enable in development, as it ensures immediate reporting of issues."},{"type":4,"line":"In addition to displaying errors, PHP can log errors when the [`log_errors`](errorfunc.configuration.html#ini.log-errors) directive is enabled. This will log any errors to the file or syslog defined by [`error_log`](errorfunc.configuration.html#ini.error-log). This can be extremely useful in a production environment, as you can log errors that occur and then generate reports based on those errors."},{"type":4,"line":"### User error handlers"},{"type":4,"line":"If PHP's default error handling is inadequate, you can also handle many types of error with your own custom error handler by installing it with [set\\_error\\_handler()](function.set-error-handler.html). While some error types cannot be handled this way, those that can be handled can then be handled in the way that your script sees fit: for example, this can be used to show a custom error page to the user and then report more directly than via a log, such as by sending an e-mail."},{"type":3,"line":"11.2 PHP 7 错误处理"},{"type":4,"line":"PHP 7 改变了大多数错误的报告方式。不同于传统（PHP 5）的错误报告机制，现在大多数错误被作为 **Error** 异常抛出。"},{"type":4,"line":"这种 **Error** 异常可以像 [Exception](class.exception.html) 异常一样被第一个匹配的 _try_ / _catch_ 块所捕获。如果没有匹配的 [_catch_](language.exceptions.html#language.exceptions.catch) 块，则调用异常处理函数（事先通过 [set\\_exception\\_handler()](function.set-exception-handler.html) 注册）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。"},{"type":4,"line":"**Error** 类并非继承自 [Exception](class.exception.html) 类，所以不能用 `catch (Exception $e) { ... }` 来捕获 **Error**。你可以用 `catch (Error $e) { ... }`，或者通过注册异常处理函数（ [set\\_exception\\_handler()](function.set-exception-handler.html)）来捕获 **Error**。"},{"type":4,"line":"### **Error** 层次结构"},{"type":5,"line":"*   **Throwable**"},{"type":5,"line":"    *   **Error**"},{"type":5,"line":"        *   **ArithmeticError**"},{"type":5,"line":"            *   **DivisionByZeroError**"},{"type":5,"line":"        *   **AssertionError**"},{"type":5,"line":"        *   **CompileError**"},{"type":5,"line":"            *   **ParseError**"},{"type":5,"line":"        *   **TypeError**"},{"type":5,"line":"            *   **ArgumentCountError**"},{"type":5,"line":"    *   [Exception](class.exception.html)"},{"type":4,"line":"        *   ..."},{"type":1,"line":"12. 异常处理"},{"type":3,"line":"12.1 扩展（extend） PHP 内置的异常处理类"},{"type":4,"line":"用户可以用自定义的异常处理类来扩展 PHP 内置的异常处理类。以下的代码说明了在内置的异常处理类中，哪些属性和方法在子类中是可访问和可继承的。译者注：以下这段代码只为说明内置异常处理类的结构，它并不是一段有实际意义的可用代码。"},{"type":4,"line":"**Example #1 内置的异常处理类**"},{"type":4,"line":"```php"},{"type":4,"line":"<php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Exception  "},{"type":5,"line":"{  "},{"type":5,"line":"    protected $message = 'Unknown exception';   // 异常信息  "},{"type":5,"line":"    private   $string;                          // __toString cache  "},{"type":5,"line":"    protected $code = 0;                        // 用户自定义异常代码  "},{"type":5,"line":"    protected $file;                            // 发生异常的文件名  "},{"type":5,"line":"    protected $line;                            // 发生异常的代码行号  "},{"type":5,"line":"    private   $trace;                           // backtrace  "},{"type":4,"line":"    private   $previous;                        // previous exception if nested exception  "},{"type":5,"line":"  "},{"type":4,"line":"    public function __construct($message = null, $code = 0, Exception $previous = null);  "},{"type":5,"line":"  "},{"type":4,"line":"    final private function __clone();           // Inhibits cloning of exceptions.  "},{"type":5,"line":"  "},{"type":5,"line":"    final public  function getMessage();        // 返回异常信息  "},{"type":5,"line":"    final public  function getCode();           // 返回异常代码  "},{"type":5,"line":"    final public  function getFile();           // 返回发生异常的文件名  "},{"type":5,"line":"    final public  function getLine();           // 返回发生异常的代码行号  "},{"type":5,"line":"    final public  function getTrace();          // backtrace() 数组  "},{"type":5,"line":"    final public  function getPrevious();       // 之前的 exception  "},{"type":4,"line":"    final public  function getTraceAsString();  // 已格成化成字符串的 getTrace() 信息  "},{"type":5,"line":"  "},{"type":5,"line":"    // Overrideable  "},{"type":4,"line":"    public function __toString();               // 可输出的字符串  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```php"},{"type":4,"line":"<"},{"type":4,"line":"如果使用自定义的类来扩展内置异常处理类，并且要重新定义[构造函数](language.oop5.decon.html)的话，建议同时调用 [parent::\\_\\_construct()](language.oop5.paamayim-nekudotayim.html) 来检查所有的变量是否已被赋值。当对象要输出字符串的时候，可以重载 [\\_\\_toString()](language.oop5.magic.html) 并自定义输出的样式。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> Exception 对象不能被复制。尝试对 Exception [对象复制](language.oop5.cloning.html) 会导致一个 **`E_ERROR`** 级别的错误。"},{"type":4,"line":"**Example #2 扩展 PHP 内置的异常处理类 (PHP 5.3.0+)**"},{"type":4,"line":"```php"},{"type":4,"line":"<php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/**  "},{"type":4,"line":" * 自定义一个异常处理类  "},{"type":4,"line":" */  "},{"type":4,"line":"class MyException extends Exception  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 重定义构造器使 message 变为必须被指定的属性  "},{"type":5,"line":"    public function __construct($message, $code = 0, Exception $previous = null) {  "},{"type":4,"line":"        // 自定义的代码  "},{"type":5,"line":"  "},{"type":5,"line":"        // 确保所有变量都被正确赋值  "},{"type":5,"line":"        parent::__construct($message, $code, $previous);  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    // 自定义字符串输出的样式  "},{"type":5,"line":"    public function __toString() {  "},{"type":5,"line":"        return __CLASS__ . \": [{$this->code}]: {$this->message}\\n\";  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function customFunction() {  "},{"type":5,"line":"        echo \"A custom function for this type of exception\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"/**  "},{"type":4,"line":" * 创建一个用于测试异常处理机制的类  "},{"type":4,"line":" */  "},{"type":4,"line":"class TestException  "},{"type":5,"line":"{  "},{"type":4,"line":"    public $var;  "},{"type":5,"line":"  "},{"type":5,"line":"    const THROW_NONE    = 0;  "},{"type":5,"line":"    const THROW_CUSTOM  = 1;  "},{"type":4,"line":"    const THROW_DEFAULT = 2;  "},{"type":5,"line":"  "},{"type":4,"line":"    function __construct($avalue = self::THROW_NONE) {  "},{"type":5,"line":"  "},{"type":5,"line":"        switch ($avalue) {  "},{"type":5,"line":"            case self::THROW_CUSTOM:  "},{"type":5,"line":"                // 抛出自定义异常  "},{"type":5,"line":"                throw new MyException('1 is an invalid parameter', 5);  "},{"type":4,"line":"                break;  "},{"type":5,"line":"  "},{"type":5,"line":"            case self::THROW_DEFAULT:  "},{"type":5,"line":"                // 抛出默认的异常  "},{"type":5,"line":"                throw new Exception('2 is not allowed as a parameter', 6);  "},{"type":4,"line":"                break;  "},{"type":5,"line":"  "},{"type":5,"line":"            default:   "},{"type":5,"line":"                // 没有异常的情况下，创建一个对象  "},{"type":5,"line":"                $this->var = $avalue;  "},{"type":5,"line":"                break;  "},{"type":5,"line":"        }  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// 例子 1  "},{"type":5,"line":"try {  "},{"type":4,"line":"    $o = new TestException(TestException::THROW_CUSTOM);  "},{"type":5,"line":"} catch (MyException $e) {      // 捕获异常  "},{"type":5,"line":"    echo \"Caught my exception\\n\", $e;  "},{"type":4,"line":"    $e->customFunction();  "},{"type":5,"line":"} catch (Exception $e) {        // 被忽略  "},{"type":4,"line":"    echo \"Caught Default Exception\\n\", $e;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// Continue execution  "},{"type":4,"line":"var_dump($o); // Null  "},{"type":4,"line":"echo \"\\n\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// 例子 2  "},{"type":5,"line":"try {  "},{"type":4,"line":"    $o = new TestException(TestException::THROW_DEFAULT);  "},{"type":4,"line":"} catch (MyException $e) {      //  不能匹配异常的种类，被忽略  "},{"type":5,"line":"  "},{"type":5,"line":"    echo \"Caught my exception\\n\", $e;  "},{"type":4,"line":"    $e->customFunction();  "},{"type":5,"line":"} catch (Exception $e) {        // 捕获异常  "},{"type":4,"line":"    echo \"Caught Default Exception\\n\", $e;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 执行后续代码  "},{"type":4,"line":"var_dump($o); // Null  "},{"type":4,"line":"echo \"\\n\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// 例子 3  "},{"type":5,"line":"try {  "},{"type":4,"line":"    $o = new TestException(TestException::THROW_CUSTOM);  "},{"type":5,"line":"} catch (Exception $e) {        // 捕获异常  "},{"type":4,"line":"    echo \"Default Exception caught\\n\", $e;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 执行后续代码  "},{"type":4,"line":"var_dump($o); // Null  "},{"type":4,"line":"echo \"\\n\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// 例子 4  "},{"type":5,"line":"try {  "},{"type":4,"line":"    $o = new TestException();  "},{"type":5,"line":"} catch (Exception $e) {        // 没有异常，被忽略  "},{"type":4,"line":"    echo \"Default Exception caught\\n\", $e;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 执行后续代码  "},{"type":4,"line":"var_dump($o); // TestException  "},{"type":4,"line":"echo \"\\n\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```php"},{"type":4,"line":"<"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> Versions of PHP 5, prior to PHP 5.3.0 do not support nesting of exceptions. The following code fragment can be used as a replacement MyException class if you wish to run this example."},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> /**  "},{"type":4,"line":">  * Define a custom exception class  "},{"type":4,"line":">  */  "},{"type":4,"line":"> class MyException extends Exception  "},{"type":4,"line":"> {  "},{"type":4,"line":">     // Redefine the exception so message isn't optional  "},{"type":4,"line":">     public function __construct($message, $code = 0) {  "},{"type":4,"line":">         // some code  "},{"type":4,"line":">       "},{"type":4,"line":">         // make sure everything is assigned properly  "},{"type":4,"line":">         parent::__construct($message, $code);  "},{"type":4,"line":">     }  "},{"type":4,"line":">   "},{"type":4,"line":">     // custom string representation of object  "},{"type":4,"line":">     public function __toString() {  "},{"type":4,"line":">         return __CLASS__ . \": [{$this->code}]: {$this->message}\\n\";  "},{"type":4,"line":">     }  "},{"type":4,"line":">   "},{"type":4,"line":">     public function customFunction() {  "},{"type":4,"line":">         echo \"A custom function for this type of exception\\n\";  "},{"type":4,"line":">     }  "},{"type":4,"line":"> }  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```php"},{"type":4,"line":"<"},{"type":1,"line":"13. 生成器"},{"type":3,"line":"13.1 生成器总览"},{"type":4,"line":"(PHP 5 >= 5.5.0, PHP 7)"},{"type":4,"line":"生成器提供了一种更容易的方法来实现简单的[对象迭代](language.oop5.iterations.html)，相比较定义类实现 **Iterator** 接口的方式，性能开销和复杂性大大降低。"},{"type":4,"line":"生成器允许你在 [foreach](control-structures.foreach.html) 代码块中写代码来迭代一组数据而不需要在内存中创建一个数组, 那会使你的内存达到上限，或者会占据可观的处理时间。相反，你可以写一个生成器函数，就像一个普通的自定义[函数](functions.user-defined.html)一样, 和普通函数只[返回](functions.returning-values.html)一次不同的是, 生成器可以根据需要 [yield](language.generators.syntax.html#control-structures.yield) 多次，以便生成需要迭代的值。"},{"type":4,"line":"一个简单的例子就是使用生成器来重新实现 [range()](function.range.html) 函数。 标准的 [range()](function.range.html) 函数需要在内存中生成一个数组包含每一个在它范围内的值，然后返回该数组, 结果就是会产生多个很大的数组。 比如，调用 **range(0, 1000000)** 将导致内存占用超过 100 MB。"},{"type":4,"line":"做为一种替代方法, 我们可以实现一个 _xrange()_ 生成器, 只需要足够的内存来创建 **Iterator** 对象并在内部跟踪生成器的当前状态，这样只需要不到1K字节的内存。"},{"type":4,"line":"**Example #1 将 [range()](function.range.html) 实现为生成器**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function xrange($start, $limit, $step = 1) {  "},{"type":5,"line":"    if ($start < $limit) {  "},{"type":5,"line":"        if ($step <= 0) {  "},{"type":5,"line":"            throw new LogicException('Step must be +ve');  "},{"type":4,"line":"        }  "},{"type":5,"line":"  "},{"type":5,"line":"        for ($i = $start; $i <= $limit; $i += $step) {  "},{"type":5,"line":"            yield $i;  "},{"type":5,"line":"        }  "},{"type":5,"line":"    } else {  "},{"type":5,"line":"        if ($step >= 0) {  "},{"type":5,"line":"            throw new LogicException('Step must be -ve');  "},{"type":4,"line":"        }  "},{"type":5,"line":"  "},{"type":5,"line":"        for ($i = $start; $i >= $limit; $i += $step) {  "},{"type":5,"line":"            yield $i;  "},{"type":5,"line":"        }  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/*   "},{"type":4,"line":" * 注意下面range()和xrange()输出的结果是一样的。  "},{"type":4,"line":" */  "},{"type":4,"line":"  "},{"type":4,"line":"echo 'Single digit odd numbers from range():  ';  "},{"type":5,"line":"foreach (range(1, 9, 2) as $number) {  "},{"type":4,"line":"    echo \"$number \";  "},{"type":4,"line":"}  "},{"type":4,"line":"echo \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo 'Single digit odd numbers from xrange(): ';  "},{"type":5,"line":"foreach (xrange(1, 9, 2) as $number) {  "},{"type":4,"line":"    echo \"$number \";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Single digit odd numbers from range():  1 3 5 7 9 "},{"type":4,"line":"Single digit odd numbers from xrange(): 1 3 5 7 9 "},{"type":4,"line":"### **Generator** objects"},{"type":4,"line":"When a generator function is called for the first time, an object of the internal **Generator** class is returned. This object implements the **Iterator** interface in much the same way as a forward-only iterator object would, and provides methods that can be called to manipulate the state of the generator, including sending values to and returning values from it."},{"type":3,"line":"13.2 生成器语法"},{"type":4,"line":"一个生成器函数看起来像一个普通的函数，不同的是普通函数返回一个值，而一个生成器可以[yield](language.generators.syntax.html#control-structures.yield)生成许多它所需要的值。"},{"type":4,"line":"当一个生成器被调用的时候，它返回一个可以被遍历的对象.当你遍历这个对象的时候(例如通过一个[foreach](control-structures.foreach.html)循环)，PHP 将会在每次需要值的时候调用生成器函数，并在产生一个值之后保存生成器的状态，这样它就可以在需要产生下一个值的时候恢复调用状态。"},{"type":4,"line":"一旦不再需要产生更多的值，生成器函数可以简单退出，而调用生成器的代码还可以继续执行，就像一个数组已经被遍历完了。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 一个生成器不可以返回值： 这样做会产生一个编译错误。然而**return**空是一个有效的语法并且它将会终止生成器继续执行。"},{"type":4,"line":"### **yield**关键字"},{"type":4,"line":"生成器函数的核心是**yield**关键字。它最简单的调用形式看起来像一个return申明，不同之处在于普通return会返回值并终止函数的执行，而yield会返回一个值给循环调用此生成器的代码并且只是暂停执行生成器函数。"},{"type":4,"line":"**Example #1 一个简单的生成值的例子**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function gen_one_to_three() {  "},{"type":5,"line":"    for ($i = 1; $i <= 3; $i++) {  "},{"type":5,"line":"        //注意变量$i的值在不同的yield之间是保持传递的。  "},{"type":5,"line":"        yield $i;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$generator = gen_one_to_three();  "},{"type":5,"line":"foreach ($generator as $value) {  "},{"type":4,"line":"    echo \"$value\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"1"},{"type":4,"line":"2"},{"type":4,"line":"3"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在内部会为生成的值配对连续的整型索引，就像一个非关联的数组。"},{"type":4,"line":"**Caution**"},{"type":4,"line":"如果在一个表达式上下文(例如在一个赋值表达式的右侧)中使用yield，你必须使用圆括号把yield申明包围起来。 例如这样是有效的："},{"type":4,"line":"`$data = (yield $value);`"},{"type":4,"line":"而这样就不合法，并且在PHP5中会产生一个编译错误："},{"type":4,"line":"`$data = yield $value;`"},{"type":4,"line":"The parenthetical restrictions do not apply in PHP 7."},{"type":4,"line":"这个语法可以和生成器对象的[Generator::send()](generator.send.html)方法配合使用。"},{"type":4,"line":"#### 指定键名来生成值"},{"type":4,"line":"PHP的数组支持关联键值对数组，生成器也一样支持。所以除了生成简单的值，你也可以在生成值的时候指定键名。"},{"type":4,"line":"如下所示，生成一个键值对与定义一个关联数组十分相似。"},{"type":4,"line":"**Example #2 生成一个键值对**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/*   "},{"type":4,"line":" * 下面每一行是用分号分割的字段组合，第一个字段将被用作键名。  "},{"type":4,"line":" */  "},{"type":4,"line":"  "},{"type":4,"line":"$input = <<<'EOF'  "},{"type":4,"line":"1;PHP;Likes dollar signs  "},{"type":4,"line":"2;Python;Likes whitespace  "},{"type":4,"line":"3;Ruby;Likes blocks  "},{"type":4,"line":"EOF;  "},{"type":4,"line":"  "},{"type":5,"line":"function input_parser($input) {  "},{"type":5,"line":"    foreach (explode(\"\\n\", $input) as $line) {  "},{"type":5,"line":"        $fields = explode(';', $line);  "},{"type":4,"line":"        $id = array_shift($fields);  "},{"type":5,"line":"  "},{"type":5,"line":"        yield $id => $fields;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"foreach (input_parser($input) as $id => $fields) {  "},{"type":5,"line":"    echo \"$id:\\n\";  "},{"type":5,"line":"    echo \"    $fields[0]\\n\";  "},{"type":4,"line":"    echo \"    $fields[1]\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":5,"line":"1:"},{"type":5,"line":"    PHP"},{"type":4,"line":"    Likes dollar signs"},{"type":5,"line":"2:"},{"type":5,"line":"    Python"},{"type":4,"line":"    Likes whitespace"},{"type":5,"line":"3:"},{"type":5,"line":"    Ruby"},{"type":4,"line":"    Likes blocks"},{"type":4,"line":"**Caution**"},{"type":4,"line":"和之前生成简单值类型一样，在一个表达式上下文中生成键值对也需要使用圆括号进行包围："},{"type":4,"line":"`$data = (yield $key => $value);`"},{"type":4,"line":"#### 生成null值"},{"type":4,"line":"Yield可以在没有参数传入的情况下被调用来生成一个 **`NULL`**值并配对一个自动的键名。"},{"type":4,"line":"**Example #3 生成**`NULL`**s**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function gen_three_nulls() {  "},{"type":5,"line":"    foreach (range(1, 3) as $i) {  "},{"type":5,"line":"        yield;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(iterator_to_array(gen_three_nulls()));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"array(3) {"},{"type":4,"line":"  \\[0\\]=>"},{"type":4,"line":"  NULL"},{"type":4,"line":"  \\[1\\]=>"},{"type":4,"line":"  NULL"},{"type":4,"line":"  \\[2\\]=>"},{"type":4,"line":"  NULL"},{"type":4,"line":"}"},{"type":4,"line":"#### 使用引用来生成值"},{"type":4,"line":"生成函数可以像使用值一样来使用引用生成。这个和[returning references from functions](functions.returning-values.html)（从函数返回一个引用）一样：通过在函数名前面加一个引用符号。"},{"type":4,"line":"**Example #4 使用引用来生成值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function &gen_reference() {  "},{"type":4,"line":"    $value = 3;  "},{"type":5,"line":"  "},{"type":5,"line":"    while ($value > 0) {  "},{"type":5,"line":"        yield $value;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/*   "},{"type":4,"line":" * 我们可以在循环中修改$number的值，而生成器是使用的引用值来生成，所以gen_reference()内部的$value值也会跟着变化。  "},{"type":4,"line":" */  "},{"type":5,"line":"foreach (gen_reference() as &$number) {  "},{"type":4,"line":"    echo (--$number).'... ';  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"2... 1... 0... "},{"type":4,"line":"#### Generator delegation via **yield from**"},{"type":4,"line":"In PHP 7, generator delegation allows you to yield values from another generator, **Traversable** object, or [array](language.types.array.html) by using the **yield from** keyword. The outer generator will then yield all values from the inner generator, object, or array until that is no longer valid, after which execution will continue in the outer generator."},{"type":4,"line":"If a generator is used with **yield from**, the **yield from** expression will also return any value returned by the inner generator."},{"type":4,"line":"**Example #5 Basic use of **yield from****"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function count_to_ten() {  "},{"type":5,"line":"    yield 1;  "},{"type":5,"line":"    yield 2;  "},{"type":5,"line":"    yield from [3, 4];  "},{"type":5,"line":"    yield from new ArrayIterator([5, 6]);  "},{"type":5,"line":"    yield from seven_eight();  "},{"type":5,"line":"    yield 9;  "},{"type":4,"line":"    yield 10;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function seven_eight() {  "},{"type":5,"line":"    yield 7;  "},{"type":4,"line":"    yield from eight();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function eight() {  "},{"type":4,"line":"    yield 8;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"foreach (count_to_ten() as $num) {  "},{"type":4,"line":"    echo \"$num \";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"1 2 3 4 5 6 7 8 9 10 "},{"type":4,"line":"**Example #6 **yield from** and return values**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function count_to_ten() {  "},{"type":5,"line":"    yield 1;  "},{"type":5,"line":"    yield 2;  "},{"type":5,"line":"    yield from [3, 4];  "},{"type":5,"line":"    yield from new ArrayIterator([5, 6]);  "},{"type":5,"line":"    yield from seven_eight();  "},{"type":4,"line":"    return yield from nine_ten();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function seven_eight() {  "},{"type":5,"line":"    yield 7;  "},{"type":4,"line":"    yield from eight();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function eight() {  "},{"type":4,"line":"    yield 8;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function nine_ten() {  "},{"type":5,"line":"    yield 9;  "},{"type":4,"line":"    return 10;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$gen = count_to_ten();  "},{"type":5,"line":"foreach ($gen as $num) {  "},{"type":4,"line":"    echo \"$num \";  "},{"type":4,"line":"}  "},{"type":4,"line":"echo $gen->getReturn();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"1 2 3 4 5 6 7 8 9 10"},{"type":3,"line":"13.3 Comparing generators with **Iterator** objects"},{"type":4,"line":"The primary advantage of generators is their simplicity. Much less boilerplate code has to be written compared to implementing an **Iterator** class, and the code is generally much more readable. For example, the following function and class are equivalent:"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function getLinesFromFile($fileName) {  "},{"type":5,"line":"    if (!$fileHandle = fopen($fileName, 'r')) {  "},{"type":5,"line":"        return;  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    while (false !== $line = fgets($fileHandle)) {  "},{"type":5,"line":"        yield $line;  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":4,"line":"    fclose($fileHandle);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// versus...  "},{"type":4,"line":"  "},{"type":5,"line":"class LineIterator implements Iterator {  "},{"type":5,"line":"    protected $fileHandle;  "},{"type":5,"line":"   "},{"type":5,"line":"    protected $line;  "},{"type":5,"line":"    protected $i;  "},{"type":5,"line":"   "},{"type":5,"line":"    public function __construct($fileName) {  "},{"type":5,"line":"        if (!$this->fileHandle = fopen($fileName, 'r')) {  "},{"type":5,"line":"            throw new RuntimeException('Couldn\\'t open file \"' . $fileName . '\"');  "},{"type":5,"line":"        }  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    public function rewind() {  "},{"type":5,"line":"        fseek($this->fileHandle, 0);  "},{"type":5,"line":"        $this->line = fgets($this->fileHandle);  "},{"type":5,"line":"        $this->i = 0;  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    public function valid() {  "},{"type":5,"line":"        return false !== $this->line;  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    public function current() {  "},{"type":5,"line":"        return $this->line;  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    public function key() {  "},{"type":5,"line":"        return $this->i;  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    public function next() {  "},{"type":5,"line":"        if (false !== $this->line) {  "},{"type":5,"line":"            $this->line = fgets($this->fileHandle);  "},{"type":5,"line":"            $this->i++;  "},{"type":5,"line":"        }  "},{"type":5,"line":"    }  "},{"type":5,"line":"   "},{"type":5,"line":"    public function __destruct() {  "},{"type":5,"line":"        fclose($this->fileHandle);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"This flexibility does come at a cost, however: generators are forward-only iterators, and cannot be rewound once iteration has started. This also means that the same generator can't be iterated over multiple times: the generator will need to either be rebuilt by calling the generator function again, or cloned via the [clone](language.oop5.cloning.html) keyword."},{"type":1,"line":"14. 引用的解释"},{"type":3,"line":"14.1 引用是什么"},{"type":4,"line":"在 PHP 中引用意味着用不同的名字访问同一个变量内容。这并不像 C 的指针：例如你不能对他们做指针运算，他们并不是实际的内存地址…… 查看[引用不是什么](language.references.arent.html)了解更多信息。 替代的是，引用是符号表别名。注意在PHP 中，变量名和变量内容是不一样的， 因此同样的内容可以有不同的名字。最接近的比喻是 Unix 的文件名和文件本身——变量名是目录条目，而变量内容则是文件本身。引用可以被看作是 Unix 文件系统中的硬链接。"},{"type":3,"line":"14.2 引用做什么"},{"type":4,"line":"PHP 的引用允许用两个变量来指向同一个内容。意思是，当这样做时："},{"type":4,"line":"```"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a =& $b;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这意味着 $a 和 $b 指向了同一个变量。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> $a 和 $b 在这里是完全相同的，这并不是 $a 指向了 $b 或者相反，而是 $a 和 $b 指向了同一个地方。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果具有引用的数组被拷贝，其值不会解除引用。对于数组传值给函数也是如此。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果对一个未定义的变量进行引用赋值、引用参数传递或引用返回，则会自动创建该变量。"},{"type":4,"line":"> "},{"type":4,"line":"> **Example #1 对未定义的变量使用引用**"},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> function foo(&$var) { }  "},{"type":4,"line":">   "},{"type":4,"line":"> foo($a); // $a is \"created\" and assigned to null  "},{"type":4,"line":">   "},{"type":4,"line":"> $b = array();  "},{"type":4,"line":"> foo($b['b']);  "},{"type":4,"line":"> var_dump(array_key_exists('b', $b)); // bool(true)  "},{"type":4,"line":">   "},{"type":4,"line":"> $c = new StdClass;  "},{"type":4,"line":"> foo($c->d);  "},{"type":4,"line":"> var_dump(property_exists($c, 'd')); // bool(true)  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"同样的语法可以用在函数中，它返回引用，以及用在 _new_ 运算符中（PHP 4.0.4 以及以后版本）："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$bar =& new fooclass();  "},{"type":4,"line":"$foo =& find_var($bar);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"自 PHP 5 起，[new](language.oop5.basic.html#language.oop5.basic.new) 自动返回引用，因此在此使用 _\\=&_ 已经过时了并且会产生 E\\_STRICT 级别的消息。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 不用 _&_ 运算符导致对象生成了一个拷贝。如果在类中用 _$this_，它将作用于该类当前的实例。没有用 _&_ 的赋值将拷贝这个实例（例如对象）并且 _$this_ 将作用于这个拷贝上，这并不总是想要的结果。由于性能和内存消耗的问题，通常只想工作在一个实例上面。"},{"type":4,"line":"> "},{"type":4,"line":"> 尽管可以用 _@_ 运算符来_抑制_构造函数中的任何错误信息，例如用 _@new_，但用 _&new_ 语句时这不起效果。这是 Zend 引擎的一个限制并且会导致一个解析错误。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"如果在一个函数内部给一个声明为 _global_ 的变量赋于一个引用，该引用只在函数内部可见。可以通过使用 [$GLOBALS](reserved.variables.globals.html) 数组避免这一点。"},{"type":4,"line":"**Example #2 在函数内引用全局变量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$var1 = \"Example variable\";  "},{"type":4,"line":"$var2 = \"\";  "},{"type":4,"line":"  "},{"type":4,"line":"function global_references($use_globals)  "},{"type":5,"line":"{  "},{"type":5,"line":"    global $var1, $var2;  "},{"type":5,"line":"    if (!$use_globals) {  "},{"type":5,"line":"        $var2 =& $var1; // visible only inside the function  "},{"type":5,"line":"    } else {  "},{"type":5,"line":"        $GLOBALS[\"var2\"] =& $var1; // visible also in global context  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"global_references(false);  "},{"type":4,"line":"echo \"var2 is set to '$var2'\\n\"; // var2 is set to ''  "},{"type":4,"line":"global_references(true);  "},{"type":4,"line":"echo \"var2 is set to '$var2'\\n\"; // var2 is set to 'Example variable'  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"把 _global $var;_ 当成是 _$var =& $GLOBALS\\['var'\\];_ 的简写。从而将其它引用赋给 _$var_ 只改变了本地变量的引用。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果在 [foreach](control-structures.foreach.html) 语句中给一个具有引用的变量赋值，被引用的对象也被改变。"},{"type":4,"line":"> "},{"type":4,"line":"> **Example #3 引用与 foreach 语句**"},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> $ref = 0;  "},{"type":4,"line":"> $row =& $ref;  "},{"type":4,"line":"> foreach (array(1, 2, 3) as $row) {  "},{"type":4,"line":">     // do something  "},{"type":4,"line":"> }  "},{"type":4,"line":"> echo $ref; // 3 - last element of the iterated array  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"引用做的第二件事是用引用传递变量。这是通过在函数内建立一个本地变量并且该变量在呼叫范围内引用了同一个内容来实现的。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo(&$var)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $var++;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a=5;  "},{"type":4,"line":"foo($a);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"将使 $a 变成 6。这是因为在 foo 函数中变量 $var 指向了和 $a 指向的同一个内容。更多详细解释见[引用传递](language.references.pass.html)。"},{"type":4,"line":"引用做的第三件事是[引用返回](language.references.return.html)。"},{"type":3,"line":"14.3 引用不是什么"},{"type":4,"line":"如前所述，引用不是指针。这意味着下面的结构不会产生预期的效果："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo(&$var)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $var =& $GLOBALS[\"baz\"];  "},{"type":4,"line":"}  "},{"type":4,"line":"foo($bar);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这将使 foo 函数中的 $var 变量在函数调用时和 $bar 绑定在一起，但接着又被重新绑定到了 [$GLOBALS\\[\"baz\"\\]](reserved.variables.globals.html) 上面。不可能通过引用机制将 $bar 在函数调用范围内绑定到别的变量上面，因为在函数 foo 中并没有变量 $bar（它被表示为 $var，但是 $var 只有变量内容而没有调用符号表中的名字到值的绑定）。可以使用[引用返回](language.references.return.html)来引用被函数选择的变量。"},{"type":3,"line":"14.4 引用传递"},{"type":4,"line":"可以将一个变量通过引用传递给函数，这样该函数就可以修改其参数的值。语法如下："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo(&$var)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $var++;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a=5;  "},{"type":4,"line":"foo($a);  "},{"type":4,"line":"// $a is 6 here  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"注意在函数调用时没有引用符号——只有函数定义中有。光是函数定义就足够使参数通过引用来正确传递了。在最近版本的 PHP 中如果把 & 用在 _foo(&$a);_ 中会得到一条警告说“Call-time pass-by-reference”已经过时了。"},{"type":4,"line":"以下内容可以通过引用传递："},{"type":4,"line":"*   变量，例如 _foo($a)_"},{"type":4,"line":"*   New 语句，例如 _foo(new foobar())_"},{"type":5,"line":"*   从函数中返回的引用，例如："},{"type":4,"line":"    "},{"type":4,"line":"```php"},{"type":5,"line":"<?php  "},{"type":5,"line":"    function &bar()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $a = 5;  "},{"type":5,"line":"        return $a;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    foo(bar());  "},{"type":4,"line":"    ?>"},{"type":5,"line":"```"},{"type":4,"line":"    "},{"type":5,"line":"详细解释见[引用返回](language.references.return.html)。"},{"type":4,"line":"    "},{"type":4,"line":"任何其它表达式都不能通过引用传递，结果未定义。例如下面引用传递的例子是无效的："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo(&$var)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $var++;  "},{"type":4,"line":"}  "},{"type":4,"line":"function bar() // Note the missing &  "},{"type":5,"line":"{  "},{"type":5,"line":"    $a = 5;  "},{"type":4,"line":"    return $a;  "},{"type":4,"line":"}  "},{"type":5,"line":"foo(bar()); // 自 PHP 5.0.5 起导致致命错误，自 PHP 5.1.1 起导致严格模式错误  "},{"type":4,"line":"            // 自 PHP 7.0 起导致 notice 信息  "},{"type":4,"line":"foo($a = 5) // 表达式，不是变量  "},{"type":4,"line":"foo(5) // 导致致命错误  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这些条件是 PHP 4.0.4 以及以后版本有的。"},{"type":3,"line":"14.5 引用返回"},{"type":4,"line":"引用返回用在当想用函数找到引用应该被绑定在哪一个变量上面时。_不要_用返回引用来增加性能，引擎足够聪明来自己进行优化。仅在有合理的技术原因时才返回引用！要返回引用，使用此语法："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class foo {  "},{"type":4,"line":"    public $value = 42;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function &getValue() {  "},{"type":5,"line":"        return $this->value;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new foo;  "},{"type":4,"line":"$myValue = &$obj->getValue(); // $myValue is a reference to $obj->value, which is 42.  "},{"type":4,"line":"$obj->value = 2;  "},{"type":4,"line":"echo $myValue;                // prints the new value of $obj->value, i.e. 2.  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"本例中 getValue 函数所返回的对象的属性将被赋值，而不是拷贝，就和没有用引用语法一样。"},{"type":4,"line":"> **Note**: 和参数传递不同，这里必须在两个地方都用 _&_ 符号——指出返回的是一个引用，而不是通常的一个拷贝，同样也指出 $myValue 是作为引用的绑定，而不是通常的赋值。"},{"type":4,"line":"> **Note**: 如果试图这样从函数返回引用：_return ($this->value);_，这将_不会_起作用，因为在试图返回一个_表达式_的结果而不是一个引用的变量。只能从函数返回引用变量——没别的方法。如果代码试图返回一个动态表达式或 _new_ 运算符的结果，自 PHP 4.4.0 和 PHP 5.1.0 起会发出一条 **`E_NOTICE`** 错误。"},{"type":3,"line":"14.6 取消引用"},{"type":4,"line":"当 unset 一个引用，只是断开了变量名和变量内容之间的绑定。这并不意味着变量内容被销毁了。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"$b =& $a;  "},{"type":4,"line":"unset($a);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"不会 unset $b，只是 $a。"},{"type":4,"line":"再拿这个和 Unix 的 **unlink** 调用来类比一下可能有助于理解。"},{"type":3,"line":"14.7 引用定位"},{"type":4,"line":"许多 PHP 的语法结构是通过引用机制实现的，所以上述有关引用绑定的一切也都适用于这些结构。一些结构，例如引用传递和返回，已经在上面提到了。其它使用引用的结构有："},{"type":4,"line":"### _global_ 引用"},{"type":4,"line":"当用 **global $var** 声明一个变量时实际上建立了一个到全局变量的引用。也就是说和这样做是相同的："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$var =& $GLOBALS[\"var\"];  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这意味着，例如，unset $var 不会 unset 全局变量。"},{"type":4,"line":"### _$this_"},{"type":4,"line":"在一个对象的方法中，$this 永远是调用它的对象的引用。"},{"type":1,"line":"15. 预定义变量"},{"type":2,"line":"15.1 超全局变量"},{"type":4,"line":"超全局变量 — 超全局变量是在全部作用域中始终可用的内置变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"PHP 中的许多预定义变量都是“超全局的”，这意味着它们在一个脚本的全部作用域中都可用。在函数或方法中无需执行 **global $variable;** 就可以访问它们。"},{"type":4,"line":"这些超全局变量是："},{"type":4,"line":"*   [$GLOBALS](reserved.variables.globals.html)"},{"type":4,"line":"*   [$\\_SERVER](reserved.variables.server.html)"},{"type":4,"line":"*   [$\\_GET](reserved.variables.get.html)"},{"type":4,"line":"*   [$\\_POST](reserved.variables.post.html)"},{"type":4,"line":"*   [$\\_FILES](reserved.variables.files.html)"},{"type":4,"line":"*   [$\\_COOKIE](reserved.variables.cookies.html)"},{"type":4,"line":"*   [$\\_SESSION](reserved.variables.session.html)"},{"type":4,"line":"*   [$\\_REQUEST](reserved.variables.request.html)"},{"type":4,"line":"*   [$\\_ENV](reserved.variables.environment.html)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"超全局变量被引入到 PHP."},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**: **变量可用性**  "},{"type":4,"line":"> "},{"type":4,"line":"> 默认情况下，所有的超全局变量都是可用的。但是，有一些指令会影响这种可用性。更多信息，参见文档 [variables\\_order](ini.core.html#ini.variables-order)."},{"type":4,"line":"> **Note**: **处理 register\\_globals**  "},{"type":4,"line":"> "},{"type":4,"line":"> 如果已经弃用的 [register\\_globals](ini.core.html#ini.register-globals) 指令被设置为 _on_ 那么局部变量也将在脚本的全局作用域中可用。例如， [$\\_POST\\['foo'\\]](reserved.variables.post.html) 也将以 $foo 的形式存在。"},{"type":4,"line":"> "},{"type":4,"line":"> 相关信息，参见 FAQ “[register\\_globals 对我有什么影响？](faq.using.html#faq.register-globals)”"},{"type":4,"line":"> **Note**: **可变变量**  "},{"type":4,"line":"> "},{"type":4,"line":"> 在函数或类方法中，超全局变量不能被用作[可变变量](language.variables.variable.html)。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [变量作用域](language.variables.scope.html)"},{"type":4,"line":"*   [variables\\_order](ini.core.html#ini.variables-order) 指令"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.2 $GLOBALS"},{"type":4,"line":"$GLOBALS — 引用全局作用域中可用的全部变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"一个包含了全部变量的全局组合数组。变量的名字就是数组的键。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $GLOBALS 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function test() {  "},{"type":4,"line":"    $foo = \"local variable\";  "},{"type":4,"line":"  "},{"type":4,"line":"    echo '$foo in global scope: ' . $GLOBALS[\"foo\"] . \"\\n\";  "},{"type":4,"line":"    echo '$foo in current scope: ' . $foo . \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = \"Example content\";  "},{"type":4,"line":"test();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"$foo in global scope: Example content"},{"type":4,"line":"$foo in current scope: local variable"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"> **Note**: **变量可用性**  "},{"type":4,"line":"> "},{"type":4,"line":"> 与所有其他[超全局变量](language.variables.superglobals.html)不同，$GLOBALS在PHP中总是可用的。"},{"type":2,"line":"15.3 $\\_SERVER"},{"type":2,"line":"$HTTP\\_SERVER\\_VARS \\[已删除\\]"},{"type":4,"line":"$\\_SERVER -- $HTTP\\_SERVER\\_VARS \\[已删除\\] — 服务器和执行环境信息"},{"type":4,"line":"### 说明"},{"type":4,"line":"$\\_SERVER 是一个包含了诸如头信息(header)、路径(path)、以及脚本位置(script locations)等等信息的数组。这个数组中的项目由 Web 服务器创建。不能保证每个服务器都提供全部项目；服务器可能会忽略一些，或者提供一些没有在这里列举出来的项目。这也就意味着大量的此类变量都会在[» CGI 1.1 规范](http://www.faqs.org/rfcs/rfc3875)中说明，所以应该仔细研究一下。"},{"type":4,"line":"> **Note**: PHP 5.4.0 之前，$HTTP\\_SERVER\\_VARS 包含着相同的信息，但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_SERVER\\_VARS 与 $\\_SERVER 是不同的变量，PHP处理它们的方式不同)"},{"type":4,"line":"### 目录"},{"type":4,"line":"在 $\\_SERVER 中，你也许能够，也许不能够找到下面的这些元素。注意，如果以[命令行](features.commandline.html)方式运行 PHP，下面列出的元素几乎没有有效的(或是没有任何实际意义的)。"},{"type":4,"line":"'PHP\\_SELF'"},{"type":4,"line":"当前执行脚本的文件名，与 document root 有关。例如，在地址为 http://example.com/foo/bar.php 的脚本中使用 $\\_SERVER\\['PHP\\_SELF'\\] 将得到 /foo/bar.php。[\\_\\_FILE\\_\\_](language.constants.predefined.html) 常量包含当前(例如包含)文件的完整路径和文件名。 从 PHP 4.3.0 版本开始，如果 PHP 以命令行模式运行，这个变量将包含脚本名。之前的版本该变量不可用。"},{"type":4,"line":"'[argv](reserved.variables.argv.html)'"},{"type":4,"line":"传递给该脚本的参数的数组。当脚本以命令行方式运行时，argv 变量传递给程序 C 语言样式的命令行参数。当通过 GET 方式调用时，该变量包含query string。"},{"type":4,"line":"'[argc](reserved.variables.argc.html)'"},{"type":4,"line":"包含命令行模式下传递给该脚本的参数的数目(如果运行在命令行模式下)。"},{"type":4,"line":"'GATEWAY\\_INTERFACE'"},{"type":4,"line":"服务器使用的 CGI 规范的版本；例如，“_CGI/1.1_”。"},{"type":4,"line":"'SERVER\\_ADDR'"},{"type":4,"line":"当前运行脚本所在的服务器的 IP 地址。"},{"type":4,"line":"'SERVER\\_NAME'"},{"type":4,"line":"当前运行脚本所在的服务器的主机名。如果脚本运行于虚拟主机中，该名称是由那个虚拟主机所设置的值决定。"},{"type":4,"line":"> **Note**: 在 Apache 2 里，必须设置 _UseCanonicalName = On_ 和 _ServerName_。 否则该值会由客户端提供，就有可能被伪造。 上下文有安全性要求的环境里，不应该依赖此值。"},{"type":4,"line":"'SERVER\\_SOFTWARE'"},{"type":4,"line":"服务器标识字符串，在响应请求时的头信息中给出。"},{"type":4,"line":"'SERVER\\_PROTOCOL'"},{"type":4,"line":"请求页面时通信协议的名称和版本。例如，“HTTP/1.0”。"},{"type":4,"line":"'REQUEST\\_METHOD'"},{"type":4,"line":"访问页面使用的请求方法；例如，“_GET_”, “_HEAD_”，“_POST_”，“_PUT_”。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果请求方法为 _HEAD_，PHP 脚本将在发送 Header 头信息之后终止(这意味着在产生任何输出后，不再有输出缓冲)。"},{"type":4,"line":"'REQUEST\\_TIME'"},{"type":4,"line":"请求开始时的时间戳。从 PHP 5.1.0 起可用。"},{"type":4,"line":"'REQUEST\\_TIME\\_FLOAT'"},{"type":4,"line":"请求开始时的时间戳，微秒级别的精准度。 自 PHP 5.4.0 开始生效。"},{"type":4,"line":"'QUERY\\_STRING'"},{"type":4,"line":"query string（查询字符串），如果有的话，通过它进行页面访问。"},{"type":4,"line":"'DOCUMENT\\_ROOT'"},{"type":4,"line":"当前运行脚本所在的文档根目录。在服务器配置文件中定义。"},{"type":4,"line":"'HTTP\\_ACCEPT'"},{"type":4,"line":"当前请求头中 _Accept:_ 项的内容，如果存在的话。"},{"type":4,"line":"'HTTP\\_ACCEPT\\_CHARSET'"},{"type":4,"line":"当前请求头中 _Accept-Charset:_ 项的内容，如果存在的话。例如：“_iso-8859-1,\\*,utf-8_”。"},{"type":4,"line":"'HTTP\\_ACCEPT\\_ENCODING'"},{"type":4,"line":"当前请求头中 _Accept-Encoding:_ 项的内容，如果存在的话。例如：“_gzip_”。"},{"type":4,"line":"'HTTP\\_ACCEPT\\_LANGUAGE'"},{"type":4,"line":"当前请求头中 _Accept-Language:_ 项的内容，如果存在的话。例如：“_en_”。"},{"type":4,"line":"'HTTP\\_CONNECTION'"},{"type":4,"line":"当前请求头中 _Connection:_ 项的内容，如果存在的话。例如：“_Keep-Alive_”。"},{"type":4,"line":"'HTTP\\_HOST'"},{"type":4,"line":"当前请求头中 _Host:_ 项的内容，如果存在的话。"},{"type":4,"line":"'HTTP\\_REFERER'"},{"type":4,"line":"引导用户代理到当前页的前一页的地址（如果存在）。由 user agent 设置决定。并不是所有的用户代理都会设置该项，有的还提供了修改 HTTP\\_REFERER 的功能。简言之，该值并不可信。"},{"type":4,"line":"'HTTP\\_USER\\_AGENT'"},{"type":4,"line":"当前请求头中 _User-Agent:_ 项的内容，如果存在的话。该字符串表明了访问该页面的用户代理的信息。一个典型的例子是：Mozilla/4.5 \\[en\\] (X11; U; Linux 2.2.9 i586)。除此之外，你可以通过 [get\\_browser()](function.get-browser.html) 来使用该值，从而定制页面输出以便适应用户代理的性能。"},{"type":4,"line":"'HTTPS'"},{"type":4,"line":"如果脚本是通过 HTTPS 协议被访问，则被设为一个非空的值。"},{"type":4,"line":"> **Note**: 注意当使用 IIS 上的 ISAPI 方式时，如果不是通过 HTTPS 协议被访问，这个值将为 _off_。"},{"type":4,"line":"'REMOTE\\_ADDR'"},{"type":4,"line":"浏览当前页面的用户的 IP 地址。"},{"type":4,"line":"'REMOTE\\_HOST'"},{"type":4,"line":"浏览当前页面的用户的主机名。DNS 反向解析不依赖于用户的 REMOTE\\_ADDR。"},{"type":4,"line":"> **Note**: 你的服务器必须被配置以便产生这个变量。例如在 Apache 中，你需要在 httpd.conf 中设置 _HostnameLookups On_ 来产生它。参见 [gethostbyaddr()](function.gethostbyaddr.html)。"},{"type":4,"line":"'REMOTE\\_PORT'"},{"type":4,"line":"用户机器上连接到 Web 服务器所使用的端口号。"},{"type":4,"line":"'REMOTE\\_USER'"},{"type":4,"line":"经验证的用户"},{"type":4,"line":"'REDIRECT\\_REMOTE\\_USER'"},{"type":4,"line":"验证的用户，如果请求已在内部重定向。"},{"type":4,"line":"'SCRIPT\\_FILENAME'"},{"type":4,"line":"当前执行脚本的绝对路径。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果在命令行界面（Command Line Interface, CLI）使用相对路径执行脚本，例如 file.php 或 ../file.php，那么 $\\_SERVER\\['SCRIPT\\_FILENAME'\\] 将包含用户指定的相对路径。"},{"type":4,"line":"'SERVER\\_ADMIN'"},{"type":4,"line":"该值指明了 Apache 服务器配置文件中的 SERVER\\_ADMIN 参数。如果脚本运行在一个虚拟主机上，则该值是那个虚拟主机的值。"},{"type":4,"line":"'SERVER\\_PORT'"},{"type":4,"line":"Web 服务器使用的端口。默认值为 “_80_”。如果使用 SSL 安全连接，则这个值为用户设置的 HTTP 端口。"},{"type":4,"line":"> **Note**: 在 Apache 2 里，为了获取真实物理端口，必须设置 _UseCanonicalName = On_ 以及 _UseCanonicalPhysicalPort = On_。 否则此值可能被伪造，不一定会返回真实端口值。 上下文有安全性要求的环境里，不应该依赖此值。"},{"type":4,"line":"'SERVER\\_SIGNATURE'"},{"type":4,"line":"包含了服务器版本和虚拟主机名的字符串。"},{"type":4,"line":"'PATH\\_TRANSLATED'"},{"type":4,"line":"当前脚本所在文件系统（非文档根目录）的基本路径。这是在服务器进行虚拟到真实路径的映像后的结果。"},{"type":4,"line":"> **Note**: 自 PHP 4.3.2 起，PATH\\_TRANSLATED 在 Apache 2 SAPI 模式下不再和 Apache 1 一样隐含赋值，而是若 Apache 不生成此值，PHP 便自己生成并将其值放入 SCRIPT\\_FILENAME 服务器常量中。这个修改遵守了 CGI 规范，PATH\\_TRANSLATED 仅在 PATH\\_INFO 被定义的条件下才存在。 Apache 2 用户可以在 httpd.conf 中设置 _AcceptPathInfo = On_ 来定义 PATH\\_INFO。"},{"type":4,"line":"'SCRIPT\\_NAME'"},{"type":4,"line":"包含当前脚本的路径。这在页面需要指向自己时非常有用。[\\_\\_FILE\\_\\_](language.constants.predefined.html) 常量包含当前脚本(例如包含文件)的完整路径和文件名。"},{"type":4,"line":"'REQUEST\\_URI'"},{"type":4,"line":"URI 用来指定要访问的页面。例如 “_/index.html_”。"},{"type":4,"line":"'PHP\\_AUTH\\_DIGEST'"},{"type":4,"line":"当作为 Apache 模块运行时，进行 HTTP Digest 认证的过程中，此变量被设置成客户端发送的“Authorization” HTTP 头内容（以便作进一步的认证操作）。"},{"type":4,"line":"'PHP\\_AUTH\\_USER'"},{"type":4,"line":"当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的用户名。"},{"type":4,"line":"'PHP\\_AUTH\\_PW'"},{"type":4,"line":"当 PHP 运行在 Apache 或 IIS（PHP 5 是 ISAPI）模块方式下，并且正在使用 HTTP 认证功能，这个变量便是用户输入的密码。"},{"type":4,"line":"'AUTH\\_TYPE'"},{"type":4,"line":"当 PHP 运行在 Apache 模块方式下，并且正在使用 HTTP 认证功能，这个变量便是认证的类型。"},{"type":4,"line":"'PATH\\_INFO'"},{"type":4,"line":"包含由客户端提供的、跟在真实脚本名称之后并且在查询语句（query string）之前的路径信息，如果存在的话。例如，如果当前脚本是通过 URL http://www.example.com/php/path\\_info.php/some/stuff?foo=bar 被访问，那么 $\\_SERVER\\['PATH\\_INFO'\\] 将包含 _/some/stuff_。"},{"type":4,"line":"'ORIG\\_PATH\\_INFO'"},{"type":4,"line":"在被 PHP 处理之前，“PATH\\_INFO” 的原始版本。"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.4.0"},{"type":4,"line":"因为移除了 long array register 功能，$HTTP\\_SERVER\\_VARS 不再有效。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"废弃了使 $HTTP\\_SERVER\\_VARS 生效的 [register\\_long\\_arrays](ini.core.html#ini.register-long-arrays) 指令。"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_SERVER，弃用 $HTTP\\_SERVER\\_VARS。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $\\_SERVER 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo $_SERVER['SERVER_NAME'];  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"www.example.com"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.4 $\\_GET"},{"type":2,"line":"$HTTP\\_GET\\_VARS \\[已弃用\\]"},{"type":4,"line":"$\\_GET -- $HTTP\\_GET\\_VARS \\[已弃用\\] — HTTP GET 变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"通过 URL 参数传递给当前脚本的变量的数组。"},{"type":4,"line":"$HTTP\\_GET\\_VARS 包含相同的信息， 但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_GET\\_VARS 和 $\\_GET 是不同的变量，PHP 处理它们的方式不同)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_GET，弃用 $HTTP\\_GET\\_VARS。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $\\_GET 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo 'Hello ' . htmlspecialchars($_GET[\"name\"]) . '!';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"假设用户访问的是 http://example.com/?name=Hannes"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"Hello Hannes!"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> GET 是通过 [urldecode()](function.urldecode.html) 传递的。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [处理外部变量](language.variables.external.html)"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.5 $\\_POST"},{"type":2,"line":"$HTTP\\_POST\\_VARS \\[已弃用\\]"},{"type":4,"line":"$\\_POST -- $HTTP\\_POST\\_VARS \\[已弃用\\] — HTTP POST 变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"当 HTTP POST 请求的 Content-Type 是 _application/x-www-form-urlencoded_ 或 _multipart/form-data_ 时，会将变量以关联数组形式传入当前脚本。"},{"type":4,"line":"$HTTP\\_POST\\_VARS 包含相同的信息，但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_POST\\_VARS 和 $\\_POST 是不同的变量，PHP 处理它们的方式不同)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_POST，弃用 $HTTP\\_POST\\_VARS。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $\\_POST 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo 'Hello ' . htmlspecialchars($_POST[\"name\"]) . '!';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"假设用户通过 HTTP POST 方式传递了参数 name=Hannes"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"Hello Hannes!"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [处理外部变量](language.variables.external.html)"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.6 $\\_FILES"},{"type":2,"line":"$HTTP\\_POST\\_FILES \\[已弃用\\]"},{"type":4,"line":"$\\_FILES -- $HTTP\\_POST\\_FILES \\[已弃用\\] — HTTP 文件上传变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"通过 HTTP POST 方式上传到当前脚本的项目的数组。 此数组的概况在 [POST 方法上传](features.file-upload.post-method.html) 章节中有描述。"},{"type":4,"line":"$HTTP\\_POST\\_FILES 包含相同的信息，但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_POST\\_FILES 和 $\\_FILES 是不同的变量，PHP 处理它们的方式不同)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_FILES，弃用 $HTTP\\_POST\\_FILES。"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [move\\_uploaded\\_file()](function.move-uploaded-file.html) - 将上传的文件移动到新位置"},{"type":4,"line":"*   [处理文件上传](features.file-upload.html)"},{"type":2,"line":"15.7 $\\_REQUEST"},{"type":4,"line":"$\\_REQUEST — HTTP Request 变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"默认情况下包含了 [$\\_GET](reserved.variables.get.html)，[$\\_POST](reserved.variables.post.html) 和 [$\\_COOKIE](reserved.variables.cookies.html) 的数组。"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.3.0"},{"type":4,"line":"引入 [request\\_order](ini.core.html#ini.request-order)。该指令会影响 $\\_REQUEST 的内容。"},{"type":4,"line":"4.3.0"},{"type":4,"line":"[$\\_FILES](reserved.variables.files.html) 信息被从 $\\_REQUEST 中移除。"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_REQUEST。"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 以[命令行](features.commandline.html)方式运行时，将_不_包含 [argv](reserved.variables.argv.html) 和 [argc](reserved.variables.argc.html) 信息；它们将存在于 [$\\_SERVER](reserved.variables.server.html) 数组。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 由于 $\\_REQUEST 中的变量通过 GET，POST 和 COOKIE 输入机制传递给脚本文件，因此可以被远程用户篡改而并不可信。这个数组的项目及其顺序依赖于 PHP 的 [variables\\_order](ini.core.html#ini.variables-order) 指令的配置。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [import\\_request\\_variables()](function.import-request-variables.html) - 将 GET／POST／Cookie 变量导入到全局作用域中"},{"type":4,"line":"*   [处理外部变量](language.variables.external.html)"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.8 $\\_SESSION"},{"type":2,"line":"$HTTP\\_SESSION\\_VARS \\[已弃用\\]"},{"type":4,"line":"$\\_SESSION -- $HTTP\\_SESSION\\_VARS \\[已弃用\\] — Session 变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"当前脚本可用 SESSION 变量的数组。更多关于如何使用的信息，参见 [Session 函数](ref.session.html) 文档。"},{"type":4,"line":"$HTTP\\_SESSION\\_VARS 包含相同的信息，但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_SESSION\\_VARS 和 $\\_SESSION 是不同的变量，PHP 处理它们的方式不同)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_SESSION，弃用 $HTTP\\_SESSION\\_VARS。"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [session\\_start()](function.session-start.html) - 启动新会话或者重用现有会话"},{"type":2,"line":"15.9 $\\_ENV"},{"type":2,"line":"$HTTP\\_ENV\\_VARS \\[已弃用\\]"},{"type":4,"line":"$\\_ENV -- $HTTP\\_ENV\\_VARS \\[已弃用\\] — 环境变量"},{"type":4,"line":"### 说明"},{"type":4,"line":"通过环境方式传递给当前脚本的变量的数组。"},{"type":4,"line":"这些变量被从 PHP 解析器的运行环境导入到 PHP 的全局命名空间。很多是由支持 PHP 运行的 Shell 提供的，并且不同的系统很可能运行着不同种类的 Shell，所以不可能有一份确定的列表。请查看你的 Shell 文档来获取定义的环境变量列表。"},{"type":4,"line":"其他环境变量包含了 CGI 变量，而不管 PHP 是以服务器模块还是 CGI 处理器的方式运行。"},{"type":4,"line":"$HTTP\\_ENV\\_VARS 包含相同的信息，但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_ENV\\_VARS 和 $\\_ENV 是不同的变量，PHP 处理它们的方式不同)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_ENV，弃用 $HTTP\\_ENV\\_VARS。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $\\_ENV 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo 'My username is ' .$_ENV[\"USER\"] . '!';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"假设 \"bjori\" 运行此段脚本"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"My username is bjori!"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [getenv()](function.getenv.html) - 获取一个环境变量的值"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.10 $\\_COOKIE"},{"type":2,"line":"$HTTP\\_COOKIE\\_VARS \\[已弃用\\]"},{"type":4,"line":"$\\_COOKIE -- $HTTP\\_COOKIE\\_VARS \\[已弃用\\] — HTTP Cookies"},{"type":4,"line":"### 说明"},{"type":4,"line":"通过 HTTP Cookies 方式传递给当前脚本的变量的数组。"},{"type":4,"line":"$HTTP\\_COOKIE\\_VARS 包含相同的信息，但它不是一个[超全局变量](language.variables.superglobals.html)。 (注意 $HTTP\\_COOKIE\\_VARS 和 $\\_COOKIE 是不同的变量，PHP 处理它们的方式不同)"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.1.0"},{"type":4,"line":"引入 $\\_COOKIE，弃用 $HTTP\\_COOKIE\\_VARS。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $\\_COOKIE 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo 'Hello ' . htmlspecialchars($_COOKIE[\"name\"]) . '!';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"假设之前发送了 \"name\" Cookie"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"Hello Hannes!"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> “Superglobal”也称为自动化的全局变量。这就表示其在脚本的所有作用域中都是可用的。不需要在函数或方法中用 **global $variable;** 来访问它。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [setcookie()](function.setcookie.html) - 发送 Cookie"},{"type":4,"line":"*   [处理外部变量](language.variables.external.html)"},{"type":4,"line":"*   [过滤器扩展](book.filter.html)"},{"type":2,"line":"15.11 $php\\_errormsg"},{"type":4,"line":"$php\\_errormsg — 前一个错误信息"},{"type":4,"line":"**Warning**"},{"type":4,"line":"This feature has been _DEPRECATED_ as of PHP 7.2.0. Relying on this feature is highly discouraged."},{"type":4,"line":"### 说明"},{"type":4,"line":"$php\\_errormsg 变量包含由 PHP 生成的最新错误信息。这个变量只在错误发生的作用域内可用，并且要求 [track\\_errors](errorfunc.configuration.html#ini.track-errors) 配置项是开启的（默认是关闭的）。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"如果用户定义了错误处理句柄（[set\\_error\\_handler()](function.set-error-handler.html)）并且返回 **`FALSE`** 的时候，$php\\_errormsg 就会被设置。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $php\\_errormsg 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"@strpos();  "},{"type":4,"line":"echo $php_errormsg;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"Wrong parameter count for strpos()"},{"type":2,"line":"15.12 $HTTP\\_RAW\\_POST\\_DATA"},{"type":4,"line":"$HTTP\\_RAW\\_POST\\_DATA — 原生POST数据"},{"type":4,"line":"### 说明"},{"type":4,"line":"**Warning**"},{"type":4,"line":"This feature was _DEPRECATED_ in PHP 5.6.0, and _REMOVED_ as of PHP 7.0.0."},{"type":4,"line":"$HTTP\\_RAW\\_POST\\_DATA 包含 POST 提交的原始数据。参见 [always\\_populate\\_raw\\_post\\_data](ini.core.html#ini.always-populate-raw-post-data)"},{"type":4,"line":"一般而言，使用 [_php://input_](wrappers.php.html#wrappers.php.input) 代替 $HTTP\\_RAW\\_POST\\_DATA。"},{"type":2,"line":"15.13 $http\\_response\\_header"},{"type":4,"line":"$http\\_response\\_header — HTTP 响应头"},{"type":4,"line":"### 说明"},{"type":4,"line":"$http\\_response\\_header 数组与 [get\\_headers()](function.get-headers.html) 函数类似。当使用[HTTP 包装器](wrappers.http.html)时，$http\\_response\\_header 将会被 HTTP 响应头信息填充。$http\\_response\\_header 将被创建于[局部作用域](language.variables.scope.html)中。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $http\\_response\\_header 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function get_contents() {  "},{"type":4,"line":"  file_get_contents(\"http://example.com\");  "},{"type":4,"line":"  var_dump($http_response_header);  "},{"type":4,"line":"}  "},{"type":4,"line":"get_contents();  "},{"type":4,"line":"var_dump($http_response_header);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"array(9) {"},{"type":4,"line":"  \\[0\\]=>"},{"type":4,"line":"  string(15) \"HTTP/1.1 200 OK\""},{"type":4,"line":"  \\[1\\]=>"},{"type":4,"line":"  string(35) \"Date: Sat, 12 Apr 2008 17:30:38 GMT\""},{"type":4,"line":"  \\[2\\]=>"},{"type":4,"line":"  string(29) \"Server: Apache/2.2.3 (CentOS)\""},{"type":4,"line":"  \\[3\\]=>"},{"type":4,"line":"  string(44) \"Last-Modified: Tue, 15 Nov 2005 13:24:10 GMT\""},{"type":4,"line":"  \\[4\\]=>"},{"type":4,"line":"  string(27) \"ETag: \"280100-1b6-80bfd280\"\""},{"type":4,"line":"  \\[5\\]=>"},{"type":4,"line":"  string(20) \"Accept-Ranges: bytes\""},{"type":4,"line":"  \\[6\\]=>"},{"type":4,"line":"  string(19) \"Content-Length: 438\""},{"type":4,"line":"  \\[7\\]=>"},{"type":4,"line":"  string(17) \"Connection: close\""},{"type":4,"line":"  \\[8\\]=>"},{"type":4,"line":"  string(38) \"Content-Type: text/html; charset=UTF-8\""},{"type":4,"line":"}"},{"type":4,"line":"NULL"},{"type":2,"line":"15.14 $argc"},{"type":4,"line":"$argc — 传递给脚本的参数数目"},{"type":4,"line":"### 说明"},{"type":4,"line":"包含当运行于[命令行](features.commandline.html)下时传递给当前脚本的参数的数目。"},{"type":4,"line":"> **Note**: 脚本的文件名总是作为参数传递给当前脚本，因此 $argc 的最小值为 _1_。"},{"type":4,"line":"> **Note**: 这个变量仅在 [register\\_argc\\_argv](ini.core.html#ini.register-argc-argv) 打开时可用。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $argc 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"var_dump($argc);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当使用这个命令执行: php script.php arg1 arg2 arg3"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"int(4)"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 也可以在 [$\\_SERVER\\['argc'\\]](reserved.variables.server.html) 中获取。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [getopt()](function.getopt.html) - 从命令行参数列表中获取选项"},{"type":4,"line":"*   [](reserved.variables.argv.html)[$argv](reserved.variables.argv.html)"},{"type":2,"line":"15.15 $argv"},{"type":4,"line":"$argv — 传递给脚本的参数数组"},{"type":4,"line":"### 说明"},{"type":4,"line":"包含当运行于[命令行](features.commandline.html)下时传递给当前脚本的参数的数组。"},{"type":4,"line":"> **Note**: 第一个参数总是当前脚本的文件名，因此 $argv\\[0\\] 就是脚本文件名。"},{"type":4,"line":"> **Note**: 这个变量仅在 [register\\_argc\\_argv](ini.core.html#ini.register-argc-argv) 打开时可用。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 $argv 范例**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"var_dump($argv);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当使用这个命令执行：php script.php arg1 arg2 arg3"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"array(4) {"},{"type":4,"line":"  \\[0\\]=>"},{"type":4,"line":"  string(10) \"script.php\""},{"type":4,"line":"  \\[1\\]=>"},{"type":4,"line":"  string(4) \"arg1\""},{"type":4,"line":"  \\[2\\]=>"},{"type":4,"line":"  string(4) \"arg2\""},{"type":4,"line":"  \\[3\\]=>"},{"type":4,"line":"  string(4) \"arg3\""},{"type":4,"line":"}"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [getopt()](function.getopt.html) - 从命令行参数列表中获取选项"},{"type":1,"line":"16. 预定义异常"},{"type":2,"line":"16.1 Exception"},{"type":4,"line":"(PHP 5, PHP 7)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"**Exception**是所有异常的基类。"},{"type":3,"line":"类摘要"},{"type":4,"line":"**Exception** {"},{"type":4,"line":"/\\* 属性 \\*/"},{"type":4,"line":"protected string [$message](class.exception.html#exception.props.message) ;"},{"type":4,"line":"protected int [$code](class.exception.html#exception.props.code) ;"},{"type":4,"line":"protected string [$file](class.exception.html#exception.props.file) ;"},{"type":4,"line":"protected int [$line](class.exception.html#exception.props.line) ;"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"public [\\_\\_construct](exception.construct.html) (\\[ string `$message` = \"\" \\[, int `$code` = 0 \\[, Throwable `$previous` = **`NULL`** \\]\\]\\] )"},{"type":4,"line":"final public [getMessage](exception.getmessage.html) ( void ) : string"},{"type":4,"line":"final public [getPrevious](exception.getprevious.html) ( void ) : Throwable"},{"type":4,"line":"final public [getCode](exception.getcode.html) ( void ) : int"},{"type":4,"line":"final public [getFile](exception.getfile.html) ( void ) : string"},{"type":4,"line":"final public [getLine](exception.getline.html) ( void ) : int"},{"type":4,"line":"final public [getTrace](exception.gettrace.html) ( void ) : array"},{"type":4,"line":"final public [getTraceAsString](exception.gettraceasstring.html) ( void ) : string"},{"type":4,"line":"public [\\_\\_toString](exception.tostring.html) ( void ) : string"},{"type":4,"line":"final private [\\_\\_clone](exception.clone.html) ( void ) : void"},{"type":4,"line":"}"},{"type":4,"line":"属性"},{"type":4,"line":"--"},{"type":4,"line":"message"},{"type":4,"line":"异常消息内容"},{"type":4,"line":"code"},{"type":4,"line":"异常代码"},{"type":4,"line":"file"},{"type":4,"line":"抛出异常的文件名"},{"type":4,"line":"line"},{"type":4,"line":"抛出异常在该文件中的行号"},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [Exception::\\_\\_construct](exception.construct.html) — 异常构造函数"},{"type":4,"line":"*   [Exception::getMessage](exception.getmessage.html) — 获取异常消息内容"},{"type":4,"line":"*   [Exception::getPrevious](exception.getprevious.html) — 返回异常链中的前一个异常"},{"type":4,"line":"*   [Exception::getCode](exception.getcode.html) — 获取异常代码"},{"type":4,"line":"*   [Exception::getFile](exception.getfile.html) — 创建异常时的程序文件名称"},{"type":4,"line":"*   [Exception::getLine](exception.getline.html) — 获取创建的异常所在文件中的行号"},{"type":4,"line":"*   [Exception::getTrace](exception.gettrace.html) — 获取异常追踪信息"},{"type":4,"line":"*   [Exception::getTraceAsString](exception.gettraceasstring.html) — 获取字符串类型的异常追踪信息"},{"type":4,"line":"*   [Exception::\\_\\_toString](exception.tostring.html) — 将异常对象转换为字符串"},{"type":4,"line":"*   [Exception::\\_\\_clone](exception.clone.html) — 异常克隆"},{"type":2,"line":"16.2 ErrorException"},{"type":4,"line":"(PHP 5 >= 5.1.0, PHP 7)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"错误异常。"},{"type":3,"line":"类摘要"},{"type":4,"line":"**ErrorException** extends [Exception](class.exception.html) {"},{"type":4,"line":"/\\* 属性 \\*/"},{"type":4,"line":"protected int [$severity](class.errorexception.html#errorexception.props.severity) ;"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"public [\\_\\_construct](errorexception.construct.html) (\\[ string `$message` = \"\" \\[, int `$code` = 0 \\[, int `$severity` = E\\_ERROR \\[, string `$filename` = \\_\\_FILE\\_\\_ \\[, int `$lineno` = \\_\\_LINE\\_\\_ \\[, [Exception](class.exception.html) `$previous` = **`NULL`** \\]\\]\\]\\]\\]\\] )"},{"type":4,"line":"final public [getSeverity](errorexception.getseverity.html) ( void ) : int"},{"type":4,"line":"/\\* 继承的方法 \\*/"},{"type":4,"line":"final public [Exception::getMessage](exception.getmessage.html) ( void ) : string"},{"type":4,"line":"final public [Exception::getPrevious](exception.getprevious.html) ( void ) : Throwable"},{"type":4,"line":"final public [Exception::getCode](exception.getcode.html) ( void ) : int"},{"type":4,"line":"final public [Exception::getFile](exception.getfile.html) ( void ) : string"},{"type":4,"line":"final public [Exception::getLine](exception.getline.html) ( void ) : int"},{"type":4,"line":"final public [Exception::getTrace](exception.gettrace.html) ( void ) : array"},{"type":4,"line":"final public [Exception::getTraceAsString](exception.gettraceasstring.html) ( void ) : string"},{"type":4,"line":"public [Exception::\\_\\_toString](exception.tostring.html) ( void ) : string"},{"type":4,"line":"final private [Exception::\\_\\_clone](exception.clone.html) ( void ) : void"},{"type":4,"line":"}"},{"type":4,"line":"属性"},{"type":4,"line":"--"},{"type":4,"line":"severity"},{"type":4,"line":"异常级别"},{"type":4,"line":"范例"},{"type":4,"line":"--"},{"type":4,"line":"**Example #1 使用[set\\_error\\_handler()](function.set-error-handler.html)函数将错误信息托管至ErrorException**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function exception_error_handler($errno, $errstr, $errfile, $errline ) {  "},{"type":4,"line":"    throw new ErrorException($errstr, 0, $errno, $errfile, $errline);  "},{"type":4,"line":"}  "},{"type":4,"line":"set_error_handler(\"exception_error_handler\");  "},{"type":4,"line":"  "},{"type":4,"line":"/* Trigger exception */  "},{"type":4,"line":"strpos();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"Fatal error: Uncaught exception 'ErrorException' with message 'Wrong parameter count for strpos()' in /home/bjori/tmp/ex.php:8"},{"type":4,"line":"Stack trace:"},{"type":4,"line":"```"},{"type":4,"line":"#0 \\[internal function\\]: exception\\_error\\_handler(2, 'Wrong parameter...', '/home/bjori/php...', 8, Array)"},{"type":4,"line":"#1 /home/bjori/php/cleandocs/test.php(8): strpos()"},{"type":4,"line":"#2 {main}"},{"type":4,"line":"  thrown in /home/bjori/tmp/ex.php on line 8"},{"type":4,"line":"```"},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [ErrorException::\\_\\_construct](errorexception.construct.html) — 构造一个异常（Exception）"},{"type":4,"line":"*   [ErrorException::getSeverity](errorexception.getseverity.html) — 获取异常的严重程度"},{"type":1,"line":"17. 预定义接口"},{"type":2,"line":"17.1 Traversable（遍历）接口"},{"type":4,"line":"(No version information available, might only be in Git)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"检测一个类是否可以使用 [foreach](control-structures.foreach.html) 进行遍历的接口。"},{"type":4,"line":"无法被单独实现的基本抽象接口。相反它必须由 **IteratorAggregate** 或 **Iterator** 接口实现。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 实现此接口的内建类可以使用 [foreach](control-structures.foreach.html) 进行遍历而无需实现 **IteratorAggregate** 或 **Iterator** 接口。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 这是一个无法在 PHP 脚本中实现的内部引擎接口。**IteratorAggregate** 或 **Iterator** 接口可以用来代替它。"},{"type":3,"line":"接口摘要"},{"type":4,"line":"**Traversable** {"},{"type":4,"line":"}"},{"type":4,"line":"这个接口没有任何方法，它的作用仅仅是作为所有可遍历类的基本接口。"},{"type":2,"line":"17.2 Iterator（迭代器）接口"},{"type":4,"line":"(No version information available, might only be in Git)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"可在内部迭代自己的外部迭代器或类的接口。"},{"type":3,"line":"接口摘要"},{"type":4,"line":"**Iterator** extends **Traversable** {"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"abstract public [current](iterator.current.html) ( void ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"abstract public [key](iterator.key.html) ( void ) : scalar"},{"type":4,"line":"abstract public [next](iterator.next.html) ( void ) : void"},{"type":4,"line":"abstract public [rewind](iterator.rewind.html) ( void ) : void"},{"type":4,"line":"abstract public [valid](iterator.valid.html) ( void ) : bool"},{"type":4,"line":"}"},{"type":3,"line":"预定义迭代器"},{"type":4,"line":"PHP 已经提供了一些用于日常任务的迭代器。 详细列表参见 [SPL 迭代器](spl.iterators.html)。"},{"type":4,"line":"范例"},{"type":4,"line":"--"},{"type":4,"line":"**Example #1 基本用法**"},{"type":4,"line":"这个例子展示了使用 [foreach](control-structures.foreach.html) 时，迭代器方法的调用顺序。"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class myIterator implements Iterator {  "},{"type":5,"line":"    private $position = 0;  "},{"type":5,"line":"    private $array = array(  "},{"type":5,"line":"        \"firstelement\",  "},{"type":5,"line":"        \"secondelement\",  "},{"type":5,"line":"        \"lastelement\",  "},{"type":4,"line":"    );    "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct() {  "},{"type":5,"line":"        $this->position = 0;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    function rewind() {  "},{"type":5,"line":"        var_dump(__METHOD__);  "},{"type":5,"line":"        $this->position = 0;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    function current() {  "},{"type":5,"line":"        var_dump(__METHOD__);  "},{"type":5,"line":"        return $this->array[$this->position];  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    function key() {  "},{"type":5,"line":"        var_dump(__METHOD__);  "},{"type":5,"line":"        return $this->position;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    function next() {  "},{"type":5,"line":"        var_dump(__METHOD__);  "},{"type":5,"line":"        ++$this->position;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    function valid() {  "},{"type":5,"line":"        var_dump(__METHOD__);  "},{"type":5,"line":"        return isset($this->array[$this->position]);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$it = new myIterator;  "},{"type":4,"line":"  "},{"type":5,"line":"foreach($it as $key => $value) {  "},{"type":5,"line":"    var_dump($key, $value);  "},{"type":4,"line":"    echo \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"string(18) \"myIterator::rewind\""},{"type":4,"line":"string(17) \"myIterator::valid\""},{"type":4,"line":"string(19) \"myIterator::current\""},{"type":4,"line":"string(15) \"myIterator::key\""},{"type":4,"line":"int(0)"},{"type":4,"line":"string(12) \"firstelement\""},{"type":4,"line":"string(16) \"myIterator::next\""},{"type":4,"line":"string(17) \"myIterator::valid\""},{"type":4,"line":"string(19) \"myIterator::current\""},{"type":4,"line":"string(15) \"myIterator::key\""},{"type":4,"line":"int(1)"},{"type":4,"line":"string(13) \"secondelement\""},{"type":4,"line":"string(16) \"myIterator::next\""},{"type":4,"line":"string(17) \"myIterator::valid\""},{"type":4,"line":"string(19) \"myIterator::current\""},{"type":4,"line":"string(15) \"myIterator::key\""},{"type":4,"line":"int(2)"},{"type":4,"line":"string(11) \"lastelement\""},{"type":4,"line":"string(16) \"myIterator::next\""},{"type":4,"line":"string(17) \"myIterator::valid\""},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [Iterator::current](iterator.current.html) — 返回当前元素"},{"type":4,"line":"*   [Iterator::key](iterator.key.html) — 返回当前元素的键"},{"type":4,"line":"*   [Iterator::next](iterator.next.html) — 向前移动到下一个元素"},{"type":4,"line":"*   [Iterator::rewind](iterator.rewind.html) — 返回到迭代器的第一个元素"},{"type":4,"line":"*   [Iterator::valid](iterator.valid.html) — 检查当前位置是否有效"},{"type":2,"line":"17.3 IteratorAggregate（聚合式迭代器）接口"},{"type":4,"line":"(No version information available, might only be in Git)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"创建外部迭代器的接口。"},{"type":3,"line":"接口摘要"},{"type":4,"line":"**IteratorAggregate** extends **Traversable** {"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"abstract public [getIterator](iteratoraggregate.getiterator.html) ( void ) : [Traversable](class.traversable.html)"},{"type":4,"line":"}"},{"type":4,"line":"**Example #1 基本用法**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class myData implements IteratorAggregate {  "},{"type":5,"line":"    public $property1 = \"Public property one\";  "},{"type":5,"line":"    public $property2 = \"Public property two\";  "},{"type":4,"line":"    public $property3 = \"Public property three\";  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct() {  "},{"type":5,"line":"        $this->property4 = \"last property\";  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function getIterator() {  "},{"type":5,"line":"        return new ArrayIterator($this);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new myData;  "},{"type":4,"line":"  "},{"type":5,"line":"foreach($obj as $key => $value) {  "},{"type":5,"line":"    var_dump($key, $value);  "},{"type":4,"line":"    echo \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"string(9) \"property1\""},{"type":4,"line":"string(19) \"Public property one\""},{"type":4,"line":"string(9) \"property2\""},{"type":4,"line":"string(19) \"Public property two\""},{"type":4,"line":"string(9) \"property3\""},{"type":4,"line":"string(21) \"Public property three\""},{"type":4,"line":"string(9) \"property4\""},{"type":4,"line":"string(13) \"last property\""},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [IteratorAggregate::getIterator](iteratoraggregate.getiterator.html) — 获取一个外部迭代器"},{"type":2,"line":"17.4 ArrayAccess（数组式访问）接口"},{"type":4,"line":"(No version information available, might only be in Git)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"提供像访问数组一样访问对象的能力的接口。"},{"type":3,"line":"接口摘要"},{"type":4,"line":"**ArrayAccess** {"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"abstract public [offsetExists](arrayaccess.offsetexists.html) ( [mixed](language.pseudo-types.html#language.types.mixed) `$offset` ) : boolean"},{"type":4,"line":"abstract public [offsetGet](arrayaccess.offsetget.html) ( [mixed](language.pseudo-types.html#language.types.mixed) `$offset` ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"abstract public [offsetSet](arrayaccess.offsetset.html) ( [mixed](language.pseudo-types.html#language.types.mixed) `$offset` , [mixed](language.pseudo-types.html#language.types.mixed) `$value` ) : void"},{"type":4,"line":"abstract public [offsetUnset](arrayaccess.offsetunset.html) ( [mixed](language.pseudo-types.html#language.types.mixed) `$offset` ) : void"},{"type":4,"line":"}"},{"type":4,"line":"**Example #1 Basic usage**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class obj implements arrayaccess {  "},{"type":5,"line":"    private $container = array();  "},{"type":5,"line":"    public function __construct() {  "},{"type":5,"line":"        $this->container = array(  "},{"type":5,"line":"            \"one\"   => 1,  "},{"type":5,"line":"            \"two\"   => 2,  "},{"type":5,"line":"            \"three\" => 3,  "},{"type":5,"line":"        );  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function offsetSet($offset, $value) {  "},{"type":5,"line":"        if (is_null($offset)) {  "},{"type":5,"line":"            $this->container[] = $value;  "},{"type":5,"line":"        } else {  "},{"type":5,"line":"            $this->container[$offset] = $value;  "},{"type":5,"line":"        }  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function offsetExists($offset) {  "},{"type":5,"line":"        return isset($this->container[$offset]);  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function offsetUnset($offset) {  "},{"type":5,"line":"        unset($this->container[$offset]);  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function offsetGet($offset) {  "},{"type":5,"line":"        return isset($this->container[$offset]) ? $this->container[$offset] : null;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new obj;  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(isset($obj[\"two\"]));  "},{"type":4,"line":"var_dump($obj[\"two\"]);  "},{"type":4,"line":"unset($obj[\"two\"]);  "},{"type":4,"line":"var_dump(isset($obj[\"two\"]));  "},{"type":4,"line":"$obj[\"two\"] = \"A value\";  "},{"type":4,"line":"var_dump($obj[\"two\"]);  "},{"type":4,"line":"$obj[] = 'Append 1';  "},{"type":4,"line":"$obj[] = 'Append 2';  "},{"type":4,"line":"$obj[] = 'Append 3';  "},{"type":4,"line":"print_r($obj);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"bool(true)"},{"type":4,"line":"int(2)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"string(7) \"A value\""},{"type":4,"line":"obj Object"},{"type":5,"line":"("},{"type":5,"line":"    \\[container:obj:private\\] => Array"},{"type":5,"line":"        ("},{"type":5,"line":"            \\[one\\] => 1"},{"type":5,"line":"            \\[three\\] => 3"},{"type":5,"line":"            \\[two\\] => A value"},{"type":5,"line":"            \\[0\\] => Append 1"},{"type":5,"line":"            \\[1\\] => Append 2"},{"type":5,"line":"            \\[2\\] => Append 3"},{"type":4,"line":"        )"},{"type":4,"line":")"},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [ArrayAccess::offsetExists](arrayaccess.offsetexists.html) — 检查一个偏移位置是否存在"},{"type":4,"line":"*   [ArrayAccess::offsetGet](arrayaccess.offsetget.html) — 获取一个偏移位置的值"},{"type":4,"line":"*   [ArrayAccess::offsetSet](arrayaccess.offsetset.html) — 设置一个偏移位置的值"},{"type":4,"line":"*   [ArrayAccess::offsetUnset](arrayaccess.offsetunset.html) — 复位一个偏移位置的值"},{"type":2,"line":"17.5 序列化接口"},{"type":4,"line":"(No version information available, might only be in Git)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"自定义序列化的接口。"},{"type":4,"line":"实现此接口的类将不再支持 [\\_\\_sleep()](language.oop5.magic.html#language.oop5.magic.sleep) 和 [\\_\\_wakeup()](language.oop5.magic.html#language.oop5.magic.sleep)。不论何时，只要有实例需要被序列化，serialize 方法都将被调用。它将不会调用 \\_\\_destruct() 或有其他影响，除非程序化地调用此方法。当数据被反序列化时，类将被感知并且调用合适的 unserialize() 方法而不是调用 \\_\\_construct()。如果需要执行标准的构造器，你应该在这个方法中进行处理。"},{"type":3,"line":"接口摘要"},{"type":4,"line":"**Serializable** {"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"abstract public [serialize](serializable.serialize.html) ( void ) : string"},{"type":4,"line":"abstract public [unserialize](serializable.unserialize.html) ( string `$serialized` ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"}"},{"type":4,"line":"**Example #1 Basic usage**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class obj implements Serializable {  "},{"type":5,"line":"    private $data;  "},{"type":5,"line":"    public function __construct() {  "},{"type":5,"line":"        $this->data = \"My private data\";  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function serialize() {  "},{"type":5,"line":"        return serialize($this->data);  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function unserialize($data) {  "},{"type":5,"line":"        $this->data = unserialize($data);  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function getData() {  "},{"type":5,"line":"        return $this->data;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new obj;  "},{"type":4,"line":"$ser = serialize($obj);  "},{"type":4,"line":"  "},{"type":4,"line":"$newobj = unserialize($ser);  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($newobj->getData());  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"string(15) \"My private data\""},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [Serializable::serialize](serializable.serialize.html) — 对象的字符串表示"},{"type":4,"line":"*   [Serializable::unserialize](serializable.unserialize.html) — 构造对象"},{"type":2,"line":"17.6 Closure 类"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"用于代表 [匿名函数](functions.anonymous.html) 的类."},{"type":4,"line":"匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象。在过去，这个类被认为是一个实现细节，但现在可以依赖它做一些事情。自 PHP 5.4 起，这个类带有一些方法，允许在匿名函数创建后对其进行更多的控制。"},{"type":4,"line":"除了此处列出的方法，还有一个 _\\_\\_invoke_ 方法。这是为了与其他实现了 [\\_\\_invoke()魔术方法](language.oop5.magic.html#language.oop5.magic.invoke) 的对象保持一致性，但调用匿名函数的过程与它无关。"},{"type":3,"line":"类摘要"},{"type":4,"line":"**Closure** {"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"[\\_\\_construct](closure.construct.html) ( void )"},{"type":4,"line":"public static [bind](closure.bind.html) ( [Closure](class.closure.html) `$closure` , object `$newthis` \\[, [mixed](language.pseudo-types.html#language.types.mixed) `$newscope` \\= 'static' \\] ) : [Closure](class.closure.html)"},{"type":4,"line":"public [bindTo](closure.bindto.html) ( object `$newthis` \\[, [mixed](language.pseudo-types.html#language.types.mixed) `$newscope` \\= 'static' \\] ) : [Closure](class.closure.html)"},{"type":4,"line":"}"},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [Closure::\\_\\_construct](closure.construct.html) — 用于禁止实例化的构造函数"},{"type":4,"line":"*   [Closure::bind](closure.bind.html) — 复制一个闭包，绑定指定的$this对象和类作用域。"},{"type":4,"line":"*   [Closure::bindTo](closure.bindto.html) — 复制当前闭包对象，绑定指定的$this对象和类作用域。"},{"type":2,"line":"17.7 生成器类"},{"type":4,"line":"(No version information available, might only be in Git)"},{"type":4,"line":"简介"},{"type":4,"line":"--"},{"type":4,"line":"**Generator** 对象是从 [generators](language.generators.html)返回的."},{"type":4,"line":"**Caution**"},{"type":4,"line":"**Generator** 对象不能通过 [new](language.oop5.basic.html#language.oop5.basic.new) 实例化."},{"type":3,"line":"类摘要"},{"type":4,"line":"**Generator** implements **Iterator** {"},{"type":4,"line":"/\\* 方法 \\*/"},{"type":4,"line":"public [current](generator.current.html) ( void ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"public [key](generator.key.html) ( void ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"public [next](generator.next.html) ( void ) : void"},{"type":4,"line":"public [rewind](generator.rewind.html) ( void ) : void"},{"type":4,"line":"public [send](generator.send.html) ( [mixed](language.pseudo-types.html#language.types.mixed) `$value` ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"public [throw](generator.throw.html) ( [Exception](class.exception.html) `$exception` ) : void"},{"type":4,"line":"public [valid](generator.valid.html) ( void ) : bool"},{"type":4,"line":"public [\\_\\_wakeup](generator.wakeup.html) ( void ) : void"},{"type":4,"line":"}"},{"type":3,"line":"Table of Contents"},{"type":4,"line":"*   [Generator::current](generator.current.html) — 返回当前产生的值"},{"type":4,"line":"*   [Generator::key](generator.key.html) — 返回当前产生的键"},{"type":4,"line":"*   [Generator::next](generator.next.html) — 生成器继续执行"},{"type":4,"line":"*   [Generator::rewind](generator.rewind.html) — 重置迭代器"},{"type":4,"line":"*   [Generator::send](generator.send.html) — 向生成器中传入一个值"},{"type":4,"line":"*   [Generator::throw](generator.throw.html) — 向生成器中抛入一个异常"},{"type":4,"line":"*   [Generator::valid](generator.valid.html) — 检查迭代器是否被关闭"},{"type":4,"line":"*   [Generator::\\_\\_wakeup](generator.wakeup.html) — 序列化回调"},{"type":1,"line":"18. 上下文（Context）选项和参数"},{"type":2,"line":"18.1 套接字上下文选项"},{"type":4,"line":"套接字上下文选项 — 套接字上下文选项列表"},{"type":4,"line":"### 说明"},{"type":4,"line":"套接字上下文选项可用于所有工作在套接字上的封装协议，像 _tcp_, _http_ 和 _ftp_."},{"type":4,"line":"### 可选项"},{"type":4,"line":"`bindto`"},{"type":4,"line":"用户PHP访问网络的指定的IP地址（IPv4或IPv6其中的一个）和/或 端口号，这个语法是 _ip:port_. Setting the IP or the port to _0_ will let the system choose the IP and/or port."},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> As FTP creates two socket connections during normal operation, the port number cannot be specified using this option."},{"type":4,"line":"`backlog`"},{"type":4,"line":"Used to limit the number of outstanding connections in the socket's listen queue."},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> This is only applicable to [stream\\_socket\\_server()](function.stream-socket-server.html)."},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.1.0"},{"type":4,"line":"Added _bindto_."},{"type":4,"line":"5.3.3"},{"type":4,"line":"Added _backlog_."},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 Basic `bindto` usage example**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// connect to the internet using the '192.168.0.100' IP  "},{"type":4,"line":"$opts = array(  "},{"type":4,"line":"    'socket' => array(  "},{"type":4,"line":"        'bindto' => '192.168.0.100:0',  "},{"type":4,"line":"    ),  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// connect to the internet using the '192.168.0.100' IP and port '7000'  "},{"type":4,"line":"$opts = array(  "},{"type":4,"line":"    'socket' => array(  "},{"type":4,"line":"        'bindto' => '192.168.0.100:7000',  "},{"type":4,"line":"    ),  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// connect to the internet using port '7000'  "},{"type":4,"line":"$opts = array(  "},{"type":4,"line":"    'socket' => array(  "},{"type":4,"line":"        'bindto' => '0:7000',  "},{"type":4,"line":"    ),  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// create the context...  "},{"type":4,"line":"$context = stream_context_create($opts);  "},{"type":4,"line":"  "},{"type":4,"line":"// ...and use it to fetch the data  "},{"type":4,"line":"echo file_get_contents('http://www.example.com', false, $context);  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":2,"line":"18.2 HTTP context 选项"},{"type":4,"line":"HTTP context 选项 — HTTP context 的选项列表"},{"type":4,"line":"### 说明"},{"type":4,"line":"提供给 _http://_ 和 _https://_ 传输协议的 context 选项。 transports."},{"type":4,"line":"### 可选项"},{"type":4,"line":"`method` [string](language.types.string.html)"},{"type":4,"line":"远程服务器支持的 **`GET`**，**`POST`** 或其它 HTTP 方法。"},{"type":4,"line":"默认值是 **`GET`**。"},{"type":4,"line":"`header` [string](language.types.string.html)"},{"type":4,"line":"请求期间发送的额外 header 。在此选项的值将覆盖其他值 （诸如 _User-agent:_， _Host:_ 和 _Authentication:_）。"},{"type":4,"line":"`user_agent` [string](language.types.string.html)"},{"type":4,"line":"要发送的 header _User-Agent:_ 的值。如果在上面的 _header_ context 选项中没有指定 user-agent，此值将被使用。"},{"type":4,"line":"默认使用 php.ini 中设置的 [user\\_agent](filesystem.configuration.html#ini.user-agent)。"},{"type":4,"line":"`content` [string](language.types.string.html)"},{"type":4,"line":"在 header 后面要发送的额外数据。通常使用POST或PUT请求。"},{"type":4,"line":"`proxy` [string](language.types.string.html)"},{"type":4,"line":"URI 指定的代理服务器的地址。(e.g. _tcp://proxy.example.com:5100_)."},{"type":4,"line":"`request_fulluri` [boolean](language.types.boolean.html)"},{"type":4,"line":"当设置为 **`TRUE`** 时，在构建请求时将使用整个 URI 。(i.e. _GET http://www.example.com/path/to/file.html HTTP/1.0_)。 虽然这是一个非标准的请求格式，但某些代理服务器需要它。"},{"type":4,"line":"默认值是 **`FALSE`**."},{"type":4,"line":"`follow_location` [integer](language.types.integer.html)"},{"type":4,"line":"跟随 _Location_ header 的重定向。设置为 _0_ 以禁用。"},{"type":4,"line":"默认值是 _1_。"},{"type":4,"line":"`max_redirects` [integer](language.types.integer.html)"},{"type":4,"line":"跟随重定向的最大次数。值为 _1_ 或更少则意味不跟随重定向。"},{"type":4,"line":"默认值是 _20_。"},{"type":4,"line":"`protocol_version` [float](language.types.float.html)"},{"type":4,"line":"HTTP 协议版本。"},{"type":4,"line":"默认值是 _1.0_。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> PHP 5.3.0 以前的版本没有实现分块传输解码。 如果此值设置为 _1.1_ ，与 _1.1_ 的兼容将是你的责任。"},{"type":4,"line":"`timeout` [float](language.types.float.html)"},{"type":4,"line":"读取超时时间，单位为秒（s），用 [float](language.types.float.html) 指定(e.g. _10.5_)。"},{"type":4,"line":"默认使用 php.ini 中设置的 [default\\_socket\\_timeout](filesystem.configuration.html#ini.default-socket-timeout)。"},{"type":4,"line":"`ignore_errors` [boolean](language.types.boolean.html)"},{"type":4,"line":"即使是故障状态码依然获取内容。"},{"type":4,"line":"默认值为 **`FALSE`**."},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.3.4"},{"type":4,"line":"添加 `follow_location`。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"当 `protocol_version` 设置为 _1.1_ 时支持分块传输解码。"},{"type":4,"line":"5.2.10"},{"type":4,"line":"添加 `ignore_errors`。"},{"type":4,"line":"5.2.10"},{"type":4,"line":"`header` 现在可以是一个数字索引的 [array](language.types.array.html)。"},{"type":4,"line":"5.2.1"},{"type":4,"line":"添加 `timeout`。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"Added HTTPS proxying through HTTP proxies. 添加经由 HTTP 代理的 HTTPS 代理。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"添加 `max_redirects`。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"添加 `protocol_version`。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 获取一个页面并发送 POST 数据**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$postdata = http_build_query(  "},{"type":4,"line":"    array(  "},{"type":4,"line":"        'var1' => 'some content',  "},{"type":4,"line":"        'var2' => 'doh'  "},{"type":4,"line":"    )  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"$opts = array('http' =>  "},{"type":4,"line":"    array(  "},{"type":4,"line":"        'method'  => 'POST',  "},{"type":4,"line":"        'header'  => 'Content-type: application/x-www-form-urlencoded',  "},{"type":4,"line":"        'content' => $postdata  "},{"type":4,"line":"    )  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"$context = stream_context_create($opts);  "},{"type":4,"line":"  "},{"type":4,"line":"$result = file_get_contents('http://example.com/submit.php', false, $context);  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 忽略重定向并获取 header 和内容**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$url = \"http://www.example.org/header.php\";  "},{"type":4,"line":"  "},{"type":4,"line":"$opts = array('http' =>  "},{"type":4,"line":"    array(  "},{"type":4,"line":"        'method' => 'GET',  "},{"type":4,"line":"        'max_redirects' => '0',  "},{"type":4,"line":"        'ignore_errors' => '1'  "},{"type":4,"line":"    )  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"$context = stream_context_create($opts);  "},{"type":4,"line":"$stream = fopen($url, 'r', false, $context);  "},{"type":4,"line":"  "},{"type":4,"line":"// header information as well as meta data  "},{"type":4,"line":"// about the stream  "},{"type":4,"line":"var_dump(stream_get_meta_data($stream));  "},{"type":4,"line":"  "},{"type":4,"line":"// actual data at $url  "},{"type":4,"line":"var_dump(stream_get_contents($stream));  "},{"type":4,"line":"fclose($stream);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**: **Underlying socket stream context options**  "},{"type":4,"line":"> Additional context options may be supported by the [underlying transport](transports.inet.html) For _http://_ streams, refer to context options for the _tcp://_ transport. For _https://_ streams, refer to context options for the _ssl://_ transport."},{"type":4,"line":"> **Note**: **HTTP status line**  "},{"type":4,"line":"> When this stream wrapper follows a redirect, the _wrapper\\_data_ returned by [stream\\_get\\_meta\\_data()](function.stream-get-meta-data.html) might not necessarily contain the HTTP status line that actually applies to the content data at index _0_."},{"type":4,"line":"> "},{"type":4,"line":"> array ("},{"type":4,"line":">   'wrapper\\_data' =>"},{"type":4,"line":">   array ("},{"type":4,"line":">     0 => 'HTTP/1.0 301 Moved Permantenly',"},{"type":4,"line":">     1 => 'Cache-Control: no-cache',"},{"type":4,"line":">     2 => 'Connection: close',"},{"type":4,"line":">     3 => 'Location: http://example.com/foo.jpg',"},{"type":4,"line":">     4 => 'HTTP/1.1 200 OK',"},{"type":4,"line":">     ..."},{"type":4,"line":"> "},{"type":4,"line":"> The first request returned a _301_ (permanent redirect), so the stream wrapper automatically followed the redirect to get a _200_ response (index = _4_)."},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [http://](wrappers.http.html)"},{"type":4,"line":"*   [套接字上下文选项](context.socket.html)"},{"type":4,"line":"*   [SSL 上下文选项](context.ssl.html)"},{"type":2,"line":"18.3 FTP context options"},{"type":4,"line":"FTP context options — FTP context option listing"},{"type":4,"line":"### 说明"},{"type":4,"line":"Context options for _ftp://_ and _ftps://_ transports."},{"type":4,"line":"### 可选项"},{"type":4,"line":"`overwrite` [boolean](language.types.boolean.html)"},{"type":4,"line":"Allow overwriting of already existing files on remote server. Applies to write mode (uploading) only."},{"type":4,"line":"Defaults to **`FALSE`**."},{"type":4,"line":"`resume_pos` [integer](language.types.integer.html)"},{"type":4,"line":"File offset at which to begin transfer. Applies to read mode (downloading) only."},{"type":4,"line":"Defaults to _0_ (Beginning of File)."},{"type":4,"line":"`proxy` [string](language.types.string.html)"},{"type":4,"line":"Proxy FTP request via http proxy server. Applies to file read operations only. Ex: _tcp://squid.example.com:8000_."},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.1.0"},{"type":4,"line":"Added `proxy`."},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**: **Underlying socket stream context options**  "},{"type":4,"line":"> Additional context options may be supported by the [underlying transport](transports.inet.html) For _ftp://_ streams, refer to context options for the _tcp://_ transport. For _ftps://_ streams, refer to context options for the _ssl://_ transport."},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [ftp://](wrappers.ftp.html)"},{"type":4,"line":"*   [套接字上下文选项](context.socket.html)"},{"type":4,"line":"*   [SSL 上下文选项](context.ssl.html)"},{"type":2,"line":"18.4 SSL 上下文选项"},{"type":4,"line":"SSL 上下文选项 — SSL 上下文选项清单"},{"type":4,"line":"### 说明"},{"type":4,"line":"_ssl://_ 和 _tls://_ 传输协议上下文选项清单。"},{"type":4,"line":"### 可选项"},{"type":4,"line":"`peer_name` [string](language.types.string.html)"},{"type":4,"line":"要连接的服务器名称。如果未设置，那么服务器名称将根据打开 SSL 流的主机名称猜测得出。"},{"type":4,"line":"`verify_peer` [boolean](language.types.boolean.html)"},{"type":4,"line":"是否需要验证 SSL 证书。"},{"type":4,"line":"默认值为 **`TRUE`**。"},{"type":4,"line":"`verify_peer_name` [boolean](language.types.boolean.html)"},{"type":4,"line":"是否需要验证 peer name。"},{"type":4,"line":"默认值为 **`TRUE`**."},{"type":4,"line":"`allow_self_signed` [boolean](language.types.boolean.html)"},{"type":4,"line":"是否允许自签名证书。需要配合 [`verify_peer`](context.ssl.html#context.ssl.verify-peer) 参数使用（注：当 verify\\_peer 参数为 true 时才会根据 allow\\_self\\_signed 参数值来决定是否允许自签名证书）。"},{"type":4,"line":"默认值为 **`FALSE`**"},{"type":4,"line":"`cafile` [string](language.types.string.html)"},{"type":4,"line":"当设置 _verify\\_peer_ 为 true 时， 用来验证远端证书所用到的 CA 证书。 本选项值为 CA 证书在本地文件系统的全路径及文件名。"},{"type":4,"line":"`capath` [string](language.types.string.html)"},{"type":4,"line":"如果未设置 _cafile_，或者 _cafile_ 所指的文件不存在时， 会在 _capath_ 所指定的目录搜索适用的证书。 该目录必须是已经经过哈希处理的证书目录。 （注：所谓 hashed certificate 目录是指使用类似 c\\_rehash 命令将目录中的 .pem 和 .crt 文件扫描并提取哈希码，然后根据此哈希码创建文件链接，以便于快速查找证书）"},{"type":4,"line":"`local_cert` [string](language.types.string.html)"},{"type":4,"line":"本地证书路径。 必须是 PEM 格式，并且包含本地的证书及私钥。 也可以包含证书颁发者证书链。 也可以通过 _local\\_pk_ 指定包含私钥的独立文件。"},{"type":4,"line":"`local_pk` [string](language.types.string.html)"},{"type":4,"line":"如果使用独立的文件来存储证书（_local\\_cert_）和私钥， 那么使用此选项来指明私钥文件的路径。"},{"type":4,"line":"`passphrase` [string](language.types.string.html)"},{"type":4,"line":"_local\\_cert_ 文件的密码。"},{"type":4,"line":"`CN_match` [string](language.types.string.html)"},{"type":4,"line":"期望远端证书的 CN 名称。 PHP 会进行有限的通配符匹配， 如果服务器给出的 CN 名称和本地访问的名称不匹配，则视为连接失败。"},{"type":4,"line":"> **Note**: 在PHP 5.6.0中，这个选项已废弃，替换为 `peer_name`。"},{"type":4,"line":"`verify_depth` [integer](language.types.integer.html)"},{"type":4,"line":"如果证书链条层次太深，超过了本选项的设定值，则终止验证。"},{"type":4,"line":"默认情况下不限制证书链条层次深度。"},{"type":4,"line":"`ciphers` [string](language.types.string.html)"},{"type":4,"line":"设置可用的密码列表。 可用的值参见： [» ciphers(1)](https://www.openssl.org/docs/manmaster/man1/ciphers.html#CIPHER-LIST-FORMAT)。"},{"type":4,"line":"默认值为 _DEFAULT_."},{"type":4,"line":"`capture_peer_cert` [boolean](language.types.boolean.html)"},{"type":4,"line":"如果设置为 **`TRUE`** 将会在上下文中创建 _peer\\_certificate_ 选项， 该选项中包含远端证书。"},{"type":4,"line":"`capture_peer_cert_chain` [boolean](language.types.boolean.html)"},{"type":4,"line":"如果设置为 **`TRUE`** 将会在上下文中创建 _peer\\_certificate\\_chain_ 选项， 该选项中包含远端证书链条。"},{"type":4,"line":"`SNI_enabled` [boolean](language.types.boolean.html)"},{"type":4,"line":"设置为 **`TRUE`** 将启用服务器名称指示（server name indication）。 启用 SNI 将允许同一 IP 地址使用多个证书。"},{"type":4,"line":"`SNI_server_name` [string](language.types.string.html)"},{"type":4,"line":"如果设置此参数，那么其设置值将被视为 SNI 服务器名称。 如果未设置，那么服务器名称将基于打开 SSL 流的主机名称猜测得出。"},{"type":4,"line":"> **Note**: 在PHP 5.6.0中，这个选项已废弃，替换为 `peer_name`。"},{"type":4,"line":"`disable_compression` [boolean](language.types.boolean.html)"},{"type":4,"line":"如果设置，则禁用 TLS 压缩，有助于减轻恶意攻击。"},{"type":4,"line":"`peer_fingerprint` [string](language.types.string.html) | [array](language.types.array.html)"},{"type":4,"line":"当远程服务器证书的摘要和指定的散列值不相同的时候， 终止操作。"},{"type":4,"line":"当使用 [string](language.types.string.html) 时， 会根据字符串的长度来检测所使用的散列算法：“md5”（32 字节）还是“sha1”（40 字节）。"},{"type":4,"line":"当使用 [array](language.types.array.html) 时， 数组的键表示散列算法名称，其对应的值是预期的摘要值。"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.6.0"},{"type":4,"line":"新加 `peer_fingerprint` 参数。"},{"type":4,"line":"5.4.13"},{"type":4,"line":"新加 `disable_compression`。 需要 OpenSSL >= 1.0.0."},{"type":4,"line":"5.3.2"},{"type":4,"line":"新加 `SNI_enabled` 和 `SNI_server_name`。"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**: 因为 _ssl://_ 是 [_https://_](wrappers.http.html) 和 [_ftps://_](wrappers.ftp.html) 的底层传输协议， 所以，_ssl://_ 的上下文选项也同样适用于 _https://_ 和 _ftps://_ 上下文。"},{"type":4,"line":"> **Note**: PHP 必须联合 OpenSSL 0.9.8j 或以上版本编译才可以支持 SNI， 同时也支持使用 **`OPENSSL_TLSEXT_SERVER_NAME`** 来探测 SNI 服务器名称。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [套接字上下文选项](context.socket.html)"},{"type":2,"line":"18.5 CURL context options"},{"type":4,"line":"CURL context options — CURL 上下文选项列表"},{"type":4,"line":"### 说明"},{"type":4,"line":"CURL 上下文选项在 [CURL](intro.curl.html) 扩展被编译（通过 **\\--with-curlwrappers** configure选项）时可用"},{"type":4,"line":"### 可选项"},{"type":4,"line":"`method` [string](language.types.string.html)"},{"type":4,"line":"**`GET`**，**`POST`**，或者其他远程服务器支持的 HTTP 方法。"},{"type":4,"line":"默认为 **`GET`**."},{"type":4,"line":"`header` [string](language.types.string.html)"},{"type":4,"line":"额外的请求标头。这个值会覆盖通过其他选项设定的值（如： _User-agent:_，_Host:_， ，_Authentication:_）。"},{"type":4,"line":"`user_agent` [string](language.types.string.html)"},{"type":4,"line":"设置请求时 User-Agent 标头的值。"},{"type":4,"line":"默认为 php.ini 中的 [user\\_agent](filesystem.configuration.html#ini.user-agent) 设定。"},{"type":4,"line":"`content` [string](language.types.string.html)"},{"type":4,"line":"在头部之后发送的额外数据。这个选项在 **`GET`** 和 **`HEAD`** 请求中不使用。"},{"type":4,"line":"`proxy` [string](language.types.string.html)"},{"type":4,"line":"URI，用于指定代理服务器的地址（例如 _tcp://proxy.example.com:5100_）。"},{"type":4,"line":"`max_redirects` [integer](language.types.integer.html)"},{"type":4,"line":"最大重定向次数。_1_ 或者更小则代表不会跟随重定向。"},{"type":4,"line":"默认为 _20_."},{"type":4,"line":"`curl_verify_ssl_host` [boolean](language.types.boolean.html)"},{"type":4,"line":"校验服务器。"},{"type":4,"line":"默认为 **`FALSE`**"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 这个选项在 HTTP 和 FTP 协议中均可使用。"},{"type":4,"line":"`curl_verify_ssl_peer` [boolean](language.types.boolean.html)"},{"type":4,"line":"要求对使用的SSL证书进行校验。"},{"type":4,"line":"默认为 **`FALSE`**"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 这个选项在 HTTP 和 FTP 协议中均可使用。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 获取一个页面，并以POST发送数据**"},{"type":4,"line":" ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$postdata = http_build_query(  "},{"type":4,"line":"    array(  "},{"type":4,"line":"        'var1' => 'some content',  "},{"type":4,"line":"        'var2' => 'doh'  "},{"type":4,"line":"    )  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"$opts = array('http' =>  "},{"type":4,"line":"    array(  "},{"type":4,"line":"        'method'  => 'POST',  "},{"type":4,"line":"        'header'  => 'Content-type: application/x-www-form-urlencoded',  "},{"type":4,"line":"        'content' => $postdata  "},{"type":4,"line":"    )  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"$context = stream_context_create($opts);  "},{"type":4,"line":"  "},{"type":4,"line":"$result = file_get_contents('http://example.com/submit.php', false, $context);  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [套接字上下文选项](context.socket.html)"},{"type":2,"line":"18.6 Phar 上下文（context）选项"},{"type":4,"line":"Phar 上下文（context）选项 — Phar 上下文（context）选项列表"},{"type":4,"line":"### 说明"},{"type":4,"line":"_phar://_ 封装（wrapper）的上下文（context）选项。"},{"type":4,"line":"### 可选项"},{"type":4,"line":"`compress` [int](language.types.integer.html)"},{"type":4,"line":"[Phar compression constants](phar.constants.html#phar.constants.compression) 中的一个。"},{"type":4,"line":"`metadata` [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"Phar 元数据（metadata）。查看 [Phar::setMetadata()](phardata.setmetadata.html)。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [phar://](wrappers.phar.html)"},{"type":4,"line":"*   [Phar stream wrapper](phar.using.stream.html)"},{"type":2,"line":"18.7 MongoDB context options"},{"type":4,"line":"MongoDB context options — MongoDB context option listing"},{"type":4,"line":"### 说明"},{"type":4,"line":"Context options for _mongodb://_ transports."},{"type":4,"line":"### 可选项"},{"type":4,"line":"`log_cmd_insert` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called when inserting a document, see [log\\_cmd\\_insert()](function.log-cmd-insert.html)."},{"type":4,"line":"`log_cmd_delete` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called when deleting a document, see [log\\_cmd\\_delete()](function.log-cmd-delete.html)."},{"type":4,"line":"`log_cmd_update` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called when updating a document, see [log\\_cmd\\_update()](function.log-cmd-update.html)."},{"type":4,"line":"`log_write_batch` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called when executing a Write Batch, see [log\\_write\\_batch()](function.log-write-batch.html)."},{"type":4,"line":"`log_reply` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called when reading a reply from MongoDB, see [log\\_reply()](function.log-reply.html)."},{"type":4,"line":"`log_getmore` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called when retrieving more results from a MongoDB cursor, see [log\\_getmore()](function.log-getmore.html)."},{"type":4,"line":"`log_killcursor` [callable](language.types.callable.html)"},{"type":4,"line":"A callback function called executing a killcursor opcode, see [log\\_killcursor()](function.log-killcursor.html)."},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"pecl/mongo 1.5.0"},{"type":4,"line":"Added Write API Context options"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [套接字上下文选项](context.socket.html)"},{"type":4,"line":"*   [SSL 上下文选项](context.ssl.html)"},{"type":2,"line":"18.8 Context 参数"},{"type":4,"line":"Context 参数 — Context 参数列表"},{"type":4,"line":"### 说明"},{"type":4,"line":"这些参数（_parameters_）可以设置为由函数 [stream\\_context\\_set\\_params()](function.stream-context-set-params.html) 返回的 _context_。"},{"type":4,"line":"### 参数"},{"type":4,"line":"`notification` [callable](language.types.callable.html)"},{"type":4,"line":"当一个流（stream）上发生事件时，[callable](language.types.callable.html) 将被调用。"},{"type":4,"line":"查看 [stream\\_notification\\_callback](function.stream-notification-callback.html) 以获得更多信息。"},{"type":1,"line":"19. 支持的协议和封装协议"},{"type":2,"line":"19.1 file://"},{"type":4,"line":"file:// — 访问本地文件系统"},{"type":4,"line":"### 说明"},{"type":4,"line":"_文件系统_ 是 PHP 使用的默认封装协议，展现了本地文件系统。 当指定了一个相对路径（不以/、\\\\、\\\\\\\\或 Windows 盘符开头的路径）提供的路径将基于当前的工作目录。 在很多情况下是脚本所在的目录，除非被修改了。 使用 CLI 的时候，目录默认是脚本被调用时所在的目录。"},{"type":4,"line":"在某些函数里，例如 [fopen()](function.fopen.html) 和 [file\\_get\\_contents()](function.file-get-contents.html)， _include\\_path_ 会可选地搜索，也作为相对的路径。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   /path/to/file.ext"},{"type":4,"line":"*   relative/path/to/file.ext"},{"type":4,"line":"*   fileInCwd.ext"},{"type":4,"line":"*   C:/path/to/winfile.ext"},{"type":4,"line":"*   C:\\\\path\\\\to\\\\winfile.ext"},{"type":4,"line":"*   \\\\\\\\smbserver\\\\share\\\\path\\\\to\\\\winfile.ext"},{"type":4,"line":"*   file:///path/to/file.ext"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议概要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen) 影响"},{"type":4,"line":"No"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes"},{"type":4,"line":"允许添加"},{"type":4,"line":"Yes"},{"type":4,"line":"允许同时读和写"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.0.0"},{"type":4,"line":"添加了 _file://_."},{"type":2,"line":"19.2 http://"},{"type":2,"line":"https://"},{"type":4,"line":"http:// -- https:// — 访问 HTTP(s) 网址"},{"type":4,"line":"### 说明"},{"type":4,"line":"允许通过 HTTP 1.0 的 GET方法，以只读访问文件或资源。 HTTP 请求会附带一个 _Host:_ 头，用于兼容基于域名的虚拟主机。 如果在你的 php.ini 文件中或字节流上下文（context）配置了 [user\\_agent](filesystem.configuration.html#ini.user-agent) 字符串，它也会被包含在请求之中。"},{"type":4,"line":"数据流允许读取资源的 _body_，而 headers 则储存在了 [$http\\_response\\_header](reserved.variables.httpresponseheader.html) 变量里。"},{"type":4,"line":"如果需要知道文档资源来自哪个 URL（经过所有重定向的处理后）， 需要处理数据流返回的系列响应报头（response headers）。"},{"type":4,"line":"The [from](filesystem.configuration.html#ini.from) directive will be used for the _From:_ header if set and not overwritten by the [上下文（Context）选项和参数](context.html)."},{"type":4,"line":"### 用法"},{"type":4,"line":"*   http://example.com"},{"type":4,"line":"*   http://example.com/file.php?var1=val1&var2=val2"},{"type":4,"line":"*   http://user:password@example.com"},{"type":4,"line":"*   https://example.com"},{"type":4,"line":"*   https://example.com/file.php?var1=val1&var2=val2"},{"type":4,"line":"*   https://user:password@example.com"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议概要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen) 限制"},{"type":4,"line":"Yes"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"No"},{"type":4,"line":"允许添加"},{"type":4,"line":"No"},{"type":4,"line":"允许同时读和写"},{"type":4,"line":"N/A"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.3.7"},{"type":4,"line":"检测 IIS 服务器避免 _\"SSL: Fatal Protocol Error\"_ 错误。"},{"type":4,"line":"4.3.0"},{"type":4,"line":"添加 _https://_。"},{"type":4,"line":"4.0.5"},{"type":4,"line":"增加了对重定向的支持。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 检测重定向后最终的 URL**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$url = 'http://www.example.com/redirecting_page.php';  "},{"type":4,"line":"  "},{"type":4,"line":"$fp = fopen($url, 'r');  "},{"type":4,"line":"  "},{"type":4,"line":"$meta_data = stream_get_meta_data($fp);  "},{"type":4,"line":"foreach ($meta_data['wrapper_data'] as $response) {  "},{"type":5,"line":"  "},{"type":5,"line":"    /* 我们是否被重定向了？ */  "},{"type":4,"line":"    if (strtolower(substr($response, 0, 10)) == 'location: ') {  "},{"type":5,"line":"  "},{"type":5,"line":"        /* 更新我们被重定向后的 $url */  "},{"type":5,"line":"        $url = substr($response, 10);  "},{"type":4,"line":"    }  "},{"type":4,"line":"  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**: [openssl](book.openssl.html) 扩展启用后才能够支持 HTTPS 协议。"},{"type":4,"line":"HTTP 连接是只读的；还不支持对一个 HTTP 资源进行写数据或者复制文件。"},{"type":4,"line":"比如发送 _POST_ 和 _PUT_ 请求， 可以在 [HTTP Contexts](context.http.html) 的支持下实现。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [HTTP context 选项](context.http.html)"},{"type":4,"line":"*   [$http\\_response\\_header](reserved.variables.httpresponseheader.html)"},{"type":4,"line":"*   [stream\\_get\\_meta\\_data()](function.stream-get-meta-data.html) - 从封装协议文件指针中取得报头／元数据"},{"type":2,"line":"19.3 ftp://"},{"type":2,"line":"ftps://"},{"type":4,"line":"ftp:// -- ftps:// — 访问 FTP(s) URLs"},{"type":4,"line":"### 说明"},{"type":4,"line":"允许通过 FTP 读取存在的文件，以及创建新文件。 如果服务器不支持被动（passive）模式的 FTP，连接会失败。"},{"type":4,"line":"打开文件后你既可以读也可以写，但是不能同时进行。 当远程文件已经存在于 ftp 服务器上，如果尝试打开并写入文件的时候， 未指定上下文（context）选项 _overwrite_，连接会失败。 如果要通过 FTP 覆盖存在的文件， 指定上下文（context）的 _overwrite_ 选项来打开、写入。 另外可使用 [FTP 扩展](ref.ftp.html)来代替。"},{"type":4,"line":"如果你设置了 php.ini 中的 [from](filesystem.configuration.html#ini.from) 指令， 这个值会作为匿名（anonymous）ftp 的密码。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   ftp://example.com/pub/file.txt"},{"type":4,"line":"*   ftp://user:password@example.com/pub/file.txt"},{"type":4,"line":"*   ftps://example.com/pub/file.txt"},{"type":4,"line":"*   ftps://user:password@example.com/pub/file.txt"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议概要**"},{"type":4,"line":"属性"},{"type":4,"line":"PHP 4"},{"type":4,"line":"PHP 5"},{"type":4,"line":"受 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen) 影响"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes (仅支持新文件)"},{"type":4,"line":"Yes (新文件/启用 `overwrite` 后已存在的文件)"},{"type":4,"line":"允许添加"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"允许同时读和写"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"自 5.0.0 起：仅仅 [filesize()](function.filesize.html)、 [filetype()](function.filetype.html)、 [file\\_exists()](function.file-exists.html)、 [is\\_file()](function.is-file.html) 和 [is\\_dir()](function.is-dir.html)。 自 PHP 5.1.0 起： [filemtime()](function.filemtime.html)。"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"4.3.0"},{"type":4,"line":"增加 _ftps://_."},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> FTPS 仅在 [openssl](book.openssl.html) 扩展开启时有效。"},{"type":4,"line":"> "},{"type":4,"line":"> 如果服务器不支持 SSL，这个连接会降级（falls back）到普通未加密的 ftp。"},{"type":4,"line":"> **Note**: **追加**  "},{"type":4,"line":"> 自 PHP 5.0.0 起文件可以通过 _ftp://_ URL 封装器来追加（append）。 在之前的版本，尝试通过 _ftp://_ 来追加一个文件将会导致错误。"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [FTP context options](context.ftp.html)"},{"type":2,"line":"19.4 php://"},{"type":4,"line":"php:// — 访问各个输入/输出流（I/O streams）"},{"type":4,"line":"### 说明"},{"type":4,"line":"PHP 提供了一些杂项输入/输出（IO）流，允许访问 PHP 的输入输出流、标准输入输出和错误描述符， 内存中、磁盘备份的临时文件流以及可以操作其他读取写入文件资源的过滤器。"},{"type":4,"line":"#### php://stdin, php://stdout 和 php://stderr"},{"type":4,"line":"php://stdin、php://stdout 和 php://stderr 允许直接访问 PHP 进程相应的输入或者输出流。 数据流引用了复制的文件描述符，所以如果你打开 php://stdin 并在之后关了它， 仅是关闭了复制品，真正被引用的 **`STDIN`** 并不受影响。 注意 PHP 在这方面的行为有很多 BUG 直到 PHP 5.2.1。 推荐你简单使用常量 **`STDIN`**、 **`STDOUT`** 和 **`STDERR`** 来代替手工打开这些封装器。"},{"type":4,"line":"php://stdin 是只读的， php://stdout 和 php://stderr 是只写的。"},{"type":4,"line":"#### php://input"},{"type":4,"line":"php://input 是个可以访问请求的原始数据的只读流。 POST 请求的情况下，最好使用 php://input 来代替 [$HTTP\\_RAW\\_POST\\_DATA](reserved.variables.httprawpostdata.html)，因为它不依赖于特定的 php.ini 指令。 而且，这样的情况下 [$HTTP\\_RAW\\_POST\\_DATA](reserved.variables.httprawpostdata.html) 默认没有填充， 比激活 [always\\_populate\\_raw\\_post\\_data](ini.core.html#ini.always-populate-raw-post-data) 潜在需要更少的内存。 _enctype=\"multipart/form-data\"_ 的时候 php://input 是无效的。"},{"type":4,"line":"> **Note**: 在 PHP 5.6 之前 php://input 打开的数据流只能读取一次； 数据流不支持 seek 操作。 不过，依赖于 SAPI 的实现，请求体数据被保存的时候， 它可以打开另一个 php://input 数据流并重新读取。 通常情况下，这种情况只是针对 POST 请求，而不是其他请求方式，比如 PUT 或者 PROPFIND。"},{"type":4,"line":"#### php://output"},{"type":4,"line":"php://output 是一个只写的数据流， 允许你以 [print](function.print.html) 和 [echo](function.echo.html) 一样的方式 写入到输出缓冲区。"},{"type":4,"line":"#### php://fd"},{"type":4,"line":"php://fd 允许直接访问指定的文件描述符。 例如 php://fd/3 引用了文件描述符 3。"},{"type":4,"line":"#### php://memory 和 php://temp"},{"type":4,"line":"php://memory 和 php://temp 是一个类似文件 包装器的数据流，允许读写临时数据。 两者的唯一区别是 php://memory 总是把数据储存在内存中， 而 php://temp 会在内存量达到预定义的限制后（默认是 2MB）存入临时文件中。 临时文件位置的决定和 [sys\\_get\\_temp\\_dir()](function.sys-get-temp-dir.html) 的方式一致。"},{"type":4,"line":"php://temp 的内存限制可通过添加 _/maxmemory:NN_ 来控制，_NN_ 是以字节为单位、保留在内存的最大数据量，超过则使用临时文件。"},{"type":4,"line":"#### php://filter"},{"type":4,"line":"php://filter 是一种元封装器， 设计用于数据流打开时的[筛选过滤](filters.html)应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 [readfile()](function.readfile.html)、 [file()](function.file.html) 和 [file\\_get\\_contents()](function.file-get-contents.html)， 在数据流内容读取之前没有机会应用其他过滤器。"},{"type":4,"line":"php://filter 目标使用以下的参数作为它路径的一部分。 复合过滤链能够在一个路径上指定。详细使用这些参数可以参考具体范例。"},{"type":4,"line":"**php://filter 参数**"},{"type":4,"line":"名称"},{"type":4,"line":"描述"},{"type":4,"line":"_resource=<要过滤的数据流>_"},{"type":4,"line":"这个参数是必须的。它指定了你要筛选过滤的数据流。"},{"type":4,"line":"_read=<读链的筛选列表>_"},{"type":4,"line":"该参数可选。可以设定一个或多个过滤器名称，以管道符（_|_）分隔。"},{"type":4,"line":"_write=<写链的筛选列表>_"},{"type":4,"line":"该参数可选。可以设定一个或多个过滤器名称，以管道符（_|_）分隔。"},{"type":4,"line":"_<；两个链的筛选列表>_"},{"type":4,"line":"任何没有以 _read=_ 或 _write=_ 作前缀 的筛选器列表会视情况应用于读或写链。"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议摘要（针对 _php://filter_，参考被筛选的封装器。）**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受限于 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"受限于 [allow\\_url\\_include](filesystem.configuration.html#ini.allow-url-include)"},{"type":4,"line":"仅 _php://input_、 _php://stdin_、 _php://memory_ 和 _php://temp_。"},{"type":4,"line":"允许读取"},{"type":4,"line":"仅 _php://stdin_、 _php://input_、 _php://fd_、 _php://memory_ 和 _php://temp_。"},{"type":4,"line":"允许写入"},{"type":4,"line":"仅 _php://stdout_、 _php://stderr_、 _php://output_、 _php://fd_、 _php://memory_ 和 _php://temp_。"},{"type":4,"line":"允许追加"},{"type":4,"line":"仅 _php://stdout_、 _php://stderr_、 _php://output_、 _php://fd_、 _php://memory_ 和 _php://temp_（等于写入）"},{"type":4,"line":"允许同时读写"},{"type":4,"line":"仅 _php://fd_、 _php://memory_ 和 _php://temp_。"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"仅 _php://memory_ 和 _php://temp_。"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"仅仅支持 [stream\\_select()](function.stream-select.html)"},{"type":4,"line":"_php://stdin_、 _php://stdout_、 _php://stderr_、 _php://fd_ 和 _php://temp_。"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.6.0"},{"type":4,"line":"php://input 可反复使用。"},{"type":4,"line":"5.3.6"},{"type":4,"line":"增加 php://fd。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"增加 php://memory 和 php://temp。"},{"type":4,"line":"5.0.0"},{"type":4,"line":"增加 php://filter。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 php://temp/maxmemory**"},{"type":4,"line":"这个可选选项允许设置 php://temp 开始使用临时文件前的最大内存限制。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Set the limit to 5 MB.  "},{"type":4,"line":"$fiveMBs = 5 * 1024 * 1024;  "},{"type":4,"line":"$fp = fopen(\"php://temp/maxmemory:$fiveMBs\", 'r+');  "},{"type":4,"line":"  "},{"type":4,"line":"fputs($fp, \"hello\\n\");  "},{"type":4,"line":"  "},{"type":4,"line":"// Read what we have written.  "},{"type":4,"line":"rewind($fp);  "},{"type":4,"line":"echo stream_get_contents($fp);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 php://filter/resource=<待过滤的数据流>**"},{"type":4,"line":"这个参数必须位于 php://filter 的末尾，并且指向需要过滤筛选的数据流。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* 这简单等同于：  "},{"type":4,"line":"  readfile(\"http://www.example.com\");  "},{"type":4,"line":"  实际上没有指定过滤器 */  "},{"type":4,"line":"  "},{"type":4,"line":"readfile(\"php://filter/resource=http://www.example.com\");  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #3 php://filter/read=<读链需要应用的过滤器列表>**"},{"type":4,"line":"这个参数采用一个或以管道符 _|_ 分隔的多个过滤器名称。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* 这会以大写字母输出 www.example.com 的全部内容 */  "},{"type":4,"line":"readfile(\"php://filter/read=string.toupper/resource=http://www.example.com\");  "},{"type":4,"line":"  "},{"type":4,"line":"/* 这会和以上所做的一样，但还会用 ROT13 加密。 */  "},{"type":4,"line":"readfile(\"php://filter/read=string.toupper|string.rot13/resource=http://www.example.com\");  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #4 php://filter/write=<写链需要应用的过滤器列表>**"},{"type":4,"line":"这个参数采用一个或以管道符 _|_ 分隔的多个过滤器名称。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* 这会通过 rot13 过滤器筛选出字符 \"Hello World\"  "},{"type":4,"line":"  然后写入当前目录下的 example.txt */  "},{"type":4,"line":"file_put_contents(\"php://filter/write=string.rot13/resource=example.txt\",\"Hello World\");  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #5 php://memory 和 php://temp 是一次性的**"},{"type":4,"line":"php://memory 和 php://temp 是一次性的，比如：stream 流关闭后，就无法再次得到以前的内容了。"},{"type":4,"line":"`file_put_contents('php://memory', 'PHP');  "},{"type":4,"line":"echo file_get_contents('php://memory'); // 啥也没有`"},{"type":2,"line":"19.5 zlib://"},{"type":2,"line":"bzip2://"},{"type":2,"line":"zip://"},{"type":4,"line":"zlib:// -- bzip2:// -- zip:// — 压缩流"},{"type":4,"line":"### 说明"},{"type":4,"line":"compress.zlib:// and compress.bzip2://"},{"type":4,"line":"zlib: 的功能类似 [gzopen()](function.gzopen.html)，但是 其数据流还能被 [fread()](function.fread.html) 和其他文件系统函数使用。 自 PHP 4.3.0 后这个不建议被使用，因为会和其他带“:”字符的文件名混淆； 请使用 compress.zlib:// 作为替代。"},{"type":4,"line":"compress.zlib://、 compress.bzip2:// 和 [gzopen()](function.gzopen.html)、[bzopen()](function.bzopen.html) 是相等的。并且可以在不支持 fopencookie 的系统中使用。"},{"type":4,"line":"[ZIP 扩展](book.zip.html) 注册了 zip: 封装器。 自 PHP 7.2.0 和 libzip 1.2.0+ 起，加密归档开始支持密码，允许数据流中使用密码。 字节流上下文（stream contexts）中使用 _'password'_ 选项设置密码。"},{"type":4,"line":"### 可选项"},{"type":4,"line":"*   compress.zlib://file.gz"},{"type":4,"line":"*   compress.bzip2://file.bz2"},{"type":4,"line":"*   zip://archive.zip#dir/file.txt"},{"type":4,"line":"### 用法"},{"type":4,"line":"**封装协议摘要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受限于 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes（除了 _zip://_）"},{"type":4,"line":"允许附加"},{"type":4,"line":"Yes（除了 _zip://_）"},{"type":4,"line":"允许同时读写"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No，请使用普通的 _file://_ 封装器统计压缩文件。"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No，请使用 _file://_ 封装器删除压缩文件。"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":2,"line":"19.6 data://"},{"type":4,"line":"data:// — 数据（RFC 2397）"},{"type":4,"line":"### 说明"},{"type":4,"line":"自 PHP 5.2.0 起 data:（[» RFC 2397](http://www.faqs.org/rfcs/rfc2397)）数据流封装器开始有效。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   data://text/plain;base64,"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议摘要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受限于 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"受限于 [allow\\_url\\_include](filesystem.configuration.html#ini.allow-url-include)"},{"type":4,"line":"Yes"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"No"},{"type":4,"line":"允许追加"},{"type":4,"line":"No"},{"type":4,"line":"允许同时读写"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 打印 data:// 的内容**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 打印 \"I love PHP\"  "},{"type":4,"line":"echo file_get_contents('data://text/plain;base64,SSBsb3ZlIFBIUAo=');  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 获取媒体类型**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$fp   = fopen('data://text/plain;base64,', 'r');  "},{"type":4,"line":"$meta = stream_get_meta_data($fp);  "},{"type":4,"line":"  "},{"type":4,"line":"// 打印 \"text/plain\"  "},{"type":4,"line":"echo $meta['mediatype'];  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":2,"line":"19.7 glob://"},{"type":4,"line":"glob:// — 查找匹配的文件路径模式"},{"type":4,"line":"### 说明"},{"type":4,"line":"glob: 数据流包装器自 PHP 5.3.0 起开始有效。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   glob://"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议摘要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受限于 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"受限于 [allow\\_url\\_include](filesystem.configuration.html#ini.allow-url-include)"},{"type":4,"line":"No"},{"type":4,"line":"允许读取"},{"type":4,"line":"No"},{"type":4,"line":"允许写入"},{"type":4,"line":"No"},{"type":4,"line":"允许附加"},{"type":4,"line":"No"},{"type":4,"line":"允许同时读写"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 基本用法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 循环 ext/spl/examples/ 目录里所有 *.php 文件  "},{"type":4,"line":"// 并打印文件名和文件尺寸  "},{"type":4,"line":"$it = new DirectoryIterator(\"glob://ext/spl/examples/*.php\");  "},{"type":5,"line":"foreach($it as $f) {  "},{"type":4,"line":"    printf(\"%s: %.1FK\\n\", $f->getFilename(), $f->getSize()/1024);  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"tree.php: 1.0K"},{"type":4,"line":"findregex.php: 0.6K"},{"type":4,"line":"findfile.php: 0.7K"},{"type":4,"line":"dba\\_dump.php: 0.9K"},{"type":4,"line":"nocvsdir.php: 1.1K"},{"type":4,"line":"phar\\_from\\_dir.php: 1.0K"},{"type":4,"line":"ini\\_groups.php: 0.9K"},{"type":4,"line":"directorytree.php: 0.9K"},{"type":4,"line":"dba\\_array.php: 1.1K"},{"type":4,"line":"class\\_tree.php: 1.8K"},{"type":2,"line":"19.8 phar://"},{"type":4,"line":"phar:// — PHP 归档"},{"type":4,"line":"### 说明"},{"type":4,"line":"phar:// 数据流包装器自 PHP 5.3.0 起开始有效。详细的描述可参见 [Phar 数据流包装器](phar.using.stream.html)。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   phar://"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议摘要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"支持 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [allow\\_url\\_include](filesystem.configuration.html#ini.allow-url-include)"},{"type":4,"line":"No"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes"},{"type":4,"line":"允许附加"},{"type":4,"line":"No"},{"type":4,"line":"允许同时读写"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [Phar 上下文（context）选项](context.phar.html)"},{"type":2,"line":"19.9 ssh2://"},{"type":4,"line":"ssh2:// — Secure Shell 2"},{"type":4,"line":"### 说明"},{"type":4,"line":"ssh2.shell:// ssh2.exec:// ssh2.tunnel:// ssh2.sftp:// ssh2.scp:// PHP 4.3.0 and up (PECL)"},{"type":4,"line":"> **Note**: **该封装器默认没有激活**  "},{"type":4,"line":"> 为了使用 ssh2.\\*:// 封装协议， 你必须安装来自 [» PECL](https://pecl.php.net/) 的 [» SSH2](https://pecl.php.net/package/ssh2) 扩展。"},{"type":4,"line":"除了支持传统的 URI 登录信息，ssh2 封装协议也支持通过 URL 的主机（host）部分来复用打开连接。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   ssh2.shell://user:pass@example.com:22/xterm"},{"type":4,"line":"*   ssh2.exec://user:pass@example.com:22/usr/local/bin/somecmd"},{"type":4,"line":"*   ssh2.tunnel://user:pass@example.com:22/192.168.0.1:14"},{"type":4,"line":"*   ssh2.sftp://user:pass@example.com:22/path/to/filename"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议概要**"},{"type":4,"line":"属性"},{"type":4,"line":"ssh2.shell"},{"type":4,"line":"ssh2.exec"},{"type":4,"line":"ssh2.tunnel"},{"type":4,"line":"ssh2.sftp"},{"type":4,"line":"ssh2.scp"},{"type":4,"line":"受 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen) 影响"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"允许追加"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"Yes（当服务器支持的时候）"},{"type":4,"line":"No"},{"type":4,"line":"允许同时读和写"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"No"},{"type":4,"line":"Yes"},{"type":4,"line":"No"},{"type":4,"line":"**上下文选项（Context）**"},{"type":4,"line":"名称"},{"type":4,"line":"用法"},{"type":4,"line":"默认"},{"type":4,"line":"_session_"},{"type":4,"line":"重复使用预连接的 ssh2 资源"},{"type":4,"line":" "},{"type":4,"line":"_sftp_"},{"type":4,"line":"重复使用预先分配的 sftp 资源"},{"type":4,"line":" "},{"type":4,"line":"_methods_"},{"type":4,"line":"密钥交换（key exchange）、主机密钥（hostkey）、cipher、压缩和 MAC 方法"},{"type":4,"line":" "},{"type":4,"line":"_callbacks_"},{"type":4,"line":" "},{"type":4,"line":" "},{"type":4,"line":"_username_"},{"type":4,"line":"以该用户名连接"},{"type":4,"line":" "},{"type":4,"line":"_password_"},{"type":4,"line":"使用的密码来进行密码验证"},{"type":4,"line":" "},{"type":4,"line":"_pubkey\\_file_"},{"type":4,"line":"用于验证的公钥（public key）文件"},{"type":4,"line":" "},{"type":4,"line":"_privkey\\_file_"},{"type":4,"line":"用于验证的私钥（private key）文件"},{"type":4,"line":" "},{"type":4,"line":"_env_"},{"type":4,"line":"需要设置的环境变量的关联数组"},{"type":4,"line":" "},{"type":4,"line":"_term_"},{"type":4,"line":"在分配一个 pty 时请求的终端类型"},{"type":4,"line":" "},{"type":4,"line":"_term\\_width_"},{"type":4,"line":"在分配一个 pty 时请求的终端宽度"},{"type":4,"line":" "},{"type":4,"line":"_term\\_height_"},{"type":4,"line":"在分配一个 pty 时请求的终端宽度高度"},{"type":4,"line":" "},{"type":4,"line":"_term\\_units_"},{"type":4,"line":"term\\_width 和 term\\_height 的单位"},{"type":4,"line":"**`SSH2_TERM_UNIT_CHARS`**"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 从一个活动连接中打开字节流**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$session = ssh2_connect('example.com', 22);  "},{"type":5,"line":"ssh2_auth_pubkey_file($session, 'username', '/home/username/.ssh/id_rsa.pub',  "},{"type":4,"line":"                                            '/home/username/.ssh/id_rsa', 'secret');  "},{"type":4,"line":"$stream = fopen(\"ssh2.tunnel://$session/remote.example.com:1234\", 'r');  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 This $session variable must be kept available!**"},{"type":4,"line":"In order to use the ssh2.\\*://$session wrappers you must keep the $session resouce variable. The code below will not have the desired effect:"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$session = ssh2_connect('example.com', 22);  "},{"type":5,"line":"ssh2_auth_pubkey_file($session, 'username', '/home/username/.ssh/id_rsa.pub',  "},{"type":4,"line":"                                            '/home/username/.ssh/id_rsa', 'secret');  "},{"type":4,"line":"$connection_string = \"ssh2.sftp://$session/\";  "},{"type":4,"line":"unset($session);  "},{"type":4,"line":"$stream = fopen($connection_string . \"path/to/file\", 'r');  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"unset() closes the session, because $connection\\_string does not hold a reference to the $session variable, just a string cast derived from it. This also happens when the [unset()](function.unset.html) is implicit because of leaving scope (like in a function)."},{"type":2,"line":"19.10 rar://"},{"type":4,"line":"rar:// — RAR"},{"type":4,"line":"### 说明"},{"type":4,"line":"The wrapper takes the url encoded path to the RAR archive (relative or absolute), an optional asterik (_\\*_), an optional number sign (_#_) and an optional url encoded entry name, as stored in the archive. Specifying an entry name requires the number sign; a leading forward slash in the entry name is optional."},{"type":4,"line":"This wrapper can open both files and directories. When opening directories, the asterisk sign forces the directory entries names to be returned unencoded. If it's not specified, they will be returned url encoded – the reason for this is to allow the wrapper to be correctly used with built-in functionality like the [RecursiveDirectoryIterator](class.recursivedirectoryiterator.html) in the presence of file names that seem like url encoded data."},{"type":4,"line":"If the pound sign and the entry name part are not included, the root of the archive will be displayed. This differs from regular directories in that the resulting stream will not contain information such as the modification time, as the root directory is not stored in an individual entry in the archive. The usage of the wrapper with [RecursiveDirectoryIterator](class.recursivedirectoryiterator.html) requires the number sign to be included in the URL when accessing the root, so that the URLs of the children may be constructed correctly."},{"type":4,"line":"> **Note**: **This wrapper is not enabled by default**  "},{"type":4,"line":"> In order to use the rar:// wrapper, you must install the [» rar](https://pecl.php.net/package/rar) extension available from [» PECL](https://pecl.php.net/)."},{"type":4,"line":"rar:// Available since PECL rar 3.0.0"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   rar://<url encoded archive name>\\[\\*\\]\\[#\\[<url encoded entry name>\\]\\]"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**Wrapper Summary**"},{"type":4,"line":"Attribute"},{"type":4,"line":"Supported"},{"type":4,"line":"Restricted by [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"Restricted by [allow\\_url\\_include](filesystem.configuration.html#ini.allow-url-include)"},{"type":4,"line":"No"},{"type":4,"line":"Allows Reading"},{"type":4,"line":"Yes"},{"type":4,"line":"Allows Writing"},{"type":4,"line":"No"},{"type":4,"line":"Allows Appending"},{"type":4,"line":"No"},{"type":4,"line":"Allows Simultaneous Reading and Writing"},{"type":4,"line":"No"},{"type":4,"line":"Supports [stat()](function.stat.html)"},{"type":4,"line":"Yes"},{"type":4,"line":"Supports [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"Supports [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"Supports [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"Supports [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"**Context options**"},{"type":4,"line":"Name"},{"type":4,"line":"Usage"},{"type":4,"line":"Default"},{"type":4,"line":"_open\\_password_"},{"type":4,"line":"The password used to encrypt the headers of the archive, if any. WinRAR will encrypt all the files with the same password as the headers password when the later is present, so for archives with encrypted headers, _file\\_password_ will be ignored."},{"type":4,"line":" "},{"type":4,"line":"_file\\_password_"},{"type":4,"line":"The password used to encrypt a file, if any. If the headers are also encrypted, this option will be ignored in favor of _open\\_password_. The reason there are two options is to cover the possibility of supporting archives with different headers and file passwords, should those archives arise. Note that if the archive does not have its headers encrypted, _open\\_password_ will be ignored and this option must be used instead."},{"type":4,"line":" "},{"type":4,"line":"_volume\\_callback_"},{"type":4,"line":"A callback to determine the path of missing volumes. See [RarArchive::open()](rararchive.open.html) for more information."},{"type":4,"line":" "},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 Traversing a RAR archive**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":5,"line":"class MyRecDirIt extends RecursiveDirectoryIterator {  "},{"type":5,"line":"    function current() {  "},{"type":5,"line":"        return rawurldecode($this->getSubPathName()) .  "},{"type":5,"line":"            (is_dir(parent::current())?\" [DIR]\":\"\");  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"$f = \"rar://\" . rawurlencode(dirname(__FILE__)) .  "},{"type":4,"line":"    DIRECTORY_SEPARATOR . 'dirs_and_extra_headers.rar#';  "},{"type":4,"line":"  "},{"type":4,"line":"$it = new RecursiveTreeIterator(new MyRecDirIt($f));  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($it as $s) {  "},{"type":4,"line":"    echo $s, \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"|-allow\\_everyone\\_ni \\[DIR\\]"},{"type":4,"line":"|-file1.txt"},{"type":4,"line":"|-file2\\_אּ.txt"},{"type":4,"line":"|-with\\_streams.txt"},{"type":4,"line":"\\\\-אּ \\[DIR\\]"},{"type":4,"line":"  |-אּ\\\\%2Fempty%2E \\[DIR\\]"},{"type":4,"line":"  | \\\\-אּ\\\\%2Fempty%2E\\\\file7.txt"},{"type":4,"line":"  |-אּ\\\\empty \\[DIR\\]"},{"type":4,"line":"  |-אּ\\\\file3.txt"},{"type":4,"line":"  |-אּ\\\\file4\\_אּ.txt"},{"type":5,"line":"  \\\\-אּ\\\\אּ\\_2 \\[DIR\\]"},{"type":5,"line":"    |-אּ\\\\אּ\\_2\\\\file5.txt"},{"type":4,"line":"    \\\\-אּ\\\\אּ\\_2\\\\file6\\_אּ.txt"},{"type":4,"line":"**Example #2 Opening an encrypted file (header encryption)**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$stream = fopen(\"rar://\" .  "},{"type":5,"line":"    rawurlencode(dirname(__FILE__)) . DIRECTORY_SEPARATOR .  "},{"type":5,"line":"    'encrypted_headers.rar' . '#encfile1.txt', \"r\", false,  "},{"type":5,"line":"    stream_context_create(  "},{"type":5,"line":"        array(  "},{"type":5,"line":"            'rar' =>  "},{"type":5,"line":"                array(  "},{"type":5,"line":"                    'open_password' => 'samplepassword'  "},{"type":5,"line":"                )  "},{"type":5,"line":"            )  "},{"type":5,"line":"        )  "},{"type":4,"line":"    );  "},{"type":4,"line":"var_dump(stream_get_contents($stream));  "},{"type":4,"line":"/* creation and last access date is opt-in in WinRAR, hence most  "},{"type":4,"line":" * files don't have them */  "},{"type":4,"line":"var_dump(fstat($stream));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"string(26) \"Encrypted file 1 contents.\""},{"type":4,"line":"Array"},{"type":5,"line":"("},{"type":5,"line":"    \\[0\\] => 0"},{"type":5,"line":"    \\[1\\] => 0"},{"type":5,"line":"    \\[2\\] => 33206"},{"type":5,"line":"    \\[3\\] => 1"},{"type":5,"line":"    \\[4\\] => 0"},{"type":5,"line":"    \\[5\\] => 0"},{"type":5,"line":"    \\[6\\] => 0"},{"type":5,"line":"    \\[7\\] => 26"},{"type":5,"line":"    \\[8\\] => 0"},{"type":5,"line":"    \\[9\\] => 1259550052"},{"type":5,"line":"    \\[10\\] => 0"},{"type":5,"line":"    \\[11\\] => -1"},{"type":5,"line":"    \\[12\\] => -1"},{"type":5,"line":"    \\[dev\\] => 0"},{"type":5,"line":"    \\[ino\\] => 0"},{"type":5,"line":"    \\[mode\\] => 33206"},{"type":5,"line":"    \\[nlink\\] => 1"},{"type":5,"line":"    \\[uid\\] => 0"},{"type":5,"line":"    \\[gid\\] => 0"},{"type":5,"line":"    \\[rdev\\] => 0"},{"type":5,"line":"    \\[size\\] => 26"},{"type":5,"line":"    \\[atime\\] => 0"},{"type":5,"line":"    \\[mtime\\] => 1259550052"},{"type":5,"line":"    \\[ctime\\] => 0"},{"type":5,"line":"    \\[blksize\\] => -1"},{"type":4,"line":"    \\[blocks\\] => -1"},{"type":4,"line":")"},{"type":2,"line":"19.11 ogg://"},{"type":4,"line":"ogg:// — 音频流"},{"type":4,"line":"### 说明"},{"type":4,"line":"通过包装器 ogg:// 读取的文件， 是作为 _OGG/Vorbis_ 格式的压缩音频编码。 同样，通过包装器 ogg:// 写入或追加的数据格式也是压缩音频。 当 [stream\\_get\\_meta\\_data()](function.stream-get-meta-data.html) 用于一个打开读取的 _OGG/Vorbis_ 文件时，会返回关于数据流的详细信息，包含了 `vendor` 标签、任何内含的 `comments`、 `channels` 数字、采样率（`rate`），以及 用 `bitrate_lower`、`bitrate_upper`、 `bitrate_nominal` 和 `bitrate_window` 描述的可变比特率范围。"},{"type":4,"line":"ogg:// PHP 4.3.0 及以上（PECL）"},{"type":4,"line":"> **Note**: **该封装器默认未激活**  "},{"type":4,"line":"> 要使用 ogg:// 封装器，您必须安装 [» OGG/Vorbis](https://pecl.php.net/package/oggvorbis) 扩展。 可以在 [» PECL](https://pecl.php.net/) 上找到。"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   ogg://soundfile.ogg"},{"type":4,"line":"*   ogg:///path/to/soundfile.ogg"},{"type":4,"line":"*   ogg://http://www.example.com/path/to/soundstream.ogg"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议摘要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受限于 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen)"},{"type":4,"line":"No"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes"},{"type":4,"line":"允许附加"},{"type":4,"line":"Yes"},{"type":4,"line":"允许同时读写"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"**上下文选项**"},{"type":4,"line":"Name"},{"type":4,"line":"Usage"},{"type":4,"line":"Default"},{"type":4,"line":"Mode"},{"type":4,"line":"_pcm\\_mode_"},{"type":4,"line":"读取时使用如下 PCM 编码之一: **`OGGVORBIS_PCM_U8`**、**`OGGVORBIS_PCM_S8`**、 **`OGGVORBIS_PCM_U16_BE`**、**`OGGVORBIS_PCM_S16_BE`**、 **`OGGVORBIS_PCM_U16_LE`** 和 **`OGGVORBIS_PCM_S16_LE`**。 (8 或 16 位，签名或未签名，大或小的 _endian_)"},{"type":4,"line":"OGGVORBIS\\_PCM\\_S16\\_LE"},{"type":4,"line":"读取"},{"type":4,"line":"_rate_"},{"type":4,"line":"输入数据的采样率，单位为 Hz"},{"type":4,"line":"44100"},{"type":4,"line":"写入/附加"},{"type":4,"line":"_bitrate_"},{"type":4,"line":"若给的值为整数，则是用固定的比特率进行编码。（16000 到 131072）若给的值为浮点数，则使用可变的比特率（质。(-1.0 到 1.0）"},{"type":4,"line":"128000"},{"type":4,"line":"写入/附加"},{"type":4,"line":"_channels_"},{"type":4,"line":"要编码的声道的数量，典型为 1 (单声道), 或 2 (立体声)。最高支持 16 声道。"},{"type":4,"line":"2"},{"type":4,"line":"写入/附加"},{"type":4,"line":"_comments_"},{"type":4,"line":"编码到音轨头部的字符串数组。"},{"type":4,"line":" "},{"type":4,"line":"写入/附加"},{"type":4,"line":"### 范例"},{"type":2,"line":"19.12 expect://"},{"type":4,"line":"expect:// — 处理交互式的流"},{"type":4,"line":"### 说明"},{"type":4,"line":"由 expect:// 封装协议打开的数据流 PTY 通过提供了对进程 stdio、stdout 和 stderr 的访问。"},{"type":4,"line":"> **Note**: **该封装协议默认未开启**  "},{"type":4,"line":"> 为了使用 expect:// 封装器，你必须安装 [» PECL](https://pecl.php.net/) 上的 [» Expect](https://pecl.php.net/package/expect) 扩展。"},{"type":4,"line":"expect:// PHP 4.3.0 and up (PECL)"},{"type":4,"line":"### 用法"},{"type":4,"line":"*   expect://command"},{"type":4,"line":"### 可选项"},{"type":4,"line":"**封装协议概要**"},{"type":4,"line":"属性"},{"type":4,"line":"支持"},{"type":4,"line":"受 [allow\\_url\\_fopen](filesystem.configuration.html#ini.allow-url-fopen) 影响"},{"type":4,"line":"No"},{"type":4,"line":"允许读取"},{"type":4,"line":"Yes"},{"type":4,"line":"允许写入"},{"type":4,"line":"Yes"},{"type":4,"line":"允许添加"},{"type":4,"line":"Yes"},{"type":4,"line":"允许同时读和写"},{"type":4,"line":"No"},{"type":4,"line":"支持 [stat()](function.stat.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [unlink()](function.unlink.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rename()](function.rename.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [mkdir()](function.mkdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"支持 [rmdir()](function.rmdir.html)"},{"type":4,"line":"No"},{"type":4,"line":"### 范例"},{"type":1,"line":"2. 类型"},{"type":4,"line":"2.1 简介"},{"type":4,"line":"--"},{"type":4,"line":"PHP 支持 9 种原始数据类型。"},{"type":4,"line":"四种标量类型："},{"type":4,"line":"*   [boolean](language.types.boolean.html)（布尔型）"},{"type":4,"line":"*   [integer](language.types.integer.html)（整型）"},{"type":4,"line":"*   [float](language.types.float.html)（浮点型，也称作 [double](language.types.float.html))"},{"type":4,"line":"*   [string](language.types.string.html)（字符串）"},{"type":4,"line":"三种复合类型："},{"type":4,"line":"*   [array](language.types.array.html)（数组）"},{"type":4,"line":"*   [object](language.types.object.html)（对象）"},{"type":4,"line":"*   [callable](language.types.callable.html)（可调用）"},{"type":4,"line":"最后是两种特殊类型："},{"type":4,"line":"*   [resource](language.types.resource.html)（资源）"},{"type":4,"line":"*   [NULL](language.types.null.html)（无类型）"},{"type":4,"line":"为了确保代码的易读性，本手册还介绍了一些[伪类型](language.pseudo-types.html)："},{"type":4,"line":"*   [mixed](language.pseudo-types.html#language.types.mixed)（混合类型）"},{"type":4,"line":"*   [number](language.pseudo-types.html#language.types.number)（数字类型）"},{"type":4,"line":"*   [callback](language.pseudo-types.html#language.types.callback)（回调类型，又称为 [callable](language.types.callable.html)）"},{"type":4,"line":"*   [array|object](language.pseudo-types.html#language.types.array-object)（数组 | 对象类型）"},{"type":4,"line":"*   void （无类型）"},{"type":4,"line":"以及伪变量 `$...`。"},{"type":4,"line":"可能还会读到一些关于“双精度（double）”类型的参考。实际上 double 和 float 是相同的，由于一些历史的原因，这两个名称同时存在。"},{"type":4,"line":"变量的类型通常不是由程序员设定的，确切地说，是由 PHP 根据该变量使用的上下文在运行时决定的。"},{"type":4,"line":"> **Note**: 如果想查看某个[表达式](language.expressions.html)的值和类型，用 [var\\_dump()](function.var-dump.html) 函数。"},{"type":4,"line":"> "},{"type":4,"line":"> 如果只是想得到一个易读懂的类型的表达方式用于调试，用 [gettype()](function.gettype.html) 函数。要检验某个类型，_不要_用 [gettype()](function.gettype.html)，而用 _is\\_type_ 函数。以下是一些范例："},{"type":4,"line":"> "},{"type":4,"line":">"},{"type":4,"line":" "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> $a_bool = TRUE;   // 布尔值 boolean  "},{"type":4,"line":"> $a_str  = \"foo\";  // 字符串 string  "},{"type":4,"line":"> $a_str2 = 'foo';  // 字符串 string  "},{"type":4,"line":"> $an_int = 12;     // 整型 integer  "},{"type":4,"line":">   "},{"type":4,"line":"> echo gettype($a_bool); // 输出:  boolean  "},{"type":4,"line":"> echo gettype($a_str);  // 输出:  string  "},{"type":4,"line":">   "},{"type":4,"line":"> // 如果是整型，就加上 4  "},{"type":4,"line":"> if (is_int($an_int)) {  "},{"type":4,"line":">     $an_int += 4;  "},{"type":4,"line":"> }  "},{"type":4,"line":">   "},{"type":4,"line":"> // 如果 $bool 是字符串，就打印出来  "},{"type":4,"line":"> // (啥也没打印出来)  "},{"type":4,"line":"> if (is_string($a_bool)) {  "},{"type":4,"line":">     echo \"String: $a_bool\";  "},{"type":4,"line":"> }  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"如果要将一个变量强制转换为某类型，可以对其使用[强制转换](language.types.type-juggling.html#language.types.typecasting)或者 [settype()](function.settype.html) 函数。"},{"type":4,"line":"注意变量根据其当时的类型在特定场合下会表现出不同的值。更多信息见[类型转换的判别](language.types.type-juggling.html)。此外，还可以参考 [PHP 类型比较表](types.comparisons.html)看不同类型相互比较的例子。"},{"type":3,"line":"2.2 Boolean 布尔类型"},{"type":4,"line":"这是最简单的类型。[boolean](language.types.boolean.html) 表达了真值，可以为 **`TRUE`** 或 **`FALSE`**。"},{"type":4,"line":"### 语法"},{"type":4,"line":"要指定一个布尔值，使用常量 **`TRUE`** 或 **`FALSE`**。两个都不区分大小写。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = True; // 设置 $foo 为 TRUE  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"通常[运算符](language.operators.html)所返回的 [boolean](language.types.boolean.html) 值结果会被传递给[控制流程](language.control-structures.html)。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// == 是一个操作符，它检测两个变量是否相等，并返回一个布尔值  "},{"type":5,"line":"if ($action == \"show_version\") {  "},{"type":4,"line":"    echo \"The version is 1.23\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 这样做是不必要的...  "},{"type":5,"line":"if ($show_separators == TRUE) {  "},{"type":4,"line":"    echo \"<hr>\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// ...因为可以使用下面这种简单的方式：  "},{"type":5,"line":"if ($show_separators) {  "},{"type":4,"line":"    echo \"<hr>\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 转换为布尔值"},{"type":4,"line":"要明确地将一个值转换成 [boolean](language.types.boolean.html)，用 _(bool)_ 或者 _(boolean)_ 来强制转换。但是很多情况下不需要用强制转换，因为当运算符，函数或者流程控制结构需要一个 [boolean](language.types.boolean.html) 参数时，该值会被自动转换。"},{"type":4,"line":"参见[类型转换的判别](language.types.type-juggling.html)。"},{"type":4,"line":"当转换为 [boolean](language.types.boolean.html) 时，以下值被认为是 **`FALSE`**："},{"type":4,"line":"*   [布尔](language.types.boolean.html)值 **`FALSE`** 本身"},{"type":4,"line":"*   [整型](language.types.integer.html)值 0（零）"},{"type":4,"line":"*   [浮点型](language.types.float.html)值 0.0（零）"},{"type":4,"line":"*   空[字符串](language.types.string.html)，以及[字符串](language.types.string.html) \"0\""},{"type":4,"line":"*   不包括任何元素的[数组](language.types.array.html)"},{"type":4,"line":"*   特殊类型 [NULL](language.types.null.html)（包括尚未赋值的变量）"},{"type":4,"line":"*   从空标记生成的 [SimpleXML](ref.simplexml.html) 对象"},{"type":4,"line":"所有其它值都被认为是 **`TRUE`**（包括任何[资源](language.types.resource.html) 和 **`NAN`**）。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"_\\-1_ 和其它非零值（不论正负）一样，被认为是 **`TRUE`**！"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"var_dump((bool) \"\");        // bool(false)  "},{"type":4,"line":"var_dump((bool) 1);         // bool(true)  "},{"type":4,"line":"var_dump((bool) -2);        // bool(true)  "},{"type":4,"line":"var_dump((bool) \"foo\");     // bool(true)  "},{"type":4,"line":"var_dump((bool) 2.3e5);     // bool(true)  "},{"type":4,"line":"var_dump((bool) array(12)); // bool(true)  "},{"type":4,"line":"var_dump((bool) array());   // bool(false)  "},{"type":4,"line":"var_dump((bool) \"false\");   // bool(true)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"2.3 Integer 整型"},{"type":4,"line":"[integer](language.types.integer.html) 是集合 ℤ = {..., -2, -1, 0, 1, 2, ...} 中的某个数。"},{"type":4,"line":"参见："},{"type":4,"line":"*   [任意长度整数／GMP](book.gmp.html)"},{"type":4,"line":"*   [浮点型](language.types.float.html)"},{"type":4,"line":"*   [任意精度数学库／BCMath](book.bc.html)"},{"type":4,"line":"### 语法"},{"type":4,"line":"整型值可以使用十进制，十六进制，八进制或二进制表示，前面可以加上可选的符号（- 或者 +）。"},{"type":4,"line":"二进制表达的 [integer](language.types.integer.html) 自 PHP 5.4.0 起可用。"},{"type":4,"line":"要使用八进制表达，数字前必须加上 _0_（零）。要使用十六进制表达，数字前必须加上 _0x_。要使用二进制表达，数字前必须加上 _0b_。"},{"type":4,"line":"**Example #1 整数文字表达**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1234; // 十进制数  "},{"type":4,"line":"$a = -123; // 负数  "},{"type":4,"line":"$a = 0123; // 八进制数 (等于十进制 83)  "},{"type":4,"line":"$a = 0x1A; // 十六进制数 (等于十进制 26)  "},{"type":4,"line":"$a = 0b11111111; // 二进制数字 (等于十进制 255)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"[integer](language.types.integer.html) 语法的结构形式是："},{"type":5,"line":"decimal     : \\[1-9\\]\\[0-9\\]\\*"},{"type":4,"line":"            | 0"},{"type":4,"line":"hexadecimal : 0\\[xX\\]\\[0-9a-fA-F\\]+"},{"type":4,"line":"octal       : 0\\[0-7\\]+"},{"type":4,"line":"binary      : 0b\\[01\\]+"},{"type":5,"line":"integer     : \\[+-\\]?decimal"},{"type":5,"line":"            | \\[+-\\]?hexadecimal"},{"type":5,"line":"            | \\[+-\\]?octal"},{"type":4,"line":"            | \\[+-\\]?binary"},{"type":4,"line":"整型数的字长和平台有关，尽管通常最大值是大约二十亿（32 位有符号）。64 位平台下的最大值通常是大约 9E18，除了 Windows 下 PHP 7 以前的版本，总是 32 位的。 PHP 不支持无符号的 [integer](language.types.integer.html)。[Integer](language.types.integer.html) 值的字长可以用常量 **`PHP_INT_SIZE`**来表示，自 PHP 4.4.0 和 PHP 5.0.5后，最大值可以用常量 **`PHP_INT_MAX`** 来表示，最小值可以在 PHP 7.0.0 及以后的版本中用常量 **`PHP_INT_MIN`** 表示。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"PHP 7 以前的版本里，如果向八进制数传递了一个非法数字（即 8 或 9），则后面其余数字会被忽略。PHP 7 以后，会产生 Parse Error。"},{"type":4,"line":"### 整数溢出"},{"type":4,"line":"如果给定的一个数超出了 [integer](language.types.integer.html) 的范围，将会被解释为 [float](language.types.float.html)。同样如果执行的运算结果超出了 [integer](language.types.integer.html) 范围，也会返回 [float](language.types.float.html)。"},{"type":4,"line":"**Example #2 32 位系统下的整数溢出**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$large_number = 2147483647;  "},{"type":4,"line":"var_dump($large_number);                     // int(2147483647)  "},{"type":4,"line":"  "},{"type":4,"line":"$large_number = 2147483648;  "},{"type":4,"line":"var_dump($large_number);                     // float(2147483648)  "},{"type":4,"line":"  "},{"type":4,"line":"$million = 1000000;  "},{"type":4,"line":"$large_number =  50000 * $million;  "},{"type":4,"line":"var_dump($large_number);                     // float(50000000000)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #3 64 位系统下的整数溢出**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$large_number = 9223372036854775807;  "},{"type":4,"line":"var_dump($large_number);                     // int(9223372036854775807)  "},{"type":4,"line":"  "},{"type":4,"line":"$large_number = 9223372036854775808;  "},{"type":4,"line":"var_dump($large_number);                     // float(9.2233720368548E+18)  "},{"type":4,"line":"  "},{"type":4,"line":"$million = 1000000;  "},{"type":4,"line":"$large_number =  50000000000000 * $million;  "},{"type":4,"line":"var_dump($large_number);                     // float(5.0E+19)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"PHP 中没有整除的运算符。_1/2_ 产生出 [float](language.types.float.html) _0.5_。 值可以舍弃小数部分，强制转换为 [integer](language.types.integer.html)，或者使用 [round()](function.round.html) 函数可以更好地进行四舍五入。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"var_dump(25/7);         // float(3.5714285714286)   "},{"type":4,"line":"var_dump((int) (25/7)); // int(3)  "},{"type":4,"line":"var_dump(round(25/7));  // float(4)   "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 转换为整型"},{"type":4,"line":"要明确地将一个值转换为 [integer](language.types.integer.html)，用 _(int)_ 或 _(integer)_ 强制转换。不过大多数情况下都不需要强制转换，因为当运算符，函数或流程控制需要一个 [integer](language.types.integer.html) 参数时，值会自动转换。还可以通过函数 [intval()](function.intval.html) 来将一个值转换成整型。"},{"type":4,"line":"将 [resource](language.types.resource.html) 转换成 [integer](language.types.integer.html) 时， 结果会是 PHP 运行时为 [resource](language.types.resource.html) 分配的唯一资源号。"},{"type":4,"line":"参见：[类型转换的判别](language.types.type-juggling.html)。"},{"type":4,"line":"#### 从[布尔值](language.types.boolean.html)转换"},{"type":4,"line":"**`FALSE`** 将产生出 _0_（零），**`TRUE`** 将产生出 _1_（壹）。"},{"type":4,"line":"#### 从[浮点型](language.types.float.html)转换"},{"type":4,"line":"当从浮点数转换成整数时，将_向下_取整。"},{"type":4,"line":"如果浮点数超出了整数范围（32 位平台下通常为 _+/- 2.15e+9 = 2^31_，64 位平台下，除了 Windows，通常为 _+/- 9.22e+18 = 2^63_），则结果为未定义，因为没有足够的精度给出一个确切的整数结果。在此情况下没有警告，甚至没有任何通知！"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> PHP 7.0.0 起，NaN 和 Infinity 在转换成 [integer](language.types.integer.html) 时，不再是 undefined 或者依赖于平台，而是都会变成零。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"绝不要将未知的分数强制转换为 [integer](language.types.integer.html)，这样有时会导致不可预料的结果。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo (int) ( (0.1+0.7) * 10 ); // 显示 7!  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见[关于浮点数精度的警告](language.types.float.html#warn.float-precision)。"},{"type":4,"line":"#### 从字符串转换"},{"type":4,"line":"参见[字符串转换为数值](language.types.string.html#language.types.string.conversion)。"},{"type":4,"line":"#### 从其它类型转换"},{"type":4,"line":"**Caution**"},{"type":4,"line":"没有定义从其它类型转换为整型的行为。_不要_依赖任何现有的行为，因为它会未加通知地改变。"},{"type":3,"line":"2.4 Float 浮点型"},{"type":4,"line":"浮点型（也叫浮点数 float，双精度数 double 或实数 real）可以用以下任一语法定义："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1.234;   "},{"type":4,"line":"$b = 1.2e3;   "},{"type":4,"line":"$c = 7E-10;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"浮点数的形式表示："},{"type":4,"line":"LNUM          \\[0-9\\]+"},{"type":4,"line":"DNUM          (\\[0-9\\]\\*\\[\\\\.\\]{LNUM}) | ({LNUM}\\[\\\\.\\]\\[0-9\\]\\*)"},{"type":4,"line":"EXPONENT\\_DNUM \\[+-\\]?(({LNUM} | {DNUM}) \\[eE\\]\\[+-\\]? {LNUM})"},{"type":4,"line":"浮点数的字长和平台相关，尽管通常最大值是 1.8e308 并具有 14 位十进制数字的精度（64 位 IEEE 格式）。"},{"type":4,"line":"**Warning**"},{"type":2,"line":"浮点数的精度"},{"type":4,"line":"浮点数的精度有限。尽管取决于系统，PHP 通常使用 IEEE 754 双精度格式，则由于取整而导致的最大相对误差为 1.11e-16。非基本数学运算可能会给出更大误差，并且要考虑到进行复合运算时的误差传递。"},{"type":4,"line":"此外，以十进制能够精确表示的有理数如 _0.1_ 或 _0.7_，无论有多少尾数都不能被内部所使用的二进制精确表示，因此不能在不丢失一点点精度的情况下转换为二进制的格式。这就会造成混乱的结果：例如，_floor((0.1+0.7)\\*10)_ 通常会返回 _7_ 而不是预期中的 _8_，因为该结果内部的表示其实是类似 _7.9999999999999991118..._。"},{"type":4,"line":"所以永远不要相信浮点数结果精确到了最后一位，也永远不要比较两个浮点数是否相等。如果确实需要更高的精度，应该使用[任意精度数学函数](ref.bc.html)或者 [gmp 函数](ref.gmp.html)。"},{"type":4,"line":"参见[» 浮点数指南](http://floating-point-gui.de/)网页的简单解释。"},{"type":4,"line":"### 转换为浮点数"},{"type":4,"line":"如果希望了解有关何时和如何将字符串转换成浮点数的信息，请参阅“[字符串转换为数值](language.types.string.html#language.types.string.conversion)”一节。对于其它类型的值，其情况类似于先将值转换成整型，然后再转换成浮点。请参阅“[转换为整型](language.types.integer.html#language.types.integer.casting)”一节以获取更多信息。自 PHP 5 起，如果试图将对象转换为浮点数，会发出一条 E\\_NOTICE 错误消息。"},{"type":4,"line":"### 比较浮点数"},{"type":4,"line":"如上述警告信息所言，由于内部表达方式的原因，比较两个浮点数是否相等是有问题的。不过还是有迂回的方法来比较浮点数值的。"},{"type":4,"line":"要测试浮点数是否相等，要使用一个仅比该数值大一丁点的最小误差值。该值也被称为机器极小值（epsilon）或最小单元取整数，是计算中所能接受的最小的差别值。"},{"type":4,"line":"$a 和 $b 在小数点后五位精度内都是相等的。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1.23456789;  "},{"type":4,"line":"$b = 1.23456780;  "},{"type":4,"line":"$epsilon = 0.00001;  "},{"type":4,"line":"  "},{"type":5,"line":"if(abs($a-$b) < $epsilon) {  "},{"type":4,"line":"    echo \"true\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### NaN"},{"type":4,"line":"某些数学运算会产生一个由常量 **`NAN`** 所代表的结果。此结果代表着一个在浮点数运算中未定义或不可表述的值。任何拿此值与其它任何值（除了 **`TRUE`**）进行的松散或严格比较的结果都是 **`FALSE`**。"},{"type":4,"line":"由于 **`NAN`** 代表着任何不同值，不应拿 **`NAN`** 去和其它值进行比较，包括其自身，应该用 [is\\_nan()](function.is-nan.html) 来检查。"},{"type":3,"line":"2.5 String 字符串"},{"type":4,"line":"一个字符串 [string](language.types.string.html) 就是由一系列的字符组成，其中每个字符等同于一个字节。这意味着 PHP 只能支持 256 的字符集，因此不支持 Unicode 。详见[字符串类型详解](language.types.string.html#language.types.string.details)。"},{"type":4,"line":"> **Note**: [string](language.types.string.html) 最大可以达到 2GB。"},{"type":4,"line":"### 语法"},{"type":4,"line":"一个字符串可以用 4 种方式表达："},{"type":4,"line":"*   [单引号](language.types.string.html#language.types.string.syntax.single)"},{"type":4,"line":"*   [双引号](language.types.string.html#language.types.string.syntax.double)"},{"type":4,"line":"*   [heredoc 语法结构](language.types.string.html#language.types.string.syntax.heredoc)"},{"type":4,"line":"*   [nowdoc 语法结构](language.types.string.html#language.types.string.syntax.nowdoc)（自 PHP 5.3.0 起）"},{"type":4,"line":"#### 单引号"},{"type":4,"line":"定义一个字符串的最简单的方法是用单引号把它包围起来（字符 _'_）。"},{"type":4,"line":"要表达一个单引号自身，需在它的前面加个反斜线（_\\\\_）来转义。要表达一个反斜线自身，则用两个反斜线（_\\\\\\\\_）。其它任何方式的反斜线都会被当成反斜线本身：也就是说如果想使用其它转义序列例如 _\\\\r_ 或者 _\\\\n_，并不代表任何特殊含义，就单纯是这两个字符本身。"},{"type":4,"line":"> **Note**: 不像[双引号](language.types.string.html#language.types.string.syntax.double)和 [heredoc](language.types.string.html#language.types.string.syntax.heredoc) 语法结构，在单引号字符串中的[变量](language.variables.html)和特殊字符的转义序列将_不会_被替换。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo 'this is a simple string';  "},{"type":4,"line":"  "},{"type":4,"line":"// 可以录入多行  "},{"type":4,"line":"echo 'You can also have embedded newlines in   "},{"type":4,"line":"strings this way as it is  "},{"type":4,"line":"okay to do';  "},{"type":4,"line":"  "},{"type":4,"line":"// 输出： Arnold once said: \"I'll be back\"  "},{"type":4,"line":"echo 'Arnold once said: \"I\\'ll be back\"';  "},{"type":4,"line":"  "},{"type":4,"line":"// 输出： You deleted C:\\*.*?  "},{"type":4,"line":"echo 'You deleted C:\\\\*.*?';  "},{"type":4,"line":"  "},{"type":4,"line":"// 输出： You deleted C:\\*.*?  "},{"type":4,"line":"echo 'You deleted C:\\*.*?';  "},{"type":4,"line":"  "},{"type":4,"line":"// 输出： This will not expand: \\n a newline  "},{"type":4,"line":"echo 'This will not expand: \\n a newline';  "},{"type":4,"line":"  "},{"type":4,"line":"// 输出： Variables do not $expand $either  "},{"type":4,"line":"echo 'Variables do not $expand $either';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"#### 双引号"},{"type":4,"line":"如果字符串是包围在双引号（\"）中， PHP 将对一些特殊的字符进行解析："},{"type":4,"line":"**转义字符**"},{"type":4,"line":"序列"},{"type":4,"line":"含义"},{"type":4,"line":"_\\\\n_"},{"type":4,"line":"换行（ASCII 字符集中的 LF 或 0x0A (10)）"},{"type":4,"line":"_\\\\r_"},{"type":4,"line":"回车（ASCII 字符集中的 CR 或 0x0D (13)）"},{"type":4,"line":"_\\\\t_"},{"type":4,"line":"水平制表符（ASCII 字符集中的 HT 或 0x09 (9)）"},{"type":4,"line":"_\\\\v_"},{"type":4,"line":"垂直制表符（ASCII 字符集中的 VT 或 0x0B (11)）（自 PHP 5.2.5 起）"},{"type":4,"line":"_\\\\e_"},{"type":4,"line":"Escape（ASCII 字符集中的 ESC 或 0x1B (27)）（自 PHP 5.4.0 起）"},{"type":4,"line":"_\\\\f_"},{"type":4,"line":"换页（ASCII 字符集中的 FF 或 0x0C (12)）（自 PHP 5.2.5 起）"},{"type":4,"line":"_\\\\\\\\_"},{"type":4,"line":"反斜线"},{"type":4,"line":"_\\\\$_"},{"type":4,"line":"美元标记"},{"type":4,"line":"_\\\\\"_"},{"type":4,"line":"双引号"},{"type":4,"line":"_\\\\\\[0-7\\]{1,3}_"},{"type":4,"line":"符合该正则表达式序列的是一个以八进制方式来表达的字符"},{"type":4,"line":"_\\\\x\\[0-9A-Fa-f\\]{1,2}_"},{"type":4,"line":"符合该正则表达式序列的是一个以十六进制方式来表达的字符"},{"type":4,"line":"和单引号字符串一样，转义任何其它字符都会导致反斜线被显示出来。PHP 5.1.1 以前，_\\\\{$var}_ 中的反斜线还不会被显示出来。"},{"type":4,"line":"用双引号定义的字符串最重要的特征是变量会被解析，详见[变量解析](language.types.string.html#language.types.string.parsing)。"},{"type":4,"line":"#### Heredoc 结构"},{"type":4,"line":"第三种表达字符串的方法是用 heredoc 句法结构：_<<<_。在该运算符之后要提供一个标识符，然后换行。接下来是字符串 [string](language.types.string.html) 本身，最后要用前面定义的标识符作为结束标志。"},{"type":4,"line":"结束时所引用的标识符_必须_在该行的第一列，而且，标识符的命名也要像其它标签一样遵守 PHP 的规则：只能包含字母、数字和下划线，并且必须以字母和下划线作为开头。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"要注意的是结束标识符这行除了_可能_有一个分号（_;_）外，绝对不能包含其它字符。这意味着标识符_不能缩进_，分号的前后也不能有任何空白或制表符。更重要的是结束标识符的前面必须是个被本地操作系统认可的换行，比如在 UNIX 和 Mac OS X 系统中是 _\\\\n_，而结束定界符（可能其后有个分号）之后也必须紧跟一个换行。"},{"type":4,"line":"如果不遵守该规则导致结束标识不“干净”，PHP 将认为它不是结束标识符而继续寻找。如果在文件结束前也没有找到一个正确的结束标识符，PHP 将会在最后一行产生一个解析错误。"},{"type":4,"line":"Heredocs 结构不能用来初始化类的属性。自 PHP 5.3 起，此限制仅对 heredoc 包含变量时有效。"},{"type":4,"line":"**Example #1 非法的示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class foo {  "},{"type":4,"line":"    public $bar = <<<EOT  "},{"type":5,"line":"bar  "},{"type":4,"line":"    EOT;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"Heredoc 结构就象是没有使用双引号的双引号字符串，这就是说在 heredoc 结构中单引号不用被转义，但是上文中列出的转义序列还可以使用。变量将被替换，但在 heredoc 结构中含有复杂的变量时要格外小心。"},{"type":4,"line":"**Example #2 Heredoc 结构的字符串示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$str = <<<EOD  "},{"type":4,"line":"Example of string  "},{"type":4,"line":"spanning multiple lines  "},{"type":4,"line":"using heredoc syntax.  "},{"type":4,"line":"EOD;  "},{"type":4,"line":"  "},{"type":4,"line":"/* 含有变量的更复杂示例 */  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    var $foo;  "},{"type":4,"line":"    var $bar;  "},{"type":5,"line":"  "},{"type":5,"line":"    function foo()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->foo = 'Foo';  "},{"type":5,"line":"        $this->bar = array('Bar1', 'Bar2', 'Bar3');  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new foo();  "},{"type":4,"line":"$name = 'MyName';  "},{"type":4,"line":"  "},{"type":4,"line":"echo <<<EOT  "},{"type":4,"line":"My name is \"$name\". I am printing some $foo->foo.  "},{"type":4,"line":"Now, I am printing some {$foo->bar[1]}.  "},{"type":4,"line":"This should print a capital 'A': \\x41  "},{"type":4,"line":"EOT;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"My name is \"MyName\". I am printing some Foo."},{"type":4,"line":"Now, I am printing some Bar2."},{"type":4,"line":"This should print a capital 'A': A"},{"type":4,"line":"也可以把 Heredoc 结构用在函数参数中来传递数据："},{"type":4,"line":"**Example #3 Heredoc 结构在参数中的示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"var_dump(array(<<<EOD  "},{"type":4,"line":"foobar!  "},{"type":4,"line":"EOD  "},{"type":4,"line":"));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在 PHP 5.3.0 以后，也可以用 Heredoc 结构来初始化静态变量和类的属性和常量："},{"type":4,"line":"**Example #4 使用 Heredoc 结构来初始化静态值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 静态变量  "},{"type":4,"line":"function foo()  "},{"type":5,"line":"{  "},{"type":4,"line":"    static $bar = <<<LABEL  "},{"type":4,"line":"Nothing in here...  "},{"type":4,"line":"LABEL;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 类的常量、属性  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":4,"line":"    const BAR = <<<FOOBAR  "},{"type":4,"line":"Constant example  "},{"type":4,"line":"FOOBAR;  "},{"type":5,"line":"  "},{"type":4,"line":"    public $baz = <<<FOOBAR  "},{"type":4,"line":"Property example  "},{"type":4,"line":"FOOBAR;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"自 PHP 5.3.0 起还可以在 Heredoc 结构中用双引号来声明标识符："},{"type":4,"line":"**Example #5 在 heredoc 结构中使用双引号**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo <<<\"FOOBAR\"  "},{"type":4,"line":"Hello World!  "},{"type":4,"line":"FOOBAR;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"#### Nowdoc 结构"},{"type":4,"line":"就象 heredoc 结构类似于双引号字符串，Nowdoc 结构是类似于单引号字符串的。Nowdoc 结构很象 heredoc 结构，但是 nowdoc 中_不进行解析操作_。这种结构很适合用于嵌入 PHP 代码或其它大段文本而无需对其中的特殊字符进行转义。与 SGML 的 _<!\\[CDATA\\[ \\]\\]>_ 结构是用来声明大段的不用解析的文本类似，nowdoc 结构也有相同的特征。"},{"type":4,"line":"一个 nowdoc 结构也用和 heredocs 结构一样的标记 _<<<_， 但是跟在后面的标识符要用单引号括起来，即 _<<<'EOT'_。Heredoc 结构的所有规则也同样适用于 nowdoc 结构，尤其是结束标识符的规则。"},{"type":4,"line":"**Example #6 Nowdoc 结构字符串示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$str = <<<'EOD'  "},{"type":4,"line":"Example of string  "},{"type":4,"line":"spanning multiple lines  "},{"type":4,"line":"using nowdoc syntax.  "},{"type":4,"line":"EOD;  "},{"type":4,"line":"  "},{"type":4,"line":"/* 含有变量的更复杂的示例 */  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $foo;  "},{"type":4,"line":"    public $bar;  "},{"type":5,"line":"  "},{"type":5,"line":"    function foo()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->foo = 'Foo';  "},{"type":5,"line":"        $this->bar = array('Bar1', 'Bar2', 'Bar3');  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new foo();  "},{"type":4,"line":"$name = 'MyName';  "},{"type":4,"line":"  "},{"type":4,"line":"echo <<<'EOT'  "},{"type":4,"line":"My name is \"$name\". I am printing some $foo->foo.  "},{"type":4,"line":"Now, I am printing some {$foo->bar[1]}.  "},{"type":4,"line":"This should not print a capital 'A': \\x41  "},{"type":4,"line":"EOT;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"My name is \"$name\". I am printing some $foo->foo."},{"type":4,"line":"Now, I am printing some {$foo->bar\\[1\\]}."},{"type":4,"line":"This should not print a capital 'A': \\\\x41"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 不象 heredoc 结构，nowdoc 结构可以用在任意的静态数据环境中，最典型的示例是用来初始化类的属性或常量："},{"type":4,"line":"> "},{"type":4,"line":"> **Example #7 静态数据的示例**"},{"type":4,"line":"> "},{"type":4,"line":" "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> class foo {  "},{"type":4,"line":">     public $bar = <<<'EOT'  "},{"type":4,"line":"> bar  "},{"type":4,"line":"> EOT;  "},{"type":4,"line":"> }  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> Nowdoc 结构是在 PHP 5.3.0 中加入的。"},{"type":4,"line":"#### 变量解析"},{"type":4,"line":"当字符串用双引号或 heredoc 结构定义时，其中的[变量](language.variables.html)将会被解析。"},{"type":4,"line":"这里共有两种语法规则：一种[简单](language.types.string.html#language.types.string.parsing.simple)规则，一种[复杂](language.types.string.html#language.types.string.parsing.complex)规则。简单的语法规则是最常用和最方便的，它可以用最少的代码在一个 [string](language.types.string.html) 中嵌入一个变量，一个 [array](language.types.array.html) 的值，或一个 [object](language.types.object.html) 的属性。"},{"type":4,"line":"复杂规则语法的显著标记是用花括号包围的表达式。"},{"type":4,"line":"##### 简单语法"},{"type":4,"line":"当 PHP 解析器遇到一个美元符号（_$_）时，它会和其它很多解析器一样，去组合尽量多的标识以形成一个合法的变量名。可以用花括号来明确变量名的界线。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$juice = \"apple\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"He drank some $juice juice.\".PHP_EOL;  "},{"type":4,"line":"// Invalid. \"s\" is a valid character for a variable name, but the variable is $juice.  "},{"type":4,"line":"echo \"He drank some juice made of $juices.\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"He drank some apple juice."},{"type":4,"line":"He drank some juice made of ."},{"type":4,"line":"类似的，一个 [array](language.types.array.html) 索引或一个 [object](language.types.object.html) 属性也可被解析。数组索引要用方括号（_\\]_）来表示索引结束的边际，对象属性则是和上述的变量规则相同。"},{"type":4,"line":"**Example #8 简单语法示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$juices = array(\"apple\", \"orange\", \"koolaid1\" => \"purple\");  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"He drank some $juices[0] juice.\".PHP_EOL;  "},{"type":4,"line":"echo \"He drank some $juices[1] juice.\".PHP_EOL;  "},{"type":4,"line":"echo \"He drank some juice made of $juice[0]s.\".PHP_EOL; // Won't work  "},{"type":4,"line":"echo \"He drank some $juices[koolaid1] juice.\".PHP_EOL;  "},{"type":4,"line":"  "},{"type":5,"line":"class people {  "},{"type":5,"line":"    public $john = \"John Smith\";  "},{"type":5,"line":"    public $jane = \"Jane Smith\";  "},{"type":5,"line":"    public $robert = \"Robert Paulsen\";  "},{"type":5,"line":"      "},{"type":4,"line":"    public $smith = \"Smith\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$people = new people();  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"$people->john drank some $juices[0] juice.\".PHP_EOL;  "},{"type":4,"line":"echo \"$people->john then said hello to $people->jane.\".PHP_EOL;  "},{"type":4,"line":"echo \"$people->john's wife greeted $people->robert.\".PHP_EOL;  "},{"type":4,"line":"echo \"$people->robert greeted the two $people->smiths.\"; // Won't work  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"He drank some apple juice."},{"type":4,"line":"He drank some orange juice."},{"type":4,"line":"He drank some juice made of s."},{"type":4,"line":"He drank some purple juice."},{"type":4,"line":"John Smith drank some apple juice."},{"type":4,"line":"John Smith then said hello to Jane Smith."},{"type":4,"line":"John Smith's wife greeted Robert Paulsen."},{"type":4,"line":"Robert Paulsen greeted the two ."},{"type":4,"line":"如果想要表达更复杂的结构，请用复杂语法。"},{"type":4,"line":"##### 复杂（花括号）语法"},{"type":4,"line":"复杂语法不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式。"},{"type":4,"line":"任何具有 [string](language.types.string.html) 表达的标量变量，数组单元或对象属性都可使用此语法。只需简单地像在 [string](language.types.string.html) 以外的地方那样写出表达式，然后用花括号 _{_ 和 _}_ 把它括起来即可。由于 _{_ 无法被转义，只有 _$_ 紧挨着 _{_ 时才会被识别。可以用 _{\\\\$_ 来表达 _{$_。下面的示例可以更好的解释："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 显示所有错误  "},{"type":4,"line":"error_reporting(E_ALL);  "},{"type":4,"line":"  "},{"type":4,"line":"$great = 'fantastic';  "},{"type":4,"line":"  "},{"type":4,"line":"// 无效，输出: This is { fantastic}  "},{"type":4,"line":"echo \"This is { $great}\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 有效，输出： This is fantastic  "},{"type":4,"line":"echo \"This is {$great}\";  "},{"type":4,"line":"echo \"This is ${great}\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 有效  "},{"type":4,"line":"echo \"This square is {$square->width}00 centimeters broad.\";   "},{"type":4,"line":"  "},{"type":4,"line":"// 有效，只有通过花括号语法才能正确解析带引号的键名  "},{"type":4,"line":"echo \"This works: {$arr['key']}\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 有效  "},{"type":4,"line":"echo \"This works: {$arr[4][3]}\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 这是错误的表达式，因为就象 $foo[bar] 的格式在字符串以外也是错的一样。  "},{"type":4,"line":"// 换句话说，只有在 PHP 能找到常量 foo 的前提下才会正常工作；这里会产生一个  "},{"type":4,"line":"// E_NOTICE (undefined constant) 级别的错误。  "},{"type":4,"line":"echo \"This is wrong: {$arr[foo][3]}\";   "},{"type":4,"line":"  "},{"type":4,"line":"// 有效，当在字符串中使用多重数组时，一定要用括号将它括起来  "},{"type":4,"line":"echo \"This works: {$arr['foo'][3]}\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 有效  "},{"type":4,"line":"echo \"This works: \" . $arr['foo'][3];  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"This works too: {$obj->values[3]->name}\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"This is the value of the var named $name: {${$name}}\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"This is the value of the var named by the return value of getName(): {${getName()}}\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"This is the value of the var named by the return value of \\$object->getName(): {${$object->getName()}}\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 无效，输出： This is the return value of getName(): {getName()}  "},{"type":4,"line":"echo \"This is the return value of getName(): {getName()}\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"也可以在字符串中用此语法通过变量来调用类的属性。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class foo {  "},{"type":4,"line":"    var $bar = 'I am bar.';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new foo();  "},{"type":4,"line":"$bar = 'bar';  "},{"type":4,"line":"$baz = array('foo', 'bar', 'baz', 'quux');  "},{"type":4,"line":"echo \"{$foo->$bar}\\n\";  "},{"type":4,"line":"echo \"{$foo->{$baz[1]}}\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"  "},{"type":4,"line":"I am bar.  "},{"type":4,"line":"I am bar.  "},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 函数、方法、静态类变量和类常量只有在 PHP 5 以后才可在 _{$}_ 中使用。然而，只有在该字符串被定义的命名空间中才可以将其值作为变量名来访问。只单一使用花括号 (_{}_) 无法处理从函数或方法的返回值或者类常量以及类静态变量的值。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 显示所有错误  "},{"type":4,"line":"error_reporting(E_ALL);  "},{"type":4,"line":"  "},{"type":5,"line":"class beers {  "},{"type":5,"line":"    const softdrink = 'rootbeer';  "},{"type":4,"line":"    public static $ale = 'ipa';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$rootbeer = 'A & W';  "},{"type":4,"line":"$ipa = 'Alexander Keith\\'s';  "},{"type":4,"line":"  "},{"type":4,"line":"// 有效，输出： I'd like an A & W  "},{"type":4,"line":"echo \"I'd like an {${beers::softdrink}}\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"// 也有效，输出： I'd like an Alexander Keith's  "},{"type":4,"line":"echo \"I'd like an {${beers::$ale}}\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"#### 存取和修改字符串中的字符"},{"type":4,"line":"[string](language.types.string.html) 中的字符可以通过一个从 0 开始的下标，用类似 [array](language.types.array.html) 结构中的方括号包含对应的数字来访问和修改，比如 $str\\[42\\]。可以把 [string](language.types.string.html) 当成字符组成的 [array](language.types.array.html)。函数 [substr()](function.substr.html) 和 [substr\\_replace()](function.substr-replace.html) 可用于操作多于一个字符的情况。"},{"type":4,"line":"> **Note**: [string](language.types.string.html) 也可用花括号访问，比如 $str{42}。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"用超出字符串长度的下标写入将会拉长该字符串并以空格填充。非整数类型下标会被转换成整数。非法下标类型会产生一个 **`E_NOTICE`** 级别错误。用负数下标写入字符串时会产生一个 **`E_NOTICE`** 级别错误，用负数下标读取字符串时返回空字符串。写入时只用到了赋值字符串的第一个字符。用空字符串赋值则赋给的值是 NULL 字符。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"PHP 的字符串在内部是字节组成的数组。因此用花括号访问或修改字符串对多字节字符集很不安全。仅应对单字节编码例如 ISO-8859-1 的字符串进行此类操作。"},{"type":4,"line":"**Example #9 一些字符串示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 取得字符串的第一个字符  "},{"type":4,"line":"$str = 'This is a test.';  "},{"type":4,"line":"$first = $str[0];  "},{"type":4,"line":"  "},{"type":4,"line":"// 取得字符串的第三个字符  "},{"type":4,"line":"$third = $str[2];  "},{"type":4,"line":"  "},{"type":4,"line":"// 取得字符串的最后一个字符  "},{"type":4,"line":"$str = 'This is still a test.';  "},{"type":4,"line":"$last = $str[strlen($str)-1];   "},{"type":4,"line":"  "},{"type":4,"line":"// 修改字符串的最后一个字符  "},{"type":4,"line":"$str = 'Look at the sea';  "},{"type":4,"line":"$str[strlen($str)-1] = 'e';  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"自 PHP 5.4 起字符串下标必须为整数或可转换为整数的字符串，否则会发出警告。之前类似 _\"foo\"_ 的下标会无声地转换成 _0_。"},{"type":4,"line":"**Example #10 PHP 5.3 和 PHP 5.4 的区别**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$str = 'abc';  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($str['1']);  "},{"type":4,"line":"var_dump(isset($str['1']));  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($str['1.0']);  "},{"type":4,"line":"var_dump(isset($str['1.0']));  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($str['x']);  "},{"type":4,"line":"var_dump(isset($str['x']));  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($str['1x']);  "},{"type":4,"line":"var_dump(isset($str['1x']));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程在PHP 5.3中的输出："},{"type":4,"line":"string(1) \"b\""},{"type":4,"line":"bool(true)"},{"type":4,"line":"string(1) \"b\""},{"type":4,"line":"bool(true)"},{"type":4,"line":"string(1) \"a\""},{"type":4,"line":"bool(true)"},{"type":4,"line":"string(1) \"b\""},{"type":4,"line":"bool(true)"},{"type":4,"line":"以上例程在PHP 5.4中的输出："},{"type":4,"line":"string(1) \"b\""},{"type":4,"line":"bool(true)"},{"type":4,"line":"Warning: Illegal string offset '1.0' in /tmp/t.php on line 7"},{"type":4,"line":"string(1) \"b\""},{"type":4,"line":"bool(false)"},{"type":4,"line":"Warning: Illegal string offset 'x' in /tmp/t.php on line 9"},{"type":4,"line":"string(1) \"a\""},{"type":4,"line":"bool(false)"},{"type":4,"line":"string(1) \"b\""},{"type":4,"line":"bool(false)"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 用 _\\[\\]_ 或 _{}_ 访问任何其它类型（不包括数组或具有相应接口的对象实现）的变量只会无声地返回 **`NULL`**。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> PHP 5.5 增加了直接在字符串原型中用 _\\[\\]_ 或 _{}_ 访问字符的支持。"},{"type":4,"line":"### 有用的函数和运算符"},{"type":4,"line":"字符串可以用 '.'（点）运算符连接起来，注意 '+'（加号）运算符_没有_这个功能。更多信息参考[字符串运算符](language.operators.string.html)。"},{"type":4,"line":"对于 [string](language.types.string.html) 的操作有很多有用的函数。"},{"type":4,"line":"可以参考[字符串函数](ref.strings.html)了解大部分函数，高级的查找与替换功能可以参考[正则表达式函数](ref.regex.html)或 [Perl 兼容正则表达式函数](ref.pcre.html)。"},{"type":4,"line":"另外还有 [URL 字符串函数](ref.url.html)，也有加密／解密字符串的函数（[mcrypt](ref.mcrypt.html) 和 [mhash](ref.mhash.html)）。"},{"type":4,"line":"最后，可以参考[字符类型函数](ref.ctype.html)。"},{"type":4,"line":"### 转换成字符串"},{"type":4,"line":"一个值可以通过在其前面加上 _(string)_ 或用 [strval()](function.strval.html) 函数来转变成字符串。在一个需要字符串的表达式中，会自动转换为 [string](language.types.string.html)。比如在使用函数 [echo](function.echo.html) 或 [print](function.print.html) 时，或在一个变量和一个 [string](language.types.string.html) 进行比较时，就会发生这种转换。[类型](language.types.html)和[类型转换](language.types.type-juggling.html)可以更好的解释下面的事情，也可参考函数 [settype()](function.settype.html)。"},{"type":4,"line":"一个布尔值 [boolean](language.types.boolean.html) 的 **`TRUE`** 被转换成 [string](language.types.string.html) 的 _\"1\"_。[Boolean](language.types.boolean.html) 的 **`FALSE`** 被转换成 _\"\"_（空字符串）。这种转换可以在 [boolean](language.types.boolean.html) 和 [string](language.types.string.html) 之间相互进行。"},{"type":4,"line":"一个整数 [integer](language.types.integer.html) 或浮点数 [float](language.types.float.html) 被转换为数字的字面样式的 [string](language.types.string.html)（包括 [float](language.types.float.html) 中的指数部分）。使用指数计数法的浮点数（_4.1E+6_）也可转换。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在脚本的区域（category LC\\_NUMERIC）中定义了十进制小数点字符。参见 [setlocale()](function.setlocale.html)。"},{"type":4,"line":"数组 [array](language.types.array.html) 总是转换成字符串 _\"Array\"_，因此，[echo](function.echo.html) 和 [print](function.print.html) 无法显示出该数组的内容。要显示某个单元，可以用 _echo $arr\\['foo'\\]_ 这种结构。要显示整个数组内容见下文。"},{"type":4,"line":"在 PHP 4 中对象 [object](language.types.object.html) 总是被转换成字符串 _\"Object\"_，如果为了调试原因需要打印出对象的值，请继续阅读下文。为了得到对象的类的名称，可以用 [get\\_class()](function.get-class.html) 函数。自 PHP 5 起，适当时可以用 [\\_\\_toString](language.oop5.magic.html) 方法。"},{"type":4,"line":"资源 [resource](language.types.resource.html) 总会被转变成 _\"Resource id #1\"_ 这种结构的字符串，其中的 _1_ 是 PHP 在运行时分配给该 [resource](language.types.resource.html) 的唯一值。不要依赖此结构，可能会有变更。要得到一个 [resource](language.types.resource.html) 的类型，可以用函数 [get\\_resource\\_type()](function.get-resource-type.html)。"},{"type":4,"line":"**`NULL`** 总是被转变成空字符串。"},{"type":4,"line":"如上面所说的，直接把 [array](language.types.array.html)，[object](language.types.object.html) 或 [resource](language.types.resource.html) 转换成 [string](language.types.string.html) 不会得到除了其类型之外的任何有用信息。可以使用函数 [print\\_r()](function.print-r.html) 和 [var\\_dump()](function.var-dump.html) 列出这些类型的内容。"},{"type":4,"line":"大部分的 PHP 值可以转变成 [string](language.types.string.html) 来永久保存，这被称作串行化，可以用函数 [serialize()](function.serialize.html) 来实现。如果 PHP 引擎设定支持 [WDDX](ref.wddx.html)，PHP 值也可被串行化为格式良好的 XML 文本。"},{"type":4,"line":"### 字符串转换为数值"},{"type":4,"line":"当一个字符串被当作一个数值来取值，其结果和类型如下："},{"type":4,"line":"如果该字符串没有包含 '.'，'e' 或 'E' 并且其数字值在整型的范围之内（由 **`PHP_INT_MAX`** 所定义），该字符串将被当成 [integer](language.types.integer.html) 来取值。其它所有情况下都被作为 [float](language.types.float.html) 来取值。"},{"type":4,"line":"该字符串的开始部分决定了它的值。如果该字符串以合法的数值开始，则使用该数值。否则其值为 0（零）。合法数值由可选的正负号，后面跟着一个或多个数字（可能有小数点），再跟着可选的指数部分。指数部分由 'e' 或 'E' 后面跟着一个或多个数字构成。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = 1 + \"10.5\";                // $foo is float (11.5)  "},{"type":4,"line":"$foo = 1 + \"-1.3e3\";              // $foo is float (-1299)  "},{"type":4,"line":"$foo = 1 + \"bob-1.3e3\";           // $foo is integer (1)  "},{"type":4,"line":"$foo = 1 + \"bob3\";                // $foo is integer (1)  "},{"type":4,"line":"$foo = 1 + \"10 Small Pigs\";       // $foo is integer (11)  "},{"type":4,"line":"$foo = 4 + \"10.2 Little Piggies\"; // $foo is float (14.2)  "},{"type":4,"line":"$foo = \"10.0 pigs \" + 1;          // $foo is float (11)  "},{"type":4,"line":"$foo = \"10.0 pigs \" + 1.0;        // $foo is float (11)       "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"更多信息可以参考 Unix 手册中的 strtod(3)。"},{"type":4,"line":"本节中的示例可以通过复制／粘贴到下面的代码中来显示："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo \"\\$foo==$foo; type is \" . gettype ($foo) . \"<br />\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"不要想像在 C 语言中的那样，通过将一个字符转换成整数以得到其代码。使用函数 [ord()](function.ord.html) 和 [chr()](function.chr.html) 实现 ASCII 码和字符间的转换。"},{"type":4,"line":"### 字符串类型详解"},{"type":4,"line":"PHP 中的 [string](language.types.string.html) 的实现方式是一个由字节组成的数组再加上一个整数指明缓冲区长度。并无如何将字节转换成字符的信息，由程序员来决定。字符串由什么值来组成并无限制；特别的，其值为 _0_（“NUL bytes”）的字节可以处于字符串任何位置（不过有几个函数，在本手册中被称为非“二进制安全”的，也许会把 NUL 字节之后的数据全都忽略）。"},{"type":4,"line":"字符串类型的此特性解释了为什么 PHP 中没有单独的“byte”类型 - 已经用字符串来代替了。返回非文本值的函数 - 例如从网络套接字读取的任意数据 - 仍会返回字符串。"},{"type":4,"line":"由于 PHP 并不特别指明字符串的编码，那字符串到底是怎样编码的呢？例如字符串 _\"á\"_ 到底是等于 _\"\\\\xE1\"_（ISO-8859-1），_\"\\\\xC3\\\\xA1\"_（UTF-8，C form），_\"\\\\x61\\\\xCC\\\\x81\"_（UTF-8，D form）还是任何其它可能的表达呢？答案是字符串会被按照该脚本文件相同的编码方式来编码。因此如果一个脚本的编码是 ISO-8859-1，则其中的字符串也会被编码为 ISO-8859-1，以此类推。不过这并不适用于激活了 Zend Multibyte 时；此时脚本可以是以任何方式编码的（明确指定或被自动检测）然后被转换为某种内部编码，然后字符串将被用此方式编码。注意脚本的编码有一些约束（如果激活了 Zend Multibyte 则是其内部编码）- 这意味着此编码应该是 ASCII 的兼容超集，例如 UTF-8 或 ISO-8859-1。不过要注意，依赖状态的编码其中相同的字节值可以用于首字母和非首字母而转换状态，这可能会造成问题。"},{"type":4,"line":"当然了，要做到有用，操作文本的函数必须假定字符串是如何编码的。不幸的是，PHP 关于此的函数有很多变种："},{"type":4,"line":"*   某些函数假定字符串是以单字节编码的，但并不需要将字节解释为特定的字符。例如 [substr()](function.substr.html)，[strpos()](function.strpos.html)，[strlen()](function.strlen.html) 和 [strcmp()](function.strcmp.html)。理解这些函数的另一种方法是它们作用于内存缓冲区，即按照字节和字节下标操作。"},{"type":4,"line":"*   某些函数被传递入了字符串的编码方式，也可能会假定默认无此信息。例如 [htmlentities()](function.htmlentities.html) 和 [mbstring](book.mbstring.html) 扩展中的大部分函数。"},{"type":4,"line":"*   其它函数使用了当前区域（见 [setlocale()](function.setlocale.html)），但是逐字节操作。例如 [strcasecmp()](function.strcasecmp.html)，[strtoupper()](function.strtoupper.html) 和 [ucfirst()](function.ucfirst.html)。这意味着这些函数只能用于单字节编码，而且编码要与区域匹配。例如 _strtoupper(\"á\")_ 在区域设定正确并且 _á_ 是单字节编码时会返回 _\"Á\"_。如果是用 UTF-8 编码则不会返回正确结果，其结果根据当前区域有可能返回损坏的值。"},{"type":4,"line":"*   最后一些函数会假定字符串是使用某特定编码的，通常是 UTF-8。[intl](book.intl.html) 扩展和 [PCRE](book.pcre.html)（上例中仅在使用了 _u_ 修饰符时）扩展中的大部分函数都是这样。尽管这是由于其特殊用途，[utf8\\_decode()](function.utf8-decode.html) 会假定 UTF-8 编码而 [utf8\\_encode()](function.utf8-encode.html) 会假定 ISO-8859-1 编码。"},{"type":4,"line":"最后，要书写能够正确使用 Unicode 的程序依赖于很小心地避免那些可能会损坏数据的函数。要使用来自于 [intl](book.intl.html) 和 [mbstring](book.mbstring.html) 扩展的函数。不过使用能处理 Unicode 编码的函数只是个开始。不管用何种语言提供的函数，最基本的还是了解 Unicode 规格。例如一个程序如果假定只有大写和小写，那可是大错特错。"},{"type":3,"line":"2.6 Array 数组"},{"type":4,"line":"PHP 中的数组实际上是一个有序映射。映射是一种把 _values_ 关联到 _keys_ 的类型。此类型在很多方面做了优化，因此可以把它当成真正的数组，或列表（向量），散列表（是映射的一种实现），字典，集合，栈，队列以及更多可能性。由于数组元素的值也可以是另一个数组，树形结构和多维数组也是允许的。"},{"type":4,"line":"解释这些结构超出了本手册的范围，但对于每种结构至少会提供一个例子。要得到这些结构的更多信息，建议参考有关此广阔主题的其它著作。"},{"type":4,"line":"### 语法"},{"type":4,"line":"#### 定义数组 [array()](function.array.html)"},{"type":4,"line":"可以用 [array()](function.array.html) 语言结构来新建一个数组。它接受任意数量用逗号分隔的 _键（key） => 值（value）_对。"},{"type":5,"line":"array(  key =>  value"},{"type":5,"line":"     , ..."},{"type":4,"line":"     )"},{"type":4,"line":"// 键（key）可是是一个整数 [integer](language.types.integer.html) 或字符串 [string](language.types.string.html)"},{"type":4,"line":"// 值（value）可以是任意类型的值"},{"type":4,"line":"最后一个数组单元之后的逗号可以省略。通常用于单行数组定义中，例如常用 _array(1, 2)_ 而不是 _array(1, 2, )_。对多行数组定义通常保留最后一个逗号，这样要添加一个新单元时更方便。"},{"type":4,"line":"自 5.4 起可以使用短数组定义语法，用 _\\[\\]_ 替代 _array()_。"},{"type":4,"line":"**Example #1 一个简单数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = array(  "},{"type":5,"line":"    \"foo\" => \"bar\",  "},{"type":4,"line":"    \"bar\" => \"foo\",  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"// 自 PHP 5.4 起  "},{"type":5,"line":"$array = [  "},{"type":5,"line":"    \"foo\" => \"bar\",  "},{"type":4,"line":"    \"bar\" => \"foo\",  "},{"type":4,"line":"];  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"key 可以是 [integer](language.types.integer.html) 或者 [string](language.types.string.html)。value 可以是任意类型。"},{"type":4,"line":"此外 key 会有如下的强制转换："},{"type":4,"line":"*   包含有合法整型值的字符串会被转换为整型。例如键名 _\"8\"_ 实际会被储存为 _8_。但是 _\"08\"_ 则不会强制转换，因为其不是一个合法的十进制数值。"},{"type":4,"line":"*   浮点数也会被转换为整型，意味着其小数部分会被舍去。例如键名 _8.7_ 实际会被储存为 _8_。"},{"type":4,"line":"*   布尔值也会被转换成整型。即键名 _true_ 实际会被储存为 _1_ 而键名 _false_ 会被储存为 _0_。"},{"type":4,"line":"*   [Null](language.types.null.html) 会被转换为空字符串，即键名 _null_ 实际会被储存为 _\"\"_。"},{"type":4,"line":"*   数组和对象_不能_被用为键名。坚持这么做会导致警告：_Illegal offset type_。"},{"type":4,"line":"如果在数组定义中多个单元都使用了同一个键名，则只使用了最后一个，之前的都被覆盖了。"},{"type":4,"line":"**Example #2 类型强制与覆盖示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = array(  "},{"type":5,"line":"    1    => \"a\",  "},{"type":5,"line":"    \"1\"  => \"b\",  "},{"type":5,"line":"    1.5  => \"c\",  "},{"type":4,"line":"    true => \"d\",  "},{"type":4,"line":");  "},{"type":4,"line":"var_dump($array);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"array(1) {"},{"type":4,"line":"  \\[1\\]=>"},{"type":4,"line":"  string(1) \"d\""},{"type":4,"line":"}"},{"type":4,"line":"上例中所有的键名都被强制转换为 _1_，则每一个新单元都会覆盖前一个的值，最后剩下的只有一个 _\"d\"_。"},{"type":4,"line":"PHP 数组可以同时含有 [integer](language.types.integer.html) 和 [string](language.types.string.html) 类型的键名，因为 PHP 实际并不区分索引数组和关联数组。"},{"type":4,"line":"如果对给出的值没有指定键名，则取当前最大的整数索引值，而新的键名将是该值加一。如果指定的键名已经有了值，则该值会被覆盖。"},{"type":4,"line":"**Example #3 混合 [integer](language.types.integer.html) 和 [string](language.types.string.html) 键名**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = array(  "},{"type":5,"line":"    \"foo\" => \"bar\",  "},{"type":5,"line":"    \"bar\" => \"foo\",  "},{"type":5,"line":"    100   => -100,  "},{"type":4,"line":"    -100  => 100,  "},{"type":4,"line":");  "},{"type":4,"line":"var_dump($array);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"array(4) {"},{"type":4,"line":"  \\[\"foo\"\\]=>"},{"type":4,"line":"  string(3) \"bar\""},{"type":4,"line":"  \\[\"bar\"\\]=>"},{"type":4,"line":"  string(3) \"foo\""},{"type":4,"line":"  \\[100\\]=>"},{"type":4,"line":"  int(-100)"},{"type":4,"line":"  \\[-100\\]=>"},{"type":4,"line":"  int(100)"},{"type":4,"line":"}"},{"type":4,"line":"key 为可选项。如果未指定，PHP 将自动使用之前用过的最大 [integer](language.types.integer.html) 键名加上 1 作为新的键名。"},{"type":4,"line":"**Example #4 没有键名的索引数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$array = array(\"foo\", \"bar\", \"hallo\", \"world\");  "},{"type":4,"line":"var_dump($array);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"array(4) {"},{"type":4,"line":"  \\[0\\]=>"},{"type":4,"line":"  string(3) \"foo\""},{"type":4,"line":"  \\[1\\]=>"},{"type":4,"line":"  string(3) \"bar\""},{"type":4,"line":"  \\[2\\]=>"},{"type":4,"line":"  string(5) \"hallo\""},{"type":4,"line":"  \\[3\\]=>"},{"type":4,"line":"  string(5) \"world\""},{"type":4,"line":"}"},{"type":4,"line":"还可以只对某些单元指定键名而对其它的空置："},{"type":4,"line":"**Example #5 仅对部分单元指定键名**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = array(  "},{"type":5,"line":"         \"a\",  "},{"type":5,"line":"         \"b\",  "},{"type":5,"line":"    6 => \"c\",  "},{"type":4,"line":"         \"d\",  "},{"type":4,"line":");  "},{"type":4,"line":"var_dump($array);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"array(4) {"},{"type":4,"line":"  \\[0\\]=>"},{"type":4,"line":"  string(1) \"a\""},{"type":4,"line":"  \\[1\\]=>"},{"type":4,"line":"  string(1) \"b\""},{"type":4,"line":"  \\[6\\]=>"},{"type":4,"line":"  string(1) \"c\""},{"type":4,"line":"  \\[7\\]=>"},{"type":4,"line":"  string(1) \"d\""},{"type":4,"line":"}"},{"type":4,"line":"可以看到最后一个值 _\"d\"_ 被自动赋予了键名 _7_。这是由于之前最大的整数键名是 _6_。"},{"type":4,"line":"#### 用方括号语法访问数组单元"},{"type":4,"line":"数组单元可以通过 _array\\[key\\]_ 语法来访问。"},{"type":4,"line":"**Example #6 访问数组单元**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = array(  "},{"type":5,"line":"    \"foo\" => \"bar\",  "},{"type":5,"line":"    42    => 24,  "},{"type":5,"line":"    \"multi\" => array(  "},{"type":5,"line":"         \"dimensional\" => array(  "},{"type":5,"line":"             \"array\" => \"foo\"  "},{"type":5,"line":"         )  "},{"type":4,"line":"    )  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($array[\"foo\"]);  "},{"type":4,"line":"var_dump($array[42]);  "},{"type":4,"line":"var_dump($array[\"multi\"][\"dimensional\"][\"array\"]);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"string(3) \"bar\""},{"type":4,"line":"int(24)"},{"type":4,"line":"string(3) \"foo\""},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 方括号和花括号可以互换使用来访问数组单元（例如 $array\\[42\\] 和 $array{42} 在上例中效果相同）。"},{"type":4,"line":"自 PHP 5.4 起可以用直接对函数或方法调用的结果进行数组解引用，在此之前只能通过一个临时变量。"},{"type":4,"line":"自 PHP 5.5 起可以直接对一个数组原型进行数组解引用。"},{"type":4,"line":"**Example #7 数组解引用**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function getArray() {  "},{"type":4,"line":"    return array(1, 2, 3);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// on PHP 5.4  "},{"type":4,"line":"$secondElement = getArray()[1];  "},{"type":4,"line":"  "},{"type":4,"line":"// previously  "},{"type":4,"line":"$tmp = getArray();  "},{"type":4,"line":"$secondElement = $tmp[1];  "},{"type":4,"line":"  "},{"type":4,"line":"// or  "},{"type":4,"line":"list(, $secondElement) = getArray();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 试图访问一个未定义的数组键名与访问任何未定义变量一样：会导致 **`E_NOTICE`** 级别错误信息，其结果为 **`NULL`**。"},{"type":4,"line":"#### 用方括号的语法新建／修改"},{"type":4,"line":"可以通过明示地设定其中的值来修改一个已有数组。"},{"type":4,"line":"这是通过在方括号内指定键名来给数组赋值实现的。也可以省略键名，在这种情况下给变量名加上一对空的方括号（_\\[\\]_）。"},{"type":4,"line":"$arr\\[key\\] = value;"},{"type":4,"line":"$arr\\[\\] = value;"},{"type":4,"line":"// key 可以是 [integer](language.types.integer.html) 或 [string](language.types.string.html)"},{"type":4,"line":"// value 可以是任意类型的值"},{"type":4,"line":"如果 $arr 还不存在，将会新建一个，这也是另一种新建数组的方法。不过并不鼓励这样做，因为如果 $arr 已经包含有值（例如来自请求变量的 [string](language.types.string.html)）则此值会保留而 _\\[\\]_ 实际上代表着[字符串访问运算符](language.types.string.html#language.types.string.substr)。初始化变量的最好方式是直接给其赋值。。"},{"type":4,"line":"要修改某个值，通过其键名给该单元赋一个新值。要删除某键值对，对其调用 [unset()](function.unset.html) 函数。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$arr = array(5 => 1, 12 => 2);  "},{"type":4,"line":"  "},{"type":5,"line":"$arr[] = 56;    // This is the same as $arr[13] = 56;  "},{"type":4,"line":"                // at this point of the script  "},{"type":4,"line":"  "},{"type":5,"line":"$arr[\"x\"] = 42; // This adds a new element to  "},{"type":5,"line":"                // the array with key \"x\"  "},{"type":4,"line":"                  "},{"type":4,"line":"unset($arr[5]); // This removes the element from the array  "},{"type":4,"line":"  "},{"type":4,"line":"unset($arr);    // This deletes the whole array  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如上所述，如果给出方括号但没有指定键名，则取当前最大整数索引值，新的键名将是该值加上 1（但是最小为 0）。如果当前还没有整数索引，则键名将为 _0_。"},{"type":4,"line":"> "},{"type":4,"line":"> 注意这里所使用的最大整数键名_不一定_当前就在数组中。它只要在上次数组重新生成索引后曾经存在过就行了。以下面的例子来说明："},{"type":4,"line":"> "},{"type":4,"line":" "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> // 创建一个简单的数组  "},{"type":4,"line":"> $array = array(1, 2, 3, 4, 5);  "},{"type":4,"line":"> print_r($array);  "},{"type":4,"line":">   "},{"type":4,"line":"> // 现在删除其中的所有元素，但保持数组本身不变:  "},{"type":4,"line":"> foreach ($array as $i => $value) {  "},{"type":4,"line":">     unset($array[$i]);  "},{"type":4,"line":"> }  "},{"type":4,"line":"> print_r($array);  "},{"type":4,"line":">   "},{"type":4,"line":"> // 添加一个单元（注意新的键名是 5，而不是你可能以为的 0）  "},{"type":4,"line":"> $array[] = 6;  "},{"type":4,"line":"> print_r($array);  "},{"type":4,"line":">   "},{"type":4,"line":"> // 重新索引：  "},{"type":4,"line":"> $array = array_values($array);  "},{"type":4,"line":"> $array[] = 7;  "},{"type":4,"line":"> print_r($array);  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"> "},{"type":4,"line":"> 以上例程会输出："},{"type":4,"line":"> "},{"type":4,"line":"> Array"},{"type":4,"line":"> ("},{"type":4,"line":">     \\[0\\] => 1"},{"type":4,"line":">     \\[1\\] => 2"},{"type":4,"line":">     \\[2\\] => 3"},{"type":4,"line":">     \\[3\\] => 4"},{"type":4,"line":">     \\[4\\] => 5"},{"type":4,"line":"> )"},{"type":4,"line":"> Array"},{"type":4,"line":"> ("},{"type":4,"line":"> )"},{"type":4,"line":"> Array"},{"type":4,"line":"> ("},{"type":4,"line":">     \\[5\\] => 6"},{"type":4,"line":"> )"},{"type":4,"line":"> Array"},{"type":4,"line":"> ("},{"type":4,"line":">     \\[0\\] => 6"},{"type":4,"line":">     \\[1\\] => 7"},{"type":4,"line":"> )"},{"type":4,"line":"### 实用函数"},{"type":4,"line":"有很多操作数组的函数，参见[数组函数](ref.array.html)一节。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> [unset()](function.unset.html) 函数允许删除数组中的某个键。但要注意数组将_不会_重建索引。如果需要删除后重建索引，可以用 [array\\_values()](function.array-values.html) 函数。"},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":" $a = array(1 => 'one', 2 => 'two', 3 => 'three');  "},{"type":4,"line":" unset($a[2]);  "},{"type":5,"line":" /* will produce an array that would have been defined as  "},{"type":5,"line":"    $a = array(1 => 'one', 3 => 'three');  "},{"type":5,"line":"    and NOT  "},{"type":4,"line":"    $a = array(1 => 'one', 2 =>'three');  "},{"type":5,"line":" */  "},{"type":4,"line":"   "},{"type":4,"line":" $b = array_values($a);  "},{"type":4,"line":" // Now $b is array(0 => 'one', 1 =>'three')  "},{"type":4,"line":" ?>"},{"type":4,"line":"```"},{"type":4,"line":"[foreach](control-structures.foreach.html) 控制结构是专门用于数组的。它提供了一个简单的方法来遍历数组。"},{"type":4,"line":"### 数组做什么和不做什么"},{"type":4,"line":"#### 为什么 _$foo\\[bar\\]_ 错了？"},{"type":4,"line":"应该始终在用字符串表示的数组索引上加上引号。例如用 _$foo\\['bar'\\]_ 而不是 _$foo\\[bar\\]_。但是为什么呢？可能在老的脚本中见过如下语法："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo[bar] = 'enemy';  "},{"type":4,"line":"echo $foo[bar];  "},{"type":4,"line":"// etc  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这样是错的，但可以正常运行。那么为什么错了呢？原因是此代码中有一个未定义的常量（bar）而不是字符串（'bar'－注意引号），而 PHP 可能会在以后定义此常量，不幸的是你的代码中有同样的名字。它能运行，是因为 PHP 自动将_裸字符串_（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。例如，如果没有常量定义为 **`bar`**，PHP 将把它替代为 _'bar'_ 并使用之。"},{"type":4,"line":"> **Note**: 这并不意味着_总是_给键名加上引号。用不着给键名为[常量](language.constants.html)或[变量](language.variables.html)的加上引号，否则会使 PHP 不能解析它们。"},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":" error_reporting(E_ALL);  "},{"type":4,"line":" ini_set('display_errors', true);  "},{"type":4,"line":" ini_set('html_errors', false);  "},{"type":4,"line":" // Simple array:  "},{"type":4,"line":" $array = array(1, 2);  "},{"type":4,"line":" $count = count($array);  "},{"type":5,"line":" for ($i = 0; $i < $count; $i++) {  "},{"type":5,"line":"     echo \"\\nChecking $i: \\n\";  "},{"type":5,"line":"     echo \"Bad: \" . $array['$i'] . \"\\n\";  "},{"type":5,"line":"     echo \"Good: \" . $array[$i] . \"\\n\";  "},{"type":5,"line":"     echo \"Bad: {$array['$i']}\\n\";  "},{"type":4,"line":"     echo \"Good: {$array[$i]}\\n\";  "},{"type":4,"line":" }  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> "},{"type":4,"line":"> 以上例程会输出："},{"type":4,"line":"> "},{"type":4,"line":"> Checking 0: "},{"type":4,"line":"> Notice: Undefined index:  $i in /path/to/script.html on line 9"},{"type":4,"line":"> Bad: "},{"type":4,"line":"> Good: 1"},{"type":4,"line":"> Notice: Undefined index:  $i in /path/to/script.html on line 11"},{"type":4,"line":"> Bad: "},{"type":4,"line":"> Good: 1"},{"type":4,"line":"> "},{"type":4,"line":"> Checking 1: "},{"type":4,"line":"> Notice: Undefined index:  $i in /path/to/script.html on line 9"},{"type":4,"line":"> Bad: "},{"type":4,"line":"> Good: 2"},{"type":4,"line":"> Notice: Undefined index:  $i in /path/to/script.html on line 11"},{"type":4,"line":"> Bad: "},{"type":4,"line":"> Good: 2"},{"type":4,"line":"演示此行为的更多例子："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Show all errors  "},{"type":4,"line":"error_reporting(E_ALL);  "},{"type":4,"line":"  "},{"type":4,"line":"$arr = array('fruit' => 'apple', 'veggie' => 'carrot');  "},{"type":4,"line":"  "},{"type":4,"line":"// Correct  "},{"type":4,"line":"print $arr['fruit'];  // apple  "},{"type":4,"line":"print $arr['veggie']; // carrot  "},{"type":4,"line":"  "},{"type":4,"line":"// Incorrect.  This works but also throws a PHP error of level E_NOTICE because  "},{"type":4,"line":"// of an undefined constant named fruit  "},{"type":4,"line":"//   "},{"type":4,"line":"// Notice: Use of undefined constant fruit - assumed 'fruit' in...  "},{"type":4,"line":"print $arr[fruit];    // apple  "},{"type":4,"line":"  "},{"type":4,"line":"// This defines a constant to demonstrate what's going on.  The value 'veggie'  "},{"type":4,"line":"// is assigned to a constant named fruit.  "},{"type":4,"line":"define('fruit', 'veggie');  "},{"type":4,"line":"  "},{"type":4,"line":"// Notice the difference now  "},{"type":4,"line":"print $arr['fruit'];  // apple  "},{"type":4,"line":"print $arr[fruit];    // carrot  "},{"type":4,"line":"  "},{"type":4,"line":"// The following is okay, as it's inside a string. Constants are not looked for  "},{"type":4,"line":"// within strings, so no E_NOTICE occurs here  "},{"type":4,"line":"print \"Hello $arr[fruit]\";      // Hello apple  "},{"type":4,"line":"  "},{"type":4,"line":"// With one exception: braces surrounding arrays within strings allows constants  "},{"type":4,"line":"// to be interpreted  "},{"type":4,"line":"print \"Hello {$arr[fruit]}\";    // Hello carrot  "},{"type":4,"line":"print \"Hello {$arr['fruit']}\";  // Hello apple  "},{"type":4,"line":"  "},{"type":4,"line":"// This will not work, and will result in a parse error, such as:  "},{"type":4,"line":"// Parse error: parse error, expecting T_STRING' or T_VARIABLE' or T_NUM_STRING'  "},{"type":4,"line":"// This of course applies to using superglobals in strings as well  "},{"type":4,"line":"print \"Hello $arr['fruit']\";  "},{"type":4,"line":"print \"Hello $_GET['foo']\";  "},{"type":4,"line":"  "},{"type":4,"line":"// Concatenation is another option  "},{"type":4,"line":"print \"Hello \" . $arr['fruit']; // Hello apple  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当打开 [error\\_reporting](errorfunc.configuration.html#ini.error-reporting) 来显示 **`E_NOTICE`** 级别的错误（将其设为 **`E_ALL`**）时将看到这些错误。默认情况下 [error\\_reporting](errorfunc.configuration.html#ini.error-reporting) 被关闭不显示这些。"},{"type":4,"line":"和在[语法](language.types.array.html#language.types.array.syntax)一节中规定的一样，在方括号（“_\\[_”和“_\\]_”）之间必须有一个表达式。这意味着可以这样写："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo $arr[somefunc($bar)];  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这是一个用函数返回值作为数组索引的例子。PHP 也可以用已知常量，可能之前已经见过："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$error_descriptions[E_ERROR]   = \"A fatal error has occured\";  "},{"type":4,"line":"$error_descriptions[E_WARNING] = \"PHP issued a warning\";  "},{"type":4,"line":"$error_descriptions[E_NOTICE]  = \"This is just an informal notice\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"注意 _E\\_ERROR_ 也是个合法的标识符，就和第一个例子中的 _bar_ 一样。但是上一个例子实际上和如下写法是一样的："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$error_descriptions[1] = \"A fatal error has occured\";  "},{"type":4,"line":"$error_descriptions[2] = \"PHP issued a warning\";  "},{"type":4,"line":"$error_descriptions[8] = \"This is just an informal notice\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"因为 _E\\_ERROR_ 等于 _1_，等等。"},{"type":4,"line":"##### 那么为什么这样做不好？"},{"type":4,"line":"也许有一天，PHP 开发小组可能会想新增一个常量或者关键字，或者用户可能希望以后在自己的程序中引入新的常量，那就有麻烦了。例如已经不能这样用 _empty_ 和 _default_ 这两个词了，因为他们是[保留字](reserved.html)。"},{"type":4,"line":"> **Note**: 重申一次，在双引号字符串中，不给索引加上引号是合法的因此 _\"$foo\\[bar\\]\"_ 是合法的（“合法”的原文为 valid。在实际测试中，这么做确实可以访问数组的该元素，但是会报一个常量未定义的 notice。无论如何，强烈建议不要使用 $foo\\[bar\\]这样的写法，而要使用 $foo\\['bar'\\] 来访问数组中元素。--haohappy 注）。至于为什么参见以上的例子和[字符串中的变量解析](language.types.string.html#language.types.string.parsing)中的解释。"},{"type":4,"line":"### 转换为数组"},{"type":4,"line":"对于任意 [integer](language.types.integer.html)，[float](language.types.float.html)，[string](language.types.string.html)，[boolean](language.types.boolean.html) 和 [resource](language.types.resource.html) 类型，如果将一个值转换为数组，将得到一个仅有一个元素的数组，其下标为 0，该元素即为此标量的值。换句话说，_(array)$scalarValue_ 与 _array($scalarValue)_ 完全一样。"},{"type":4,"line":"如果一个 [object](language.types.object.html) 类型转换为 [array](language.types.array.html)，则结果为一个数组，其单元为该对象的属性。键名将为成员变量名，不过有几点例外：整数属性不可访问；私有变量前会加上类名作前缀；保护变量前会加上一个 '\\*' 做前缀。这些前缀的前后都各有一个 NULL 字符。这会导致一些不可预知的行为："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":5,"line":"class A {  "},{"type":4,"line":"    private $A; // This will become '\\0A\\0A'  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class B extends A {  "},{"type":5,"line":"    private $A; // This will become '\\0B\\0A'  "},{"type":4,"line":"    public $AA; // This will become 'AA'  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump((array) new B());  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"上例会有两个键名为 'AA'，不过其中一个实际上是 '\\\\0A\\\\0A'。"},{"type":4,"line":"将 **`NULL`** 转换为 [array](language.types.array.html) 会得到一个空的数组。"},{"type":4,"line":"### 比较"},{"type":4,"line":"可以用 [array\\_diff()](function.array-diff.html) 和[数组运算符](language.operators.array.html)来比较数组。"},{"type":4,"line":"### 示例"},{"type":4,"line":"PHP 中的数组类型有非常多的用途。以下是一些示例："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// This:  "},{"type":5,"line":"$a = array( 'color' => 'red',  "},{"type":5,"line":"            'taste' => 'sweet',  "},{"type":5,"line":"            'shape' => 'round',  "},{"type":5,"line":"            'name'  => 'apple',  "},{"type":5,"line":"            4        // key will be 0  "},{"type":4,"line":"          );  "},{"type":4,"line":"  "},{"type":4,"line":"$b = array('a', 'b', 'c');  "},{"type":4,"line":"  "},{"type":4,"line":"// . . .is completely equivalent with this:  "},{"type":4,"line":"$a = array();  "},{"type":4,"line":"$a['color'] = 'red';  "},{"type":4,"line":"$a['taste'] = 'sweet';  "},{"type":4,"line":"$a['shape'] = 'round';  "},{"type":4,"line":"$a['name']  = 'apple';  "},{"type":4,"line":"$a[]        = 4;        // key will be 0  "},{"type":4,"line":"  "},{"type":4,"line":"$b = array();  "},{"type":4,"line":"$b[] = 'a';  "},{"type":4,"line":"$b[] = 'b';  "},{"type":4,"line":"$b[] = 'c';  "},{"type":4,"line":"  "},{"type":4,"line":"// After the above code is executed, $a will be the array  "},{"type":4,"line":"// array('color' => 'red', 'taste' => 'sweet', 'shape' => 'round',   "},{"type":4,"line":"// 'name' => 'apple', 0 => 4), and $b will be the array   "},{"type":4,"line":"// array(0 => 'a', 1 => 'b', 2 => 'c'), or simply array('a', 'b', 'c').  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #8 使用 array()**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Array as (property-)map  "},{"type":5,"line":"$map = array( 'version'    => 4,  "},{"type":5,"line":"              'OS'         => 'Linux',  "},{"type":5,"line":"              'lang'       => 'english',  "},{"type":5,"line":"              'short_tags' => true  "},{"type":5,"line":"            );  "},{"type":4,"line":"              "},{"type":4,"line":"// strictly numerical keys  "},{"type":5,"line":"$array = array( 7,  "},{"type":5,"line":"                8,  "},{"type":5,"line":"                0,  "},{"type":5,"line":"                156,  "},{"type":5,"line":"                -10  "},{"type":4,"line":"              );  "},{"type":4,"line":"// this is the same as array(0 => 7, 1 => 8, ...)  "},{"type":4,"line":"  "},{"type":5,"line":"$switching = array(         10, // key = 0  "},{"type":5,"line":"                    5    =>  6,  "},{"type":5,"line":"                    3    =>  7,   "},{"type":5,"line":"                    'a'  =>  4,  "},{"type":5,"line":"                            11, // key = 6 (maximum of integer-indices was 5)  "},{"type":5,"line":"                    '8'  =>  2, // key = 8 (integer!)  "},{"type":5,"line":"                    '02' => 77, // key = '02'  "},{"type":5,"line":"                    0    => 12  // the value 10 will be overwritten by 12  "},{"type":5,"line":"                  );  "},{"type":4,"line":"                    "},{"type":4,"line":"// empty array  "},{"type":4,"line":"$empty = array();           "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #9 集合**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$colors = array('red', 'blue', 'green', 'yellow');  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($colors as $color) {  "},{"type":4,"line":"    echo \"Do you like $color?\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Do you like red?"},{"type":4,"line":"Do you like blue?"},{"type":4,"line":"Do you like green?"},{"type":4,"line":"Do you like yellow?"},{"type":4,"line":"直接改变数组的值自 PHP 5 起可以通过引用传递来做到。之前的版本需要需要采取变通的方法："},{"type":4,"line":"**Example #10 在循环中改变单元**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// PHP 5  "},{"type":5,"line":"foreach ($colors as &$color) {  "},{"type":4,"line":"    $color = strtoupper($color);  "},{"type":4,"line":"}  "},{"type":4,"line":"unset($color); /* ensure that following writes to  "},{"type":4,"line":"$color will not modify the last array element */  "},{"type":4,"line":"  "},{"type":4,"line":"// Workaround for older versions  "},{"type":5,"line":"foreach ($colors as $key => $color) {  "},{"type":4,"line":"    $colors[$key] = strtoupper($color);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"print_r($colors);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Array"},{"type":5,"line":"("},{"type":5,"line":"    \\[0\\] => RED"},{"type":5,"line":"    \\[1\\] => BLUE"},{"type":5,"line":"    \\[2\\] => GREEN"},{"type":4,"line":"    \\[3\\] => YELLOW"},{"type":4,"line":")"},{"type":4,"line":"本例生成一个下标从 1 开始的数组。"},{"type":4,"line":"**Example #11 下标从 1 开始的数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$firstquarter  = array(1 => 'January', 'February', 'March');  "},{"type":4,"line":"print_r($firstquarter);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Array "},{"type":5,"line":"("},{"type":5,"line":"    \\[1\\] => 'January'"},{"type":5,"line":"    \\[2\\] => 'February'"},{"type":4,"line":"    \\[3\\] => 'March'"},{"type":4,"line":")"},{"type":4,"line":"**Example #12 填充数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// fill an array with all items from a directory  "},{"type":4,"line":"$handle = opendir('.');  "},{"type":5,"line":"while (false !== ($file = readdir($handle))) {  "},{"type":4,"line":"    $files[] = $file;  "},{"type":4,"line":"}  "},{"type":4,"line":"closedir($handle);   "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"数组是有序的。也可以使用不同的排序函数来改变顺序。更多信息参见[数组函数](ref.array.html)。可以用 [count()](function.count.html) 函数来数出数组中元素的个数。"},{"type":4,"line":"**Example #13 数组排序**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"sort($files);  "},{"type":4,"line":"print_r($files);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"因为数组中的值可以为任意值，也可是另一个数组。这样可以产生递归或多维数组。"},{"type":4,"line":"**Example #14 递归和多维数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$fruits = array ( \"fruits\"  => array ( \"a\" => \"orange\",  "},{"type":5,"line":"                                       \"b\" => \"banana\",  "},{"type":5,"line":"                                       \"c\" => \"apple\"  "},{"type":5,"line":"                                     ),  "},{"type":5,"line":"                  \"numbers\" => array ( 1,  "},{"type":5,"line":"                                       2,  "},{"type":5,"line":"                                       3,  "},{"type":5,"line":"                                       4,  "},{"type":5,"line":"                                       5,  "},{"type":5,"line":"                                       6  "},{"type":5,"line":"                                     ),  "},{"type":5,"line":"                  \"holes\"   => array (      \"first\",  "},{"type":5,"line":"                                       5 => \"second\",  "},{"type":5,"line":"                                            \"third\"  "},{"type":5,"line":"                                     )  "},{"type":4,"line":"                );  "},{"type":4,"line":"  "},{"type":4,"line":"// Some examples to address values in the array above   "},{"type":4,"line":"echo $fruits[\"holes\"][5];    // prints \"second\"  "},{"type":4,"line":"echo $fruits[\"fruits\"][\"a\"]; // prints \"orange\"  "},{"type":4,"line":"unset($fruits[\"holes\"][0]);  // remove \"first\"  "},{"type":4,"line":"  "},{"type":4,"line":"// Create a new multi-dimensional array  "},{"type":4,"line":"$juices[\"apple\"][\"green\"] = \"good\";   "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"数组(Array) 的赋值总是会涉及到值的拷贝。使用[引用运算符](language.operators.html)通过引用来拷贝数组。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$arr1 = array(2, 3);  "},{"type":4,"line":"$arr2 = $arr1;  "},{"type":5,"line":"$arr2[] = 4; // $arr2 is changed,  "},{"type":5,"line":"             // $arr1 is still array(2, 3)  "},{"type":4,"line":"               "},{"type":4,"line":"$arr3 = &$arr1;  "},{"type":4,"line":"$arr3[] = 4; // now $arr1 and $arr3 are the same  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"2.7 Object 对象"},{"type":4,"line":"### 对象初始化"},{"type":4,"line":"要创建一个新的对象 [object](language.types.object.html)，使用 _new_ 语句实例化一个类："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    function do_foo()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"Doing foo.\";   "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$bar = new foo;  "},{"type":4,"line":"$bar->do_foo();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"详细讨论参见手册中[类与对象](language.oop5.html)章节。"},{"type":4,"line":"### 转换为对象"},{"type":4,"line":"如果将一个对象转换成对象，它将不会有任何变化。如果其它任何类型的值被转换成对象，将会创建一个内置类 _stdClass_ 的实例。如果该值为 **`NULL`**，则新的实例为空。 [array](language.types.array.html) 转换成 [object](language.types.object.html) 将使键名成为属性名并具有相对应的值。注意：在这个例子里， 使用 PHP 7.2.0 之前的版本，数字键只能通过迭代访问。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$obj = (object) array('1' => 'foo');  "},{"type":4,"line":"var_dump(isset($obj->{'1'})); // PHP 7.2.0 后输出 'bool(true)'，之前版本会输出 'bool(false)'   "},{"type":4,"line":"var_dump(key($obj)); // PHP 7.2.0 后输出 'string(1) \"1\"'，之前版本输出  'int(1)'   "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"对于其他值，会包含进成员变量名 _scalar_。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$obj = (object) 'ciao';  "},{"type":4,"line":"echo $obj->scalar;  // outputs 'ciao'  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"2.8 Resource 资源类型"},{"type":4,"line":"资源 [resource](language.types.resource.html) 是一种特殊变量，保存了到外部资源的一个引用。资源是通过专门的函数来建立和使用的。所有这些函数及其相应资源类型见[附录](resource.html)。"},{"type":4,"line":"参见 [get\\_resource\\_type()](function.get-resource-type.html)。"},{"type":4,"line":"### 转换为资源"},{"type":4,"line":"由于资源类型变量保存有为打开文件、数据库连接、图形画布区域等的特殊句柄，因此将其它类型的值转换为资源没有意义。"},{"type":4,"line":"### 释放资源"},{"type":4,"line":"引用计数系统是 Zend 引擎的一部分，可以自动检测到一个资源不再被引用了（和 Java 一样）。这种情况下此资源使用的所有外部资源都会被垃圾回收系统释放。因此，很少需要手工释放内存。"},{"type":4,"line":"> **Note**: 持久数据库连接比较特殊，它们_不会_被垃圾回收系统销毁。参见[数据库永久连接](features.persistent-connections.html)一章。"},{"type":3,"line":"2.9 NULL"},{"type":4,"line":"特殊的 **`NULL`** 值表示一个变量没有值。[NULL](language.types.null.html) 类型唯一可能的值就是 **`NULL`**。"},{"type":4,"line":"在下列情况下一个变量被认为是 **`NULL`**："},{"type":5,"line":"*   被赋值为 **`NULL`**。"},{"type":4,"line":"    "},{"type":5,"line":"*   尚未被赋值。"},{"type":4,"line":"    "},{"type":5,"line":"*   被 [unset()](function.unset.html)。"},{"type":4,"line":"    "},{"type":4,"line":"### 语法"},{"type":4,"line":"**`NULL`** 类型只有一个值，就是不区分大小写的常量 **`NULL`**。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$var = NULL;         "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见 [is\\_null()](function.is-null.html) 和 [unset()](function.unset.html)。"},{"type":4,"line":"### 转换到 _NULL_"},{"type":4,"line":"使用 _(unset) $var_ 将一个变量转换为 [null](language.types.null.html) 将_不会_删除该变量或 unset 其值。仅是返回 **`NULL`** 值而已。"},{"type":3,"line":"2.10 Callback / Callable 类型"},{"type":4,"line":"自 PHP 5.4 起可用 [callable](language.types.callable.html) 类型指定回调类型 callback。本文档基于同样理由使用 [callback](language.pseudo-types.html#language.types.callback) 类型信息。"},{"type":4,"line":"一些函数如 [call\\_user\\_func()](function.call-user-func.html) 或 [usort()](function.usort.html) 可以接受用户自定义的回调函数作为参数。回调函数不止可以是简单函数，还可以是对象的方法，包括静态类方法。"},{"type":4,"line":"### 传递"},{"type":4,"line":"PHP是将函数以[string](language.types.string.html)形式传递的。 可以使用任何内置或用户自定义函数，但除了语言结构例如：[array()](function.array.html)，[echo](function.echo.html)，[empty()](function.empty.html)，[eval()](function.eval.html)，[exit()](function.exit.html)，[isset()](function.isset.html)，[list()](function.list.html)，[print](function.print.html) 或 [unset()](function.unset.html)。"},{"type":4,"line":"一个已实例化的 [object](language.types.object.html) 的方法被作为 [array](language.types.array.html) 传递，下标 0 包含该 [object](language.types.object.html)，下标 1 包含方法名。 在同一个类里可以访问 protected 和 private 方法。"},{"type":4,"line":"静态类方法也可不经实例化该类的对象而传递，只要在下标 0 中包含类名而不是对象。自 PHP 5.2.3 起，也可以传递 _'ClassName::methodName'_。"},{"type":4,"line":"除了普通的用户自定义函数外，也可传递 [匿名函数](functions.anonymous.html) 给回调参数。"},{"type":4,"line":"**Example #1 回调函数示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php   "},{"type":4,"line":"  "},{"type":4,"line":"// An example callback function  "},{"type":5,"line":"function my_callback_function() {  "},{"type":4,"line":"    echo 'hello world!';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// An example callback method  "},{"type":5,"line":"class MyClass {  "},{"type":5,"line":"    static function myCallbackMethod() {  "},{"type":5,"line":"        echo 'Hello World!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// Type 1: Simple callback  "},{"type":4,"line":"call_user_func('my_callback_function');   "},{"type":4,"line":"  "},{"type":4,"line":"// Type 2: Static class method call  "},{"type":4,"line":"call_user_func(array('MyClass', 'myCallbackMethod'));   "},{"type":4,"line":"  "},{"type":4,"line":"// Type 3: Object method call  "},{"type":4,"line":"$obj = new MyClass();  "},{"type":4,"line":"call_user_func(array($obj, 'myCallbackMethod'));  "},{"type":4,"line":"  "},{"type":4,"line":"// Type 4: Static class method call (As of PHP 5.2.3)  "},{"type":4,"line":"call_user_func('MyClass::myCallbackMethod');  "},{"type":4,"line":"  "},{"type":4,"line":"// Type 5: Relative static class method call (As of PHP 5.3.0)  "},{"type":5,"line":"class A {  "},{"type":5,"line":"    public static function who() {  "},{"type":5,"line":"        echo \"A\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class B extends A {  "},{"type":5,"line":"    public static function who() {  "},{"type":5,"line":"        echo \"B\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"call_user_func(array('B', 'parent::who')); // A  "},{"type":4,"line":"  "},{"type":4,"line":"// Type 6: Objects implementing __invoke can be used as callables (since PHP 5.3)  "},{"type":5,"line":"class C {  "},{"type":5,"line":"    public function __invoke($name) {  "},{"type":5,"line":"        echo 'Hello ', $name, \"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$c = new C();  "},{"type":4,"line":"call_user_func($c, 'PHP!');  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 使用 Closure 的示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Our closure  "},{"type":5,"line":"$double = function($a) {  "},{"type":4,"line":"    return $a * 2;  "},{"type":4,"line":"};  "},{"type":4,"line":"  "},{"type":4,"line":"// This is our range of numbers  "},{"type":4,"line":"$numbers = range(1, 5);  "},{"type":4,"line":"  "},{"type":4,"line":"// Use the closure as a callback here to   "},{"type":4,"line":"// double the size of each element in our   "},{"type":4,"line":"// range  "},{"type":4,"line":"$new_numbers = array_map($double, $numbers);  "},{"type":4,"line":"  "},{"type":4,"line":"print implode(' ', $new_numbers);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"2 4 6 8 10"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在函数中注册有多个回调内容时(如使用 [call\\_user\\_func()](function.call-user-func.html) 与 [call\\_user\\_func\\_array()](function.call-user-func-array.html))，如在前一个回调中有未捕获的异常，其后的将不再被调用。"},{"type":3,"line":"2.11 本文档中使用的伪类型与变量"},{"type":4,"line":"伪类型（pseudo-types） 是 PHP 文档里用于指示参数可以使用的类型和值。 请注意，它们不是 PHP 语言里原生类型。 所以不能把伪类型用于自定义函数里的类型约束（typehint）。"},{"type":4,"line":"### mixed"},{"type":4,"line":"_mixed_ 说明一个参数可以接受多种不同的（但不一定是所有的）类型。"},{"type":4,"line":"例如 [gettype()](function.gettype.html) 可以接受所有的 PHP 类型，[str\\_replace()](function.str-replace.html) 可以接受字符串和数组。"},{"type":4,"line":"### number"},{"type":4,"line":"_number_ 说明一个参数可以是 [integer](language.types.integer.html) 或者 [float](language.types.float.html)。"},{"type":4,"line":"### callback"},{"type":4,"line":"本文档中在 PHP 5.4 引入 [callable](language.types.callable.html) 类型之前使用 了 [callback](language.pseudo-types.html#language.types.callback) 伪类型。二者含义完全相同。"},{"type":4,"line":"### array|object"},{"type":4,"line":"_array|object_ 意思是参数既可以是 [array](language.types.array.html) 也可以是 [object](language.types.object.html)。"},{"type":4,"line":"### void"},{"type":4,"line":"_void_ 作为返回类型意味着函数的返回值是无用的。_void_ 作为参数列表意味着函数不接受任何参数。"},{"type":4,"line":"### ..."},{"type":4,"line":"在函数原型中，`$...` 表示_等等_的意思。当一个函数可以接受任意个参数时使用此变量名。"},{"type":3,"line":"2.12 类型转换的判别"},{"type":4,"line":"PHP 在变量定义中不需要（或不支持）明确的类型定义；变量类型是根据使用该变量的上下文所决定的。也就是说，如果把一个 [string](language.types.string.html) 值赋给变量 $var，$var 就成了一个 [string](language.types.string.html)。如果又把一个[integer](language.types.integer.html) 赋给 $var，那它就成了一个[integer](language.types.integer.html)。"},{"type":4,"line":"PHP 的自动类型转换的一个例子是乘法运算符“\\*”。如果任何一个操作数是[float](language.types.float.html)，则所有的操作数都被当成[float](language.types.float.html)，结果也是[float](language.types.float.html)。否则操作数会被解释为[integer](language.types.integer.html)，结果也是[integer](language.types.integer.html)。注意这并_没有_改变这些操作数本身的类型；改变的仅是这些操作数如何被求值以及表达式本身的类型。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = \"1\";  // $foo 是字符串 (ASCII 49)  "},{"type":4,"line":"$foo *= 2;   // $foo 现在是一个整数 (2)  "},{"type":4,"line":"$foo = $foo * 1.3;  // $foo 现在是一个浮点数 (2.6)  "},{"type":4,"line":"$foo = 5 * \"10 Little Piggies\"; // $foo 是整数 (50)  "},{"type":4,"line":"$foo = 5 * \"10 Small Pigs\";     // $foo 是整数 (50)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"如果上面两个例子看上去古怪的话，参见[字符串转换为数值](language.types.string.html#language.types.string.conversion)。"},{"type":4,"line":"如果要强制将一个变量当作某种类型来求值，参见[类型强制转换](language.types.type-juggling.html#language.types.typecasting)一节。如果要改变一个变量的类型，参见 [settype()](function.settype.html)。"},{"type":4,"line":"如果想要测试本节中任何例子的话，可以用 [var\\_dump()](function.var-dump.html) 函数。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 自动转换为 数组 的行为目前没有定义。"},{"type":4,"line":"> "},{"type":4,"line":"> 此外，由于 PHP 支持使用和数组下标同样的语法访问字符串下标，以下例子在所有 PHP 版本中都有效："},{"type":4,"line":"> "},{"type":4,"line":"> ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> $a    = 'car'; // $a is a string  "},{"type":4,"line":"> $a[0] = 'b';   // $a is still a string  "},{"type":4,"line":"> echo $a;       // bar  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"> "},{"type":4,"line":"> 请参阅[存取和修改字符串中的字符](language.types.string.html#language.types.string.substr)一节以获取更多信息。"},{"type":4,"line":"### 类型强制转换"},{"type":4,"line":"PHP 中的类型强制转换和 C 中的非常像：在要转换的变量之前加上用括号括起来的目标类型。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = 10;   // $foo is an integer  "},{"type":4,"line":"$bar = (boolean) $foo;   // $bar is a boolean  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"允许的强制转换有："},{"type":4,"line":"*   (int), (integer) - 转换为整形 [integer](language.types.integer.html)"},{"type":4,"line":"*   (bool), (boolean) - 转换为布尔类型 [boolean](language.types.boolean.html)"},{"type":4,"line":"*   (float), (double), (real) - 转换为浮点型 [float](language.types.float.html)"},{"type":4,"line":"*   (string) - 转换为字符串 [string](language.types.string.html)"},{"type":4,"line":"*   (array) - 转换为数组 [array](language.types.array.html)"},{"type":4,"line":"*   (object) - 转换为对象 [object](language.types.object.html)"},{"type":4,"line":"*   (unset) - 转换为 [NULL](language.types.null.html) (PHP 5)"},{"type":4,"line":"(binary) 转换和 b 前缀转换支持为 PHP 5.2.1 新增。"},{"type":4,"line":"注意在括号内允许有空格和制表符，所以下面两个例子功能相同："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = (int) $bar;  "},{"type":4,"line":"$foo = ( int ) $bar;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"将字符串文字和变量转换为二进制字符串："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$binary = (binary)$string;  "},{"type":4,"line":"$binary = b\"binary string\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 可以将变量放置在双引号中的方式来代替将变量转换成字符串："},{"type":4,"line":"> "},{"type":4,"line":"> ```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> $foo = 10;            // $foo 是一个整数  "},{"type":4,"line":"> $str = \"$foo\";        // $str 是一个字符串  "},{"type":4,"line":"> $fst = (string) $foo; // $fst 也是一个字符串  "},{"type":4,"line":">   "},{"type":4,"line":"> // 输出 \"they are the same\"  "},{"type":4,"line":"> if ($fst === $str) {  "},{"type":4,"line":">     echo \"they are the same\";  "},{"type":4,"line":"> }  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"有时在类型之间强制转换时确切地会发生什么可能不是很明显。更多信息见如下小节："},{"type":4,"line":"*   [转换为布尔型](language.types.boolean.html#language.types.boolean.casting)"},{"type":4,"line":"*   [转换为整型](language.types.integer.html#language.types.integer.casting)"},{"type":4,"line":"*   [转换为浮点型](language.types.float.html#language.types.float.casting)"},{"type":4,"line":"*   [转换为字符串](language.types.string.html#language.types.string.casting)"},{"type":4,"line":"*   [转换为数组](language.types.array.html#language.types.array.casting)"},{"type":4,"line":"*   [转换为对象](language.types.object.html#language.types.object.casting)"},{"type":4,"line":"*   [转换为资源](language.types.resource.html#language.types.resource.casting)"},{"type":4,"line":"*   [转换为 NULL](language.types.null.html#language.types.null.casting)"},{"type":4,"line":"*   [类型比较表](types.comparisons.html)"},{"type":1,"line":"3. 变量"},{"type":4,"line":"3.1 基础"},{"type":4,"line":"--"},{"type":4,"line":"PHP 中的变量用一个美元符号后面跟变量名来表示。变量名是区分大小写的。"},{"type":4,"line":"变量名与 PHP 中其它的标签一样遵循相同的规则。一个有效的变量名由字母或者下划线开头，后面跟上任意数量的字母，数字，或者下划线。按照正常的正则表达式，它将被表述为：'_\\[a-zA-Z\\_\\\\x7f-\\\\xff\\]\\[a-zA-Z0-9\\_\\\\x7f-\\\\xff\\]\\*_'。"},{"type":4,"line":"> **Note**: 在此所说的字母是 a-z，A-Z，以及 ASCII 字符从 127 到 255（_0x7f-0xff_）。"},{"type":4,"line":"> **Note**: _$this_ 是一个特殊的变量，它不能被赋值。"},{"type":4,"line":"**Tip**"},{"type":4,"line":"请参见[用户空间命名指南](userlandnaming.html)。"},{"type":4,"line":"有关变量的函数信息见[变量函数](ref.var.html)。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$var = 'Bob';  "},{"type":4,"line":"$Var = 'Joe';  "},{"type":4,"line":"echo \"$var, $Var\";      // 输出 \"Bob, Joe\"  "},{"type":4,"line":"  "},{"type":4,"line":"$4site = 'not yet';     // 非法变量名；以数字开头  "},{"type":4,"line":"$_4site = 'not yet';    // 合法变量名；以下划线开头  "},{"type":4,"line":"$i站点is = 'mansikka';  // 合法变量名；可以用中文  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"变量默认总是传值赋值。那也就是说，当将一个表达式的值赋予一个变量时，整个原始表达式的值被赋值到目标变量。这意味着，例如，当一个变量的值赋予另外一个变量时，改变其中一个变量的值，将不会影响到另外一个变量。有关这种类型的赋值操作，请参阅[表达式](language.expressions.html)一章。"},{"type":4,"line":"PHP 也提供了另外一种方式给变量赋值：[引用赋值](language.references.html)。这意味着新的变量简单的引用（换言之，“成为其别名” 或者 “指向”）了原始变量。改动新的变量将影响到原始变量，反之亦然。"},{"type":4,"line":"使用引用赋值，简单地将一个 & 符号加到将要赋值的变量前（源变量）。例如，下列代码片断将输出“My name is Bob”两次："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = 'Bob';              // 将 'Bob' 赋给 $foo  "},{"type":4,"line":"$bar = &$foo;              // 通过 $bar 引用 $foo  "},{"type":4,"line":"$bar = \"My name is $bar\";  // 修改 $bar 变量  "},{"type":4,"line":"echo $bar;  "},{"type":4,"line":"echo $foo;                 // $foo 的值也被修改  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"有一点重要事项必须指出，那就是只有有名字的变量才可以引用赋值。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$foo = 25;  "},{"type":4,"line":"$bar = &$foo;      // 合法的赋值  "},{"type":4,"line":"$bar = &(24 * 7);  // 非法; 引用没有名字的表达式  "},{"type":4,"line":"  "},{"type":4,"line":"function test()  "},{"type":5,"line":"{  "},{"type":4,"line":"   return 25;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$bar = &test();    // 非法  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"虽然在 PHP 中并不需要初始化变量，但对变量进行初始化是个好习惯。未初始化的变量具有其类型的默认值 - 布尔类型的变量默认值是 **`FALSE`**，整形和浮点型变量默认值是零，字符串型变量（例如用于 [echo](function.echo.html) 中）默认值是空字符串以及数组变量的默认值是空数组。"},{"type":4,"line":"**Example #1 未初始化变量的默认值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Unset AND unreferenced (no use context) variable; outputs NULL  "},{"type":4,"line":"var_dump($unset_var);  "},{"type":4,"line":"  "},{"type":4,"line":"// Boolean usage; outputs 'false' (See ternary operators for more on this syntax)  "},{"type":4,"line":"echo($unset_bool ? \"true\\n\" : \"false\\n\");  "},{"type":4,"line":"  "},{"type":4,"line":"// String usage; outputs 'string(3) \"abc\"'  "},{"type":4,"line":"$unset_str .= 'abc';  "},{"type":4,"line":"var_dump($unset_str);  "},{"type":4,"line":"  "},{"type":4,"line":"// Integer usage; outputs 'int(25)'  "},{"type":4,"line":"$unset_int += 25; // 0 + 25 => 25  "},{"type":4,"line":"var_dump($unset_int);  "},{"type":4,"line":"  "},{"type":4,"line":"// Float/double usage; outputs 'float(1.25)'  "},{"type":4,"line":"$unset_float += 1.25;  "},{"type":4,"line":"var_dump($unset_float);  "},{"type":4,"line":"  "},{"type":4,"line":"// Array usage; outputs array(1) {  [3]=>  string(3) \"def\" }  "},{"type":4,"line":"$unset_arr[3] = \"def\"; // array() + array(3 => \"def\") => array(3 => \"def\")  "},{"type":4,"line":"var_dump($unset_arr);  "},{"type":4,"line":"  "},{"type":4,"line":"// Object usage; creates new stdClass object (see http://www.php.net/manual/en/reserved.classes.php)  "},{"type":4,"line":"// Outputs: object(stdClass)#1 (1) {  [\"foo\"]=>  string(3) \"bar\" }  "},{"type":4,"line":"$unset_obj->foo = 'bar';  "},{"type":4,"line":"var_dump($unset_obj);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"依赖未初始化变量的默认值在某些情况下会有问题，例如把一个文件包含到另一个之中时碰上相同的变量名。另外把 [register\\_globals](ini.core.html#ini.register-globals) 打开是一个主要的[安全隐患](security.globals.html)。使用未初始化的变量会发出 E\\_NOTICE 错误，但是在向一个未初始化的数组附加单元时不会。[isset()](function.isset.html) 语言结构可以用来检测一个变量是否已被初始化。"},{"type":3,"line":"3.2 预定义变量"},{"type":4,"line":"PHP 提供了大量的预定义变量。由于许多变量依赖于运行的服务器的版本和设置，及其它因素，所以并没有详细的说明文档。一些预定义变量在 PHP 以[命令行](features.commandline.html)形式运行时并不生效。有关这些变量的详细列表，请参阅[预定义变量](reserved.variables.html)一章。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"PHP 4.2.0 以及后续版本中，PHP 指令 [register\\_globals](ini.core.html#ini.register-globals) 的默认值为 _off_。这是 PHP 的一个主要变化。让 register\\_globals 的值为 _off_ 将影响到预定义变量集在全局范围内的有效性。例如，为了得到 DOCUMENT\\_ROOT 的值，将必须使用 [$\\_SERVER\\['DOCUMENT\\_ROOT'\\]](reserved.variables.server.html) 代替 $DOCUMENT\\_ROOT，又如，使用 [$\\_GET\\['id'\\]](reserved.variables.get.html) 来代替 $id 从 URL _http://www.example.com/test.php?id=3_ 中获取 id 值，亦或使用 [$\\_ENV\\['HOME'\\]](reserved.variables.environment.html) 来代替 $HOME 获取环境变量 HOME 的值。"},{"type":4,"line":"更多相关信息，请阅读 [register\\_globals](ini.core.html#ini.register-globals) 的配置项条目，安全一章中的[使用 Register Globals](security.globals.html)，以及 PHP [» 4.1.0](https://www.php.net/releases/4_1_0.php) 和 [» 4.2.0](https://www.php.net/releases/4_2_0.php) 的发布公告。"},{"type":4,"line":"如果有可用的 PHP 预定义变量那最好用，如[超全局数组](language.variables.superglobals.html)。"},{"type":4,"line":"从 PHP 4.1.0 开始，PHP 提供了一套附加的预定数组，这些数组变量包含了来自 web 服务器（如果可用），运行环境，和用户输入的数据。这些数组非常特别，它们在全局范围内自动生效，例如，在任何范围内自动生效。因此通常被称为自动全局变量（autoglobals）或者超全局变量（superglobals）。（PHP 中没有用户自定义超全局变量的机制。）超全局变量罗列于下文中；但是为了得到它们的内容和关于 PHP 预定义变量的进一步的讨论以及它们的本质，请参阅[预定义变量](reserved.variables.html)。而且，你也将注意到旧的预定义数组（$HTTP\\_\\*\\_VARS）仍旧存在。自 PHP 5.0.0 起, 用 [register\\_long\\_arrays](ini.core.html#ini.register-long-arrays) 设置选项可禁用 长类型的 PHP [预定义变量](language.variables.predefined.html)数组。"},{"type":4,"line":"> **Note**: **可变变量**  "},{"type":4,"line":"> "},{"type":4,"line":"> 超级全局变量不能被用作函数或类方法中的[可变变量](language.variables.variable.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 尽管超全局变量和 HTTP\\_\\*\\_VARS 同时存在，但是它们并不是同一个变量，所以改变其中一个的值并不会对另一个产生影响。"},{"type":4,"line":"如果某些 [variables\\_order](ini.core.html#ini.variables-order) 中的变量没有设定，它们的对应的 PHP 预定义数组也是空的。"},{"type":3,"line":"3.3 变量范围"},{"type":4,"line":"变量的范围即它定义的上下文背景（也就是它的生效范围）。大部分的 PHP 变量只有一个单独的范围。这个单独的范围跨度同样包含了 include 和 require 引入的文件。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"include 'b.inc';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这里变量 $a 将会在包含文件 b.inc 中生效。但是，在用户自定义函数中，一个局部函数范围将被引入。任何用于函数内部的变量按缺省情况将被限制在局部函数范围内。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1; /* global scope */  "},{"type":4,"line":"  "},{"type":4,"line":"function Test()  "},{"type":5,"line":"{  "},{"type":4,"line":"    echo $a; /* reference to local scope variable */  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"Test();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这个脚本不会有任何输出，因为 echo 语句引用了一个局部版本的变量 $a，而且在这个范围内，它并没有被赋值。你可能注意到 PHP 的全局变量和 C 语言有一点点不同，在 C 语言中，全局变量在函数中自动生效，除非被局部变量覆盖。这可能引起一些问题，有些人可能不小心就改变了一个全局变量。PHP 中全局变量在函数中使用时必须声明为 global。"},{"type":4,"line":"### global 关键字"},{"type":4,"line":"首先，一个使用 _global_ 的例子："},{"type":4,"line":"**Example #1 使用 global**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"$b = 2;  "},{"type":4,"line":"  "},{"type":4,"line":"function Sum()  "},{"type":5,"line":"{  "},{"type":4,"line":"    global $a, $b;  "},{"type":5,"line":"  "},{"type":4,"line":"    $b = $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"Sum();  "},{"type":4,"line":"echo $b;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上脚本的输出将是“3”。在函数中声明了全局变量 $a 和 $b 之后，对任一变量的所有引用都会指向其全局版本。对于一个函数能够声明的全局变量的最大个数，PHP 没有限制。"},{"type":4,"line":"在全局范围内访问变量的第二个办法，是用特殊的 PHP 自定义 [$GLOBALS](reserved.variables.globals.html) 数组。前面的例子可以写成："},{"type":4,"line":"**Example #2 使用 [$GLOBALS](reserved.variables.globals.html) 替代 global**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"$b = 2;  "},{"type":4,"line":"  "},{"type":4,"line":"function Sum()  "},{"type":5,"line":"{  "},{"type":4,"line":"    $GLOBALS['b'] = $GLOBALS['a'] + $GLOBALS['b'];  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"Sum();  "},{"type":4,"line":"echo $b;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"[$GLOBALS](reserved.variables.globals.html) 是一个关联数组，每一个变量为一个元素，键名对应变量名，值对应变量的内容。[$GLOBALS](reserved.variables.globals.html) 之所以在全局范围内存在，是因为 $GLOBALS 是一个[超全局变量](language.variables.superglobals.html)。以下范例显示了超全局变量的用处："},{"type":4,"line":"**Example #3 演示超全局变量和作用域的例子**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function test_global()  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 大多数的预定义变量并不 \"super\"，它们需要用 'global' 关键字来使它们在函数的本地区域中有效。  "},{"type":4,"line":"    global $HTTP_POST_VARS;  "},{"type":5,"line":"  "},{"type":4,"line":"    echo $HTTP_POST_VARS['name'];  "},{"type":5,"line":"  "},{"type":5,"line":"    // Superglobals 在任何范围内都有效，它们并不需要 'global' 声明。Superglobals 是在 PHP 4.1.0 引入的。  "},{"type":4,"line":"    echo $_POST['name'];  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 使用静态变量"},{"type":4,"line":"变量范围的另一个重要特性是_静态变量_（static variable）。静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。看看下面的例子："},{"type":4,"line":"**Example #4 演示需要静态变量的例子**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function Test()  "},{"type":5,"line":"{  "},{"type":5,"line":"    $a = 0;  "},{"type":5,"line":"    echo $a;  "},{"type":4,"line":"    $a++;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"本函数没什么用处，因为每次调用时都会将 $a 的值设为 _0_ 并输出 _0_。将变量加一的 $a++ 没有作用，因为一旦退出本函数则变量 $a 就不存在了。要写一个不会丢失本次计数值的计数函数，要将变量 $a 定义为静态的："},{"type":4,"line":"**Example #5 使用静态变量的例子**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function test()  "},{"type":5,"line":"{  "},{"type":5,"line":"    static $a = 0;  "},{"type":5,"line":"    echo $a;  "},{"type":4,"line":"    $a++;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"现在，变量 $a 仅在第一次调用 test() 函数时被初始化，之后每次调用 test() 函数都会输出 $a 的值并加一。"},{"type":4,"line":"静态变量也提供了一种处理递归函数的方法。递归函数是一种调用自己的函数。写递归函数时要小心，因为可能会无穷递归下去。必须确保有充分的方法来中止递归。以下这个简单的函数递归计数到 10，使用静态变量 $count 来判断何时停止："},{"type":4,"line":"**Example #6 静态变量与递归函数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function test()  "},{"type":5,"line":"{  "},{"type":4,"line":"    static $count = 0;  "},{"type":5,"line":"  "},{"type":5,"line":"    $count++;  "},{"type":5,"line":"    echo $count;  "},{"type":5,"line":"    if ($count < 10) {  "},{"type":5,"line":"        test();  "},{"type":5,"line":"    }  "},{"type":4,"line":"    $count--;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 静态变量可以按照上面的例子声明。如果在声明中用表达式的结果对其赋值会导致解析错误。"},{"type":4,"line":"> "},{"type":4,"line":"> **Example #7 声明静态变量**"},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> function foo(){  "},{"type":4,"line":">     static $int = 0;          // correct  "},{"type":4,"line":">     static $int = 1+2;        // wrong  (as it is an expression)  "},{"type":4,"line":">     static $int = sqrt(121);  // wrong  (as it is an expression too)  "},{"type":4,"line":">   "},{"type":4,"line":">     $int++;  "},{"type":4,"line":">     echo $int;  "},{"type":4,"line":"> }  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"静态声明是在编译时解析的。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在函数之外使用 _global_ 关键字不算错。可以用于在一个函数之内包含文件时。"},{"type":4,"line":"### 全局和静态变量的引用"},{"type":4,"line":"在 Zend 引擎 1 代，它驱动了 PHP4，对于变量的 [static](language.variables.scope.html#language.variables.scope.static) 和 [global](language.variables.scope.html#language.variables.scope.global) 定义是以[引用](language.references.html)的方式实现的。例如，在一个函数域内部用 _global_ 语句导入的一个真正的全局变量实际上是建立了一个到全局变量的引用。这有可能导致预料之外的行为，如以下例子所演示的："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function test_global_ref() {  "},{"type":5,"line":"    global $obj;  "},{"type":4,"line":"    $obj = &new stdclass;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function test_global_noref() {  "},{"type":5,"line":"    global $obj;  "},{"type":4,"line":"    $obj = new stdclass;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"test_global_ref();  "},{"type":4,"line":"var_dump($obj);  "},{"type":4,"line":"test_global_noref();  "},{"type":4,"line":"var_dump($obj);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"  "},{"type":4,"line":"NULL  "},{"type":4,"line":"object(stdClass)(0) {  "},{"type":4,"line":"}  "},{"type":4,"line":"类似的行为也适用于 _static_ 语句。引用并不是静态地存储的："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function &get_instance_ref() {  "},{"type":4,"line":"    static $obj;  "},{"type":5,"line":"  "},{"type":5,"line":"    echo 'Static object: ';  "},{"type":5,"line":"    var_dump($obj);  "},{"type":5,"line":"    if (!isset($obj)) {  "},{"type":5,"line":"        // 将一个引用赋值给静态变量  "},{"type":5,"line":"        $obj = &new stdclass;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    $obj->property++;  "},{"type":4,"line":"    return $obj;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function &get_instance_noref() {  "},{"type":4,"line":"    static $obj;  "},{"type":5,"line":"  "},{"type":5,"line":"    echo 'Static object: ';  "},{"type":5,"line":"    var_dump($obj);  "},{"type":5,"line":"    if (!isset($obj)) {  "},{"type":5,"line":"        // 将一个对象赋值给静态变量  "},{"type":5,"line":"        $obj = new stdclass;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    $obj->property++;  "},{"type":4,"line":"    return $obj;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj1 = get_instance_ref();  "},{"type":4,"line":"$still_obj1 = get_instance_ref();  "},{"type":4,"line":"echo \"\\n\";  "},{"type":4,"line":"$obj2 = get_instance_noref();  "},{"type":4,"line":"$still_obj2 = get_instance_noref();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"  "},{"type":4,"line":"Static object: NULL  "},{"type":4,"line":"Static object: NULL  "},{"type":4,"line":"  "},{"type":4,"line":"Static object: NULL  "},{"type":4,"line":"Static object: object(stdClass)(1) {  "},{"type":4,"line":"\\[\"property\"\\]=>  "},{"type":4,"line":"int(1)  "},{"type":4,"line":"}  "},{"type":4,"line":"上例演示了当把一个引用赋值给一个静态变量时，第二次调用 _&get\\_instance\\_ref()_ 函数时其值并没有被_记住_。"},{"type":3,"line":"3.4 可变变量"},{"type":4,"line":"有时候使用可变变量名是很方便的。就是说，一个变量的变量名可以动态的设置和使用。一个普通的变量通过声明来设置，例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 'hello';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"一个可变变量获取了一个普通变量的值作为这个可变变量的变量名。在上面的例子中 _hello_ 使用了两个美元符号（$）以后，就可以作为一个可变变量的变量了。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$$a = 'world';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这时，两个变量都被定义了：$a 的内容是“hello”并且 $hello 的内容是“world”。因此，以下语句："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo \"$a${$a}\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"与以下语句输出完全相同的结果："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo \"$a$hello\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"它们都会输出：hello world。"},{"type":4,"line":"要将可变变量用于数组，必须解决一个模棱两可的问题。这就是当写下 $$a\\[1\\] 时，解析器需要知道是想要 $a\\[1\\] 作为一个变量呢，还是想要 $$a 作为一个变量并取出该变量中索引为 \\[1\\] 的值。解决此问题的语法是，对第一种情况用 ${$a\\[1\\]}，对第二种情况用 ${$a}\\[1\\]。"},{"type":4,"line":"类的属性也可以通过可变属性名来访问。可变属性名将在该调用所处的范围内被解析。例如，对于 $foo->$bar 表达式，则会在本地范围来解析 $bar 并且其值将被用于 $foo 的属性名。对于 $bar 是数组单元时也是一样。"},{"type":4,"line":"也可使用花括号来给属性名清晰定界。最有用是在属性位于数组中，或者属性名包含有多个部分或者属性名包含有非法字符时（例如来自 [json\\_decode()](function.json-decode.html) 或 [SimpleXML](book.simplexml.html)）。"},{"type":4,"line":"**Example #1 可变属性示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class foo {  "},{"type":5,"line":"    var $bar = 'I am bar.';  "},{"type":5,"line":"    var $arr = array('I am A.', 'I am B.', 'I am C.');  "},{"type":4,"line":"    var $r   = 'I am r.';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new foo();  "},{"type":4,"line":"$bar = 'bar';  "},{"type":4,"line":"$baz = array('foo', 'bar', 'baz', 'quux');  "},{"type":4,"line":"echo $foo->$bar . \"\\n\";  "},{"type":4,"line":"echo $foo->$baz[1] . \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$start = 'b';  "},{"type":4,"line":"$end   = 'ar';  "},{"type":4,"line":"echo $foo->{$start . $end} . \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$arr = 'arr';  "},{"type":4,"line":"echo $foo->$arr[1] . \"\\n\";  "},{"type":4,"line":"echo $foo->{$arr}[1] . \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"  "},{"type":4,"line":"I am bar.  "},{"type":4,"line":"I am bar.  "},{"type":4,"line":"I am bar.  "},{"type":4,"line":"I am r.  "},{"type":4,"line":"I am B.  "},{"type":4,"line":"**Warning**"},{"type":4,"line":"注意，在 PHP 的函数和类的方法中，[超全局变量](language.variables.superglobals.html)不能用作可变变量。_$this_ 变量也是一个特殊变量，不能被动态引用。"},{"type":3,"line":"3.5 来自 PHP 之外的变量"},{"type":4,"line":"### HTML 表单（GET 和 POST）"},{"type":4,"line":"当一个表单提交给 PHP 脚本时，表单中的信息会自动在脚本中可用。有很多方法访问此信息，例如："},{"type":4,"line":"**Example #1 一个简单的 HTML 表单**"},{"type":5,"line":"<form action=\"foo.php\" method=\"POST\">"},{"type":5,"line":"    Name:  <input type=\"text\" name=\"username\"><br />"},{"type":5,"line":"    Email: <input type=\"text\" name=\"email\"><br />"},{"type":4,"line":"    <input type=\"submit\" name=\"submit\" value=\"Submit me!\" />"},{"type":4,"line":"</form>"},{"type":4,"line":"根据特定的设置和个人的喜好，有很多种方法访问 HTML 表单中的数据。例如："},{"type":4,"line":"**Example #2 从一个简单的 POST HTML 表单访问数据**"},{"type":4,"line":"<?php"},{"type":5,"line":"// 自 PHP 4.1.0 起可用"},{"type":5,"line":"   echo $\\_POST\\['username'\\];"},{"type":5,"line":"   echo $\\_REQUEST\\['username'\\];"},{"type":5,"line":"   "},{"type":5,"line":"   import\\_request\\_variables('p', 'p\\_');"},{"type":4,"line":"   echo $p\\_username;"},{"type":4,"line":"// 自 PHP 5.0.0 起，这些长格式的预定义变量"},{"type":4,"line":"// 可用 register\\_long\\_arrays 指令关闭。"},{"type":4,"line":"   echo $HTTP\\_POST\\_VARS\\['username'\\];"},{"type":4,"line":"// 如果 PHP 指令 register\\_globals = on 时可用。不过自"},{"type":4,"line":"// PHP 4.2.0 起默认值为 register\\_globals = off。"},{"type":4,"line":"// 不提倡使用/依赖此种方法。"},{"type":4,"line":"   echo $username;"},{"type":4,"line":"?>"},{"type":4,"line":"使用 GET 表单也类似，只不过要用适当的 GET 预定义变量。GET 也适用于 _QUERY\\_STRING_（URL 中在“?”之后的信息）。因此，举例说，_http://www.example.com/test.php?id=3_ 包含有可用 [$\\_GET\\['id'\\]](reserved.variables.get.html) 来访问的 GET 数据。参见 [$\\_REQUEST](reserved.variables.request.html) 和 [import\\_request\\_variables()](function.import-request-variables.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> [超全局数组](language.variables.superglobals.html)例如 [$\\_POST](reserved.variables.post.html) 和 [$\\_GET](reserved.variables.get.html)，自 PHP 4.1.0 起可用。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 变量名中的点和空格被转换成下划线。例如 _<input name=\"a.b\" />_ 变成了 _$\\_REQUEST\\[\"a\\_b\"\\]_。"},{"type":4,"line":"如上所示，在 PHP 4.2.0 之前 [register\\_globals](ini.core.html#ini.register-globals) 的默认值是 _on_。PHP 社区鼓励大家不要依赖此指令，建议在编码时假定其为 _off_。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> [magic\\_quotes\\_gpc](info.configuration.html#ini.magic-quotes-gpc) 配置指令影响到 Get，Post 和 Cookie 的值。如果打开，值 (It's \"PHP!\") 会自动转换成 (It\\\\'s \\\\\"PHP!\\\\\")。十多年前对数据库的插入需要如此转义，如今已经过时了，应该关闭。参见 [addslashes()](function.addslashes.html)，[stripslashes()](function.stripslashes.html) 和 [magic\\_quotes\\_sybase](sybase.configuration.html#ini.magic-quotes-sybase)。"},{"type":4,"line":"PHP 也懂得表单变量上下文中的数组（参见[相关常见问题](faq.html.html)）。例如可以将相关的变量编成组，或者用此特性从多选输入框中取得值。例如，将一个表单 POST 给自己并在提交时显示数据："},{"type":4,"line":"**Example #3 更复杂的表单变量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"if (isset($_POST['action']) && $_POST['action'] == 'submitted') {  "},{"type":4,"line":"    echo '<pre>';  "},{"type":5,"line":"  "},{"type":5,"line":"    print_r($_POST);  "},{"type":4,"line":"    echo '<a href=\"'. $_SERVER['PHP_SELF'] .'\">Please try again</a>';  "},{"type":5,"line":"  "},{"type":4,"line":"    echo '</pre>';  "},{"type":4,"line":"} else {  "},{"type":4,"line":"?>  "},{"type":5,"line":"<form action=\"<?php echo $_SERVER['PHP_SELF']; ?>\" method=\"post\">  "},{"type":5,"line":"    Name:  <input type=\"text\" name=\"personal[name]\"><br />  "},{"type":5,"line":"    Email: <input type=\"text\" name=\"personal[email]\"><br />  "},{"type":5,"line":"    Beer: <br>  "},{"type":5,"line":"    <select multiple name=\"beer[]\">  "},{"type":5,"line":"        <option value=\"warthog\">Warthog</option>  "},{"type":5,"line":"        <option value=\"guinness\">Guinness</option>  "},{"type":5,"line":"        <option value=\"stuttgarter\">Stuttgarter Schwabenbr</option>  "},{"type":5,"line":"    </select><br />  "},{"type":5,"line":"    <input type=\"hidden\" name=\"action\" value=\"submitted\" />  "},{"type":4,"line":"    <input type=\"submit\" name=\"submit\" value=\"submit me!\" />  "},{"type":4,"line":"</form>  "},{"type":4,"line":"<?php  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"#### IMAGE SUBMIT 变量名"},{"type":4,"line":"当提交表单时，可以用一幅图像代替标准的提交按钮，用类似这样的标记："},{"type":4,"line":"<input type=\"image\" src=\"image.gif\" name=\"sub\" />"},{"type":4,"line":"当用户点击到图像中的某处时，相应的表单会被传送到服务器，并加上两个变量 sub\\_x 和 sub\\_y。它们包含了用户点击图像的坐标。有经验的用户可能会注意到被浏览器发送的实际变量名包含的是一个点而不是下划线（即 sub.x 和 sub.y），但 PHP 自动将点转换成了下划线。"},{"type":4,"line":"### HTTP Cookies"},{"type":4,"line":"PHP 透明地支持 [» RFC 6265](http://www.faqs.org/rfcs/rfc6265)定义中的 HTTP cookies。Cookies 是一种在远端浏览器端存储数据并能追踪或识别再次访问的用户的机制。可以用 [setcookie()](function.setcookie.html) 函数设定 cookies。Cookies 是 HTTP 信息头中的一部分，因此 SetCookie 函数必须在向浏览器发送任何输出之前调用。对于 [header()](function.header.html) 函数也有同样的限制。Cookie 数据会在相应的 cookie 数据数组中可用，例如 [$\\_COOKIE](reserved.variables.cookies.html)，$HTTP\\_COOKIE\\_VARS 和 [$\\_REQUEST](reserved.variables.request.html)。更多细节和例子见 [setcookie()](function.setcookie.html) 手册页面。"},{"type":4,"line":"如果要将多个值赋给一个 cookie 变量，必须将其赋成数组。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  setcookie(\"MyCookie[foo]\", 'Testing 1', time()+3600);  "},{"type":4,"line":"  setcookie(\"MyCookie[bar]\", 'Testing 2', time()+3600);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这将会建立两个单独的 cookie，尽管 MyCookie 在脚本中是一个单一的数组。如果想在仅仅一个 cookie 中设定多个值，考虑先在值上使用 [serialize()](function.serialize.html) 或 [explode()](function.explode.html)。"},{"type":4,"line":"注意在浏览器中一个 cookie 会替换掉上一个同名的 cookie，除非路径或者域不同。因此对于购物车程序可以保留一个计数器并一起传递，例如："},{"type":4,"line":"**Example #4 一个 [setcookie()](function.setcookie.html) 的示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"if (isset($_COOKIE['count'])) {  "},{"type":4,"line":"    $count = $_COOKIE['count'] + 1;  "},{"type":5,"line":"} else {  "},{"type":4,"line":"    $count = 1;  "},{"type":4,"line":"}  "},{"type":4,"line":"setcookie('count', $count, time()+3600);  "},{"type":4,"line":"setcookie(\"Cart[$count]\", $item, time()+3600);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 变量名中的点"},{"type":4,"line":"通常，PHP 不会改变传递给脚本中的变量名。然而应该注意到点（句号）不是 PHP 变量名中的合法字符。至于原因，看看："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$varname.ext;  /* 非法变量名 */  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这时，解析器看到是一个名为 $varname 的变量，后面跟着一个字符串连接运算符，后面跟着一个裸字符串（即没有加引号的字符串，且不匹配任何已知的健名或保留字）'ext'。很明显这不是想要的结果。"},{"type":4,"line":"出于此原因，要注意 PHP 将会自动将变量名中的点替换成下划线。"},{"type":4,"line":"### 确定变量类型"},{"type":4,"line":"因为 PHP 会判断变量类型并在需要时进行转换（通常情况下），因此在某一时刻给定的变量是何种类型并不明显。PHP 包括几个函数可以判断变量的类型，例如：[gettype()](function.gettype.html)，[is\\_array()](function.is-array.html)，[is\\_float()](function.is-float.html)，[is\\_int()](function.is-int.html)，[is\\_object()](function.is-object.html) 和 [is\\_string()](function.is-string.html)。参见[类型](language.types.html)一章。"},{"type":1,"line":"4. 常量"},{"type":4,"line":"4.1 语法"},{"type":4,"line":"--"},{"type":4,"line":"可以用 [define()](function.define.html) 函数来定义常量，在 PHP 5.3.0 以后，可以使用 _const_ 关键字在类定义之外定义常量。一个常量一旦被定义，就不能再改变或者取消定义。"},{"type":4,"line":"常量只能包含标量数据（[boolean](language.types.boolean.html)，[integer](language.types.integer.html)，[float](language.types.float.html) 和 [string](language.types.string.html)）。可以定义 [resource](language.types.resource.html) 常量，但应尽量避免，因为会造成不可预料的结果。"},{"type":4,"line":"可以简单的通过指定其名字来取得常量的值，与变量不同，_不应该_在常量前面加上 _$_ 符号。如果常量名是动态的，也可以用函数 [constant()](function.constant.html) 来获取常量的值。用 [get\\_defined\\_constants()](function.get-defined-constants.html) 可以获得所有已定义的常量列表。"},{"type":4,"line":"> **Note**: 常量和（全局）变量在不同的名字空间中。这意味着例如 **`TRUE`** 和 $TRUE 是不同的。"},{"type":4,"line":"如果使用了一个未定义的常量，PHP 假定想要的是该常量本身的名字，如同用字符串调用它一样（CONSTANT 对应 \"CONSTANT\"）。此时将发出一个 [E\\_NOTICE](ref.errorfunc.html) 级的错误。参见手册中为什么 [$foo\\[bar\\]](language.types.array.html#language.types.array.foo-bar) 是错误的（除非事先用 [define()](function.define.html) 将 _bar_ 定义为一个常量）。如果只想检查是否定义了某常量，用 [defined()](function.defined.html) 函数。"},{"type":4,"line":"常量和变量有如下不同："},{"type":4,"line":"*   常量前面没有美元符号（_$_）；"},{"type":4,"line":"*   常量只能用 [define()](function.define.html) 函数定义，而不能通过赋值语句；"},{"type":4,"line":"*   常量可以不用理会变量的作用域而在任何地方定义和访问；"},{"type":4,"line":"*   常量一旦定义就不能被重新定义或者取消定义；"},{"type":4,"line":"*   常量的值只能是标量。"},{"type":4,"line":"**Example #1 定义常量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"define(\"CONSTANT\", \"Hello world.\");  "},{"type":4,"line":"echo CONSTANT; // outputs \"Hello world.\"  "},{"type":4,"line":"echo Constant; // 输出 \"Constant\" 并发出一个提示级别错误信息  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 使用关键字 _const_ 定义常量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 以下代码在 PHP 5.3.0 后可以正常工作  "},{"type":4,"line":"const CONSTANT = 'Hello World';  "},{"type":4,"line":"  "},{"type":4,"line":"echo CONSTANT;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 和使用 [define()](function.define.html) 来定义常量相反的是，使用 _const_ 关键字定义常量必须处于最顶端的作用区域，因为用此方法是在编译时定义的。这就意味着不能在函数内，循环内以及 _if_ 语句之内用 _const_ 来定义常量。"},{"type":4,"line":"参见[类常量](language.oop5.constants.html)。"},{"type":3,"line":"4.2 魔术常量"},{"type":4,"line":"PHP 向它运行的任何脚本提供了大量的[预定义常量](reserved.constants.html)。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。"},{"type":4,"line":"有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 **`__LINE__`** 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下："},{"type":4,"line":"**几个 PHP 的“魔术常量”**"},{"type":4,"line":"名称"},{"type":4,"line":"说明"},{"type":4,"line":"**`__LINE__`**"},{"type":4,"line":"文件中的当前行号。"},{"type":4,"line":"**`__FILE__`**"},{"type":4,"line":"文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。自 PHP 4.0.2 起，**`__FILE__`** 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径。"},{"type":4,"line":"**`__DIR__`**"},{"type":4,"line":"文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录。它等价于 _dirname(\\_\\_FILE\\_\\_)_。除非是根目录，否则目录中名不包括末尾的斜杠。（PHP 5.3.0中新增） ="},{"type":4,"line":"**`__FUNCTION__`**"},{"type":4,"line":"函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。"},{"type":4,"line":"**`__CLASS__`**"},{"type":4,"line":"类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 _Foo\\\\Bar_）。注意自 PHP 5.4 起 \\_\\_CLASS\\_\\_ 对 trait 也起作用。当用在 trait 方法中时，\\_\\_CLASS\\_\\_ 是调用 trait 方法的类的名字。"},{"type":4,"line":"**`__TRAIT__`**"},{"type":4,"line":"Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4 起此常量返回 trait 被定义时的名字（区分大小写）。Trait 名包括其被声明的作用区域（例如 _Foo\\\\Bar_）。"},{"type":4,"line":"**`__METHOD__`**"},{"type":4,"line":"类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。"},{"type":4,"line":"**`__NAMESPACE__`**"},{"type":4,"line":"当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。"},{"type":4,"line":"参见 [get\\_class()](function.get-class.html)，[get\\_object\\_vars()](function.get-object-vars.html)，[file\\_exists()](function.file-exists.html) 和 [function\\_exists()](function.function-exists.html)。"},{"type":1,"line":"5. 表达式"},{"type":4,"line":"表达式是 PHP 最重要的基石。在 PHP 中，几乎所写的任何东西都是一个表达式。简单但却最精确的定义一个表达式的方式就是“任何有值的东西”。"},{"type":4,"line":"最基本的表达式形式是常量和变量。当键入“$a = 5”，即将值“5”分配给变量 $a。“5”，很明显，其值为 5，换句话说“5”是一个值为 5 的表达式（在这里，“5”是一个整型常量）。"},{"type":4,"line":"赋值之后，所期待情况是 $a 的值为 5，因而如果写下 $b = $a，期望的是它犹如 $b = 5 一样。换句话说，$a 是一个值也为 5 的表达式。如果一切运行正确，那这正是将要发生的正确结果。"},{"type":4,"line":"稍微复杂的表达式例子就是函数。例如，考虑下面的函数："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo ()  "},{"type":5,"line":"{  "},{"type":4,"line":"    return 5;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"假定已经熟悉了函数的概念（果不是的话，请看一下[函数](language.functions.html)的相关章节），那么键入 _$c = foo()_ 从本质上来说就如写下 _$c = 5_，这没错。函数也是表达式，表达式的值即为它们的返回值。既然 _foo()_ 返回 5，表达式“_foo()_”的值也是 5。通常函数不会仅仅返回一个静态值，而可能会计算一些东西。"},{"type":4,"line":"当然，PHP 中的值常常并非是整型的。PHP 支持四种标量值（标量值不能拆分为更小的单元，例如和数组不同）类型：整型值（[integer](language.types.integer.html)），浮点数值（[float](language.types.float.html)），字符串值（[string](language.types.string.html)）和布尔值（[boolean](language.types.boolean.html)）。PHP 也支持两种复合类型：数组和对象。这两种类型具可以赋值给变量或者从函数返回。"},{"type":4,"line":"PHP 和其它语言一样在表达式的道路上发展，但推进得更深远。PHP 是一种面向表达式的语言，从这一方面来讲几乎一切都是表达式。考虑刚才已经研究过的例子，“$a = 5”。很显然这里涉及到两个值，整型常量 5 的值以及而且变量 $a 的值，它也被更新为 5。但是事实是这里还涉及到一个额外的值，即附值语句本身的值。赋值语句本身求值为被赋的值，即 5。实际上这意味着“$a = 5”，不必管它是做什么的，是一个值为 5 的表达式。因而，这样写“$b = ($a = 5)”和这样写“$a =5; $b\\=5”（分号标志着语句的结束）是一样的。因为赋值操作的顺序是由右到左的，也可以这么写“$b = $a =5”。"},{"type":4,"line":"另外一个很好的面向表达式的例子就是前、后递增和递减。PHP 和多数其它语言的用户应该比较熟悉变量 ++ 和变量 -- 符号。即[递增和递减运算符](language.operators.increment.html)。在 PHP/FI 2 中，语句“$a++”没有值（不是表达式），这样的话你便不能为其赋值或者以任何其它方式来使用它。PHP 通过将其变为了表达式，类似 C 语言，增强了递增/递减的能力。在 PHP 和 C 语言 中，有两种类型的递增前递增和后递增，本质上来讲，前递增和后递增均增加了变量的值，并且对于变量的影响是相同的。不同的是递增表达式的值。前递增，写做“++$variable”，求增加后的值（PHP 在读取变量的值之前，增加变量的值，因而称之为“前递增”）。后递增，写做“$variable++”，求变量未递增之前的原始值（PHP 在读取变量的值之后，增加变量的值，因而叫做“后递增”）。"},{"type":4,"line":"一个常用到表达式类型是[比较表达式](language.operators.comparison.html)。这些表达式求值 **`FALSE`** 或 **`TRUE`**。PHP 支持 >（大于），>=（大于等于），==（等于），!=（不等于），<（小于），<= (小于等于)。PHP 还支持全等运算符 ===（值和类型均相同）和非全等运算符 !==（值或者类型不同）。这些表达式都是在条件判断语句，比如，_if_ 语句中最常用的。"},{"type":4,"line":"这里，将要研究的最后一个例子是组合的运算赋值表达式。已经知道如果想要为变量 $a 加1，可以简单的写“$a++”或者“++$a”。但是如果想为变量增加大于 1 的值，比如 3，该怎么做？可以多次写“$a++”，但这样明显不是一种高效舒适的方法，一个更加通用的做法是“$a = $a + 3”。“$a + 3”计算 $a 加上 3 的值，并且得到的值重新赋予变量 $a，于是 $a 的值增加了3。在 PHP 及其它几种类似 C 的语言中，可以以一种更加简短的形式完成上述功能，因而也更加清楚快捷。为 $a 的当前值加 3，可以这样写：“$a += 3”。这里的意思是“取变量 $a 的值，加 3，得到的结果再次分配给变量 $a”。除了更简略和清楚外，也可以更快的运行。“$a += 3”的值，如同一个正常赋值操作的值，是赋值后的值。注意它不是 3，而是 $a 的值加上3 之后的值（此值将被赋给 $a）。任何二元运算符都可以用运算赋值模式，例如“$a -= 5”（从变量 $a 的值中减去 5），“$b \\*= 7”（变量 $b 乘以 7），等等。"},{"type":4,"line":"还有一个表达式，如果没有在别的语言中看到过的话，可能看上去很奇怪，即三元条件运算符："},{"type":4,"line":"```"},{"type":4,"line":"$first ? $second : $third"},{"type":4,"line":"```"},{"type":4,"line":"如果第一个子表达式的值是 **`TRUE`**（非零），那么计算第二个子表达式的值，其值即为整个表达式的值。否则，将是第三个子表达式的值。"},{"type":4,"line":"下面的例子一般来说应该有助于理解前、后递增和表达式："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function double($i)  "},{"type":5,"line":"{  "},{"type":4,"line":"    return $i*2;  "},{"type":4,"line":"}  "},{"type":4,"line":"$b = $a = 5;        /* assign the value five into the variable $a and $b */  "},{"type":5,"line":"$c = $a++;          /* post-increment, assign original value of $a  "},{"type":4,"line":"                       (5) to $c */  "},{"type":5,"line":"$e = $d = ++$b;     /* pre-increment, assign the incremented value of  "},{"type":4,"line":"                       $b (6) to $d and $e */  "},{"type":4,"line":"  "},{"type":4,"line":"/* at this point, both $d and $e are equal to 6 */  "},{"type":4,"line":"  "},{"type":5,"line":"$f = double($d++);  /* assign twice the value of $d before  "},{"type":4,"line":"                       the increment, 2*6 = 12 to $f */  "},{"type":5,"line":"$g = double(++$e);  /* assign twice the value of $e after  "},{"type":4,"line":"                       the increment, 2*7 = 14 to $g */  "},{"type":5,"line":"$h = $g += 10;      /* first, $g is incremented by 10 and ends with the  "},{"type":5,"line":"                       value of 24. the value of the assignment (24) is  "},{"type":5,"line":"                       then assigned into $h, and $h ends with the value  "},{"type":4,"line":"                       of 24 as well. */  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"一些表达式可以被当成语句。这时，一条语句的形式是 'expr' ';'，即一个表达式加一个分号结尾。在“$b=$a=5;”中，$a=5 是一个有效的表达式，但它本身不是一条语句。“$b=$a=5;”是一条有效的语句。"},{"type":4,"line":"最后一件值得提起的事情就是表达式的真值。在许多事件中，大体上主要是在条件执行和循环中，不要专注于表达式中明确的值，反而要注意表达式的值是否是 **`TRUE`** 或者 **`FALSE`**。常量 **`TRUE`** 和 **`FALSE`**（大小写无关）是两种可能的 Boolean 值。如果有必要，一个表达式将自动转换为 Boolean。参见[类型强制转换](language.types.type-juggling.html#language.types.typecasting)一节。"},{"type":1,"line":"6. 运算符"},{"type":3,"line":"6.1 运算符优先级"},{"type":4,"line":"运算符优先级指定了两个表达式绑定得有多“紧密”。例如，表达式 _1 + 5 \\* 3_ 的结果是 _16_ 而不是 _18_ 是因为乘号（“\\*”）的优先级比加号（“+”）高。必要时可以用括号来强制改变优先级。例如：_(1 + 5) \\* 3_ 的值为 _18_。"},{"type":4,"line":"如果运算符优先级相同，那运算符的结合方向决定了该如何运算。例如，\"-\"是左联的，那么 _1 - 2 - 3_ 就等同于 _(1 - 2) - 3_ 并且结果是 _\\-4_. 另外一方面，\"=\"是右联的，所以 _$a = $b = $c_ 等同于 _$a = ($b = $c)_。"},{"type":4,"line":"没有结合的相同优先级的运算符不能连在一起使用，例如 _1 < 2 > 1_ 在PHP是不合法的。但另外一方面表达式 _1 <= 1 == 1_ 是合法的, 因为 _\\==_ 的优先级低于 _<=_。"},{"type":4,"line":"括号的使用，哪怕在不是必要的场合下，通过括号的配对来明确标明运算顺序，而非靠运算符优先级和结合性来决定，通常能够增加代码的可读性。"},{"type":4,"line":"下表按照优先级从高到低列出了运算符。同一行中的运算符具有相同优先级，此时它们的结合方向决定求值顺序。"},{"type":4,"line":"**运算符优先级**"},{"type":4,"line":"结合方向"},{"type":4,"line":"运算符"},{"type":4,"line":"附加信息"},{"type":4,"line":"无"},{"type":4,"line":"clone new"},{"type":4,"line":"[clone](language.oop5.cloning.html) 和 [new](language.oop5.basic.html#language.oop5.basic.new)"},{"type":4,"line":"左"},{"type":4,"line":"_\\[_"},{"type":4,"line":"[array()](function.array.html)"},{"type":4,"line":"右"},{"type":4,"line":"_\\*\\*_"},{"type":4,"line":"[算术运算符](language.operators.arithmetic.html)"},{"type":4,"line":"右"},{"type":4,"line":"_++_ _\\--_ _~_ _(int)_ _(float)_ _(string)_ _(array)_ _(object)_ _(bool)_ _@_"},{"type":4,"line":"[类型](language.types.html)和[递增／递减](language.operators.increment.html)"},{"type":4,"line":"无"},{"type":4,"line":"_instanceof_"},{"type":4,"line":"[类型](language.types.html)"},{"type":4,"line":"右"},{"type":4,"line":"_!_"},{"type":4,"line":"[逻辑运算符](language.operators.logical.html)"},{"type":4,"line":"左"},{"type":4,"line":"_\\*_ _/_ _%_"},{"type":4,"line":"[算术运算符](language.operators.arithmetic.html)"},{"type":4,"line":"左"},{"type":4,"line":"_+_ _\\-_ _._"},{"type":4,"line":"[算术运算符](language.operators.arithmetic.html)和[字符串运算符](language.operators.string.html)"},{"type":4,"line":"左"},{"type":4,"line":"_<<_ _\\>>_"},{"type":4,"line":"[位运算符](language.operators.bitwise.html)"},{"type":4,"line":"无"},{"type":4,"line":"_<_ _<=_ _\\>_ _\\>=_"},{"type":4,"line":"[比较运算符](language.operators.comparison.html)"},{"type":4,"line":"无"},{"type":4,"line":"_\\==_ _!=_ _\\===_ _!==_ _<>_ _<=>_"},{"type":4,"line":"[比较运算符](language.operators.comparison.html)"},{"type":4,"line":"左"},{"type":4,"line":"_&_"},{"type":4,"line":"[位运算符](language.operators.bitwise.html)和[引用](language.references.html)"},{"type":4,"line":"左"},{"type":4,"line":"_^_"},{"type":4,"line":"[位运算符](language.operators.bitwise.html)"},{"type":4,"line":"左"},{"type":4,"line":"_|_"},{"type":4,"line":"[位运算符](language.operators.bitwise.html)"},{"type":4,"line":"左"},{"type":4,"line":"_&&_"},{"type":4,"line":"[逻辑运算符](language.operators.logical.html)"},{"type":4,"line":"左"},{"type":4,"line":"_||_"},{"type":4,"line":"[逻辑运算符](language.operators.logical.html)"},{"type":4,"line":"左"},{"type":4,"line":"_??_"},{"type":4,"line":"[比较运算符](language.operators.comparison.html)"},{"type":4,"line":"左"},{"type":4,"line":"_? :_"},{"type":4,"line":"[ternary](language.operators.comparison.html#language.operators.comparison.ternary)"},{"type":4,"line":"right"},{"type":4,"line":"_\\=_ _+=_ _\\-=_ _\\*=_ _\\*\\*=_ _/=_ _.=_ _%=_ _&=_ _|=_ _^=_ _<<=_ _\\>>=_"},{"type":4,"line":"[赋值运算符](language.operators.assignment.html)"},{"type":4,"line":"左"},{"type":4,"line":"_and_"},{"type":4,"line":"[逻辑运算符](language.operators.logical.html)"},{"type":4,"line":"左"},{"type":4,"line":"_xor_"},{"type":4,"line":"[逻辑运算符](language.operators.logical.html)"},{"type":4,"line":"左"},{"type":4,"line":"_or_"},{"type":4,"line":"[逻辑运算符](language.operators.logical.html)"},{"type":4,"line":"**Example #1 结合方向**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 3 * 3 % 5; // (3 * 3) % 5 = 4  "},{"type":4,"line":"// ternary operator associativity differs from C/C++  "},{"type":4,"line":"$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"$b = 2;  "},{"type":4,"line":"$a = $b += 3; // $a = ($b += 3) -> $a = 5, $b = 5  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"Operator precedence and associativity only determine how expressions are grouped, they do not specify an order of evaluation. PHP does not (in the general case) specify in which order an expression is evaluated and code that assumes a specific order of evaluation should be avoided, because the behavior can change between versions of PHP or depending on the surrounding code."},{"type":4,"line":"**Example #2 Undefined order of evaluation**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"echo $a + $a++; // may print either 2 or 3  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 1;  "},{"type":4,"line":"$array[$i] = $i++; // may set either index 1 or 2  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 尽管 _\\=_ 比其它大多数的运算符的优先级低，PHP 仍旧允许类似如下的表达式：_if (!$a = foo())_，在此例中 _foo()_ 的返回值被赋给了 $a。"},{"type":3,"line":"6.2 算术运算符"},{"type":4,"line":"还记得学校里学到的基本数学知识吗？就和它们一样。"},{"type":4,"line":"**算术运算符**"},{"type":4,"line":"例子"},{"type":4,"line":"名称"},{"type":4,"line":"结果"},{"type":4,"line":"\\-$a"},{"type":4,"line":"取反"},{"type":4,"line":"$a 的负值。"},{"type":4,"line":"$a + $b"},{"type":4,"line":"加法"},{"type":4,"line":"$a 和 $b 的和。"},{"type":4,"line":"$a - $b"},{"type":4,"line":"减法"},{"type":4,"line":"$a 和 $b 的差。"},{"type":4,"line":"$a \\* $b"},{"type":4,"line":"乘法"},{"type":4,"line":"$a 和 $b 的积。"},{"type":4,"line":"$a / $b"},{"type":4,"line":"除法"},{"type":4,"line":"$a 除以 $b 的商。"},{"type":4,"line":"$a % $b"},{"type":4,"line":"取模"},{"type":4,"line":"$a 除以 $b 的余数。"},{"type":4,"line":"$a \\*\\* $b"},{"type":4,"line":"Exponentiation"},{"type":4,"line":"Result of raising $a to the $b'th power. Introduced in PHP 5.6."},{"type":4,"line":"除法运算符总是返回浮点数。只有在下列情况例外：两个操作数都是整数（或字符串转换成的整数）并且正好能整除，这时它返回一个整数。"},{"type":4,"line":"取模运算符的操作数在运算之前都会转换成整数（除去小数部分）。"},{"type":4,"line":"取模运算符 _%_ 的结果和被除数的符号（正负号）相同。即 _$a % $b_ 的结果和 $a 的符号相同。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"echo (5 % 3).\"\\n\";           // prints 2  "},{"type":4,"line":"echo (5 % -3).\"\\n\";          // prints 2  "},{"type":4,"line":"echo (-5 % 3).\"\\n\";          // prints -2  "},{"type":4,"line":"echo (-5 % -3).\"\\n\";         // prints -2  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见手册中的[数学函数](ref.math.html)。"},{"type":3,"line":"6.3 赋值运算符"},{"type":4,"line":"基本的赋值运算符是“=”。一开始可能会以为它是“等于”，其实不是的。它实际上意味着把右边表达式的值赋给左边的运算数。"},{"type":4,"line":"赋值运算表达式的值也就是所赋的值。也就是说，“_$a = 3_”的值是 3。这样就可以做一些小技巧："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$a = ($b = 4) + 5; // $a 现在成了 9，而 $b 成了 4。  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在基本赋值运算符之外，还有适合于所有[二元算术](language.operators.html)，数组集合和字符串运算符的“组合运算符”，这样可以在一个表达式中使用它的值并把表达式的结果赋给它，例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 3;  "},{"type":4,"line":"$a += 5; // sets $a to 8, as if we had said: $a = $a + 5;  "},{"type":4,"line":"$b = \"Hello \";  "},{"type":4,"line":"$b .= \"There!\"; // sets $b to \"Hello There!\", just like $b = $b . \"There!\";  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"注意赋值运算将原变量的值拷贝到新变量中（传值赋值），所以改变其中一个并不影响另一个。这也适合于在密集循环中拷贝一些值例如大数组。"},{"type":4,"line":"在 PHP 中普通的传值赋值行为有个例外就是碰到对象 [object](language.types.object.html) 时，在 PHP 5 中是以引用赋值的，除非明确使用了 [clone](language.oop5.cloning.html) 关键字来拷贝。"},{"type":4,"line":"### 引用赋值"},{"type":4,"line":"PHP 支持引用赋值，使用“$var = &$othervar;”语法。引用赋值意味着两个变量指向了同一个数据，没有拷贝任何东西。"},{"type":4,"line":"**Example #1 引用赋值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 3;  "},{"type":4,"line":"$b = &$a; // $b 是 $a 的引用  "},{"type":4,"line":"  "},{"type":4,"line":"print \"$a\\n\"; // 输出 3  "},{"type":4,"line":"print \"$b\\n\"; // 输出 3  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 4; // 修改 $a  "},{"type":4,"line":"  "},{"type":4,"line":"print \"$a\\n\"; // 输出 4  "},{"type":4,"line":"print \"$b\\n\"; // 也输出 4，因为 $b 是 $a 的引用，因此也被改变  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"自 PHP 5 起，[new](language.oop5.basic.html#language.oop5.basic.new) 运算符自动返回一个引用，因此再对 [new](language.oop5.basic.html#language.oop5.basic.new) 的结果进行引用赋值在 PHP 5.3 以及以后版本中会发出一条 **`E_DEPRECATED`** 错误信息，在之前版本会发出一条 **`E_STRICT`** 错误信息。"},{"type":4,"line":"例如以下代码将产生警告："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class C {}  "},{"type":4,"line":"  "},{"type":4,"line":"/* The following line generates the following error message:  "},{"type":4,"line":" * Deprecated: Assigning the return value of new by reference is deprecated in...  "},{"type":4,"line":" */  "},{"type":4,"line":"$o = &new C;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"有关引用更多信息参见本手册中[引用的解释](language.references.html)一章。"},{"type":3,"line":"6.4 位运算符"},{"type":4,"line":"位运算符允许对整型数中指定的位进行求值和操作。"},{"type":4,"line":"**位运算符**"},{"type":4,"line":"例子"},{"type":4,"line":"名称"},{"type":4,"line":"结果"},{"type":4,"line":"**`$a & $b`**"},{"type":4,"line":"And（按位与）"},{"type":4,"line":"将把 $a 和 $b 中都为 1 的位设为 1。"},{"type":4,"line":"**`$a | $b`**"},{"type":4,"line":"Or（按位或）"},{"type":4,"line":"将把 $a 和 $b 中任何一个为 1 的位设为 1。"},{"type":4,"line":"**`$a ^ $b`**"},{"type":4,"line":"Xor（按位异或）"},{"type":4,"line":"将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1。"},{"type":4,"line":"**`~ $a`**"},{"type":4,"line":"Not（按位取反）"},{"type":4,"line":"将 $a 中为 0 的位设为 1，反之亦然。"},{"type":4,"line":"**`$a << $b`**"},{"type":4,"line":"Shift left（左移）"},{"type":4,"line":"将 $a 中的位向左移动 $b 次（每一次移动都表示“乘以 2”）。"},{"type":4,"line":"**`$a >> $b`**"},{"type":4,"line":"Shift right（右移）"},{"type":4,"line":"将 $a 中的位向右移动 $b 次（每一次移动都表示“除以 2”）。"},{"type":4,"line":"位移在 PHP 中是数学运算。向任何方向移出去的位都被丢弃。左移时右侧以零填充，符号位被移走意味着正负号不被保留。右移时左侧以符号位填充，意味着正负号被保留。"},{"type":4,"line":"要用括号确保想要的[优先级](language.operators.precedence.html)。例如 _$a & $b == true_ 先进行比较再进行按位与；而 _($a & $b) == true_ 则先进行按位与再进行比较。"},{"type":4,"line":"If both operands for the _&_, _|_ and _^_ operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. In all other cases, both operands will be [converted to integers](language.types.integer.html#language.types.integer.casting) and the result will be an integer."},{"type":4,"line":"If the operand for the _~_ operator is a string, the operation will be performed on the ASCII values of the characters that make up the string and the result will be a string, otherwise the operand and the result will be treated as integers."},{"type":4,"line":"Both operands and the result for the _<<_ and _\\>>_ operators are always treated as integers."},{"type":4,"line":"PHP 的 ini 设定 error\\_reporting 使用了按位的值，"},{"type":4,"line":"提供了关闭某个位的真实例子。要显示除了提示级别"},{"type":4,"line":"之外的所有错误，php.ini 中是这样用的："},{"type":5,"line":"**`E_ALL & ~E_NOTICE`**"},{"type":4,"line":"      "},{"type":4,"line":"具体运作方式是先取得 E\\_ALL 的值："},{"type":4,"line":"00000000000000000111011111111111"},{"type":4,"line":"再取得 E\\_NOTICE 的值："},{"type":4,"line":"00000000000000000000000000001000"},{"type":4,"line":"然后通过 _~_ 将其取反："},{"type":4,"line":"11111111111111111111111111110111"},{"type":4,"line":"最后再用按位与 AND（&）得到两个值中都设定了（为 1）的位："},{"type":5,"line":"00000000000000000111011111110111"},{"type":4,"line":"      "},{"type":4,"line":"另外一个方法是用按位异或 XOR（_^_）来取得只在"},{"type":4,"line":"其中一个值中设定了的位："},{"type":5,"line":"**`E_ALL ^ E_NOTICE`**"},{"type":4,"line":"      "},{"type":4,"line":"error\\_reporting 也可用来演示怎样置位。只显示错误和可恢复"},{"type":4,"line":"错误的方法是："},{"type":5,"line":"**`E_ERROR | E_RECOVERABLE_ERROR`**"},{"type":4,"line":"      "},{"type":4,"line":"也就是将 E\\_ERROR"},{"type":4,"line":"00000000000000000000000000000001"},{"type":4,"line":"和 E\\_RECOVERABLE\\_ERROR"},{"type":4,"line":"00000000000000000001000000000000"},{"type":4,"line":"用按位或 OR（_|_）运算符来取得在任何一个值中被置位的结果："},{"type":5,"line":"00000000000000000001000000000001"},{"type":4,"line":"      "},{"type":4,"line":"**Example #1 整数的 AND，OR 和 XOR 位运算符**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/*  "},{"type":4,"line":" * Ignore the top section,  "},{"type":4,"line":" * it is just formatting to make output clearer.  "},{"type":4,"line":" */  "},{"type":4,"line":"  "},{"type":5,"line":"$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'  "},{"type":4,"line":"        . ' %3$s (%4$2d = %4$04b)' . \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo <<<EOH  "},{"type":4,"line":" ---------     ---------  -- ---------  "},{"type":4,"line":" result        value      op test  "},{"type":4,"line":" ---------     ---------  -- ---------  "},{"type":4,"line":"EOH;  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"/*  "},{"type":4,"line":" * Here are the examples.  "},{"type":4,"line":" */  "},{"type":4,"line":"  "},{"type":4,"line":"$values = array(0, 1, 2, 4, 8);  "},{"type":4,"line":"$test = 1 + 4;  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n Bitwise AND \\n\";  "},{"type":5,"line":"foreach ($values as $value) {  "},{"type":5,"line":"    $result = $value & $test;  "},{"type":4,"line":"    printf($format, $result, $value, '&', $test);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n Bitwise Inclusive OR \\n\";  "},{"type":5,"line":"foreach ($values as $value) {  "},{"type":5,"line":"    $result = $value | $test;  "},{"type":4,"line":"    printf($format, $result, $value, '|', $test);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n Bitwise Exclusive OR (XOR) \\n\";  "},{"type":5,"line":"foreach ($values as $value) {  "},{"type":5,"line":"    $result = $value ^ $test;  "},{"type":4,"line":"    printf($format, $result, $value, '^', $test);  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":" ---------     ---------  -- ---------"},{"type":4,"line":" result        value      op test"},{"type":4,"line":" ---------     ---------  -- ---------"},{"type":4,"line":" Bitwise AND"},{"type":4,"line":"( 0 = 0000) = ( 0 = 0000) & ( 5 = 0101)"},{"type":4,"line":"( 1 = 0001) = ( 1 = 0001) & ( 5 = 0101)"},{"type":4,"line":"( 0 = 0000) = ( 2 = 0010) & ( 5 = 0101)"},{"type":4,"line":"( 4 = 0100) = ( 4 = 0100) & ( 5 = 0101)"},{"type":4,"line":"( 0 = 0000) = ( 8 = 1000) & ( 5 = 0101)"},{"type":4,"line":" Bitwise Inclusive OR"},{"type":4,"line":"( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)"},{"type":4,"line":"( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)"},{"type":4,"line":"( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)"},{"type":4,"line":"( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)"},{"type":4,"line":"(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)"},{"type":4,"line":" Bitwise Exclusive OR (XOR)"},{"type":4,"line":"( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)"},{"type":4,"line":"( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)"},{"type":4,"line":"( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)"},{"type":4,"line":"( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)"},{"type":4,"line":"(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)"},{"type":4,"line":"**Example #2 字符串的 XOR 运算符**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo 12 ^ 9; // Outputs '5'  "},{"type":4,"line":"  "},{"type":5,"line":"echo \"12\" ^ \"9\"; // Outputs the Backspace character (ascii 8)  "},{"type":4,"line":"                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8  "},{"type":4,"line":"  "},{"type":5,"line":"echo \"hallo\" ^ \"hello\"; // Outputs the ascii values #0 #4 #0 #0 #0  "},{"type":4,"line":"                        // 'a' ^ 'e' = #4  "},{"type":4,"line":"  "},{"type":5,"line":"echo 2 ^ \"3\"; // Outputs 1  "},{"type":4,"line":"              // 2 ^ ((int)\"3\") == 1  "},{"type":4,"line":"  "},{"type":5,"line":"echo \"2\" ^ 3; // Outputs 1  "},{"type":4,"line":"              // ((int)\"2\") ^ 3 == 1  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #3 整数的位移**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/*  "},{"type":4,"line":" * Here are the examples.  "},{"type":4,"line":" */  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = 1;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = 2;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places);  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = 3;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places, 'bits shift out right side');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = 4;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places, 'same result as above; can not shift beyond 0');  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$val = -4;  "},{"type":4,"line":"$places = 1;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places, 'copy of sign bit shifted into left side');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = -4;  "},{"type":4,"line":"$places = 2;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places, 'bits shift out right side');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = -4;  "},{"type":4,"line":"$places = 3;  "},{"type":4,"line":"$res = $val >> $places;  "},{"type":4,"line":"p($res, $val, '>>', $places, 'same result as above; can not shift beyond -1');  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = 1;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places, 'zeros fill in right side');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = (PHP_INT_SIZE * 8) - 4;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places);  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = (PHP_INT_SIZE * 8) - 3;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places, 'sign bits get shifted out');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = 4;  "},{"type":4,"line":"$places = (PHP_INT_SIZE * 8) - 2;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places, 'bits shift out left side');  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$val = -4;  "},{"type":4,"line":"$places = 1;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places, 'zeros fill in right side');  "},{"type":4,"line":"  "},{"type":4,"line":"$val = -4;  "},{"type":4,"line":"$places = (PHP_INT_SIZE * 8) - 3;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places);  "},{"type":4,"line":"  "},{"type":4,"line":"$val = -4;  "},{"type":4,"line":"$places = (PHP_INT_SIZE * 8) - 2;  "},{"type":4,"line":"$res = $val << $places;  "},{"type":4,"line":"p($res, $val, '<<', $places, 'bits shift out left side, including sign bit');  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"/*  "},{"type":4,"line":" * Ignore this bottom section,  "},{"type":4,"line":" * it is just formatting to make output clearer.  "},{"type":4,"line":" */  "},{"type":4,"line":"  "},{"type":5,"line":"function p($res, $val, $op, $places, $note = '') {  "},{"type":4,"line":"    $format = '%0' . (PHP_INT_SIZE * 8) . \"b\\n\";  "},{"type":5,"line":"  "},{"type":4,"line":"    printf(\"Expression: %d = %d %s %d\\n\", $res, $val, $op, $places);  "},{"type":5,"line":"  "},{"type":5,"line":"    echo \" Decimal:\\n\";  "},{"type":5,"line":"    printf(\"  val=%d\\n\", $val);  "},{"type":4,"line":"    printf(\"  res=%d\\n\", $res);  "},{"type":5,"line":"  "},{"type":5,"line":"    echo \" Binary:\\n\";  "},{"type":5,"line":"    printf('  val=' . $format, $val);  "},{"type":4,"line":"    printf('  res=' . $format, $res);  "},{"type":5,"line":"  "},{"type":5,"line":"    if ($note) {  "},{"type":5,"line":"        echo \" NOTE: $note\\n\";  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":4,"line":"    echo \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程在 32 位机器上的输出:"},{"type":4,"line":"Expression: 2 = 4 >> 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=2"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=00000000000000000000000000000010"},{"type":4,"line":" NOTE: copy of sign bit shifted into left side"},{"type":4,"line":"Expression: 1 = 4 >> 2"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=1"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=00000000000000000000000000000001"},{"type":4,"line":"Expression: 0 = 4 >> 3"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=00000000000000000000000000000000"},{"type":4,"line":" NOTE: bits shift out right side"},{"type":4,"line":"Expression: 0 = 4 >> 4"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=00000000000000000000000000000000"},{"type":4,"line":" NOTE: same result as above; can not shift beyond 0"},{"type":4,"line":"Expression: -2 = -4 >> 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-2"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=11111111111111111111111111111100"},{"type":4,"line":"  res=11111111111111111111111111111110"},{"type":4,"line":" NOTE: copy of sign bit shifted into left side"},{"type":4,"line":"Expression: -1 = -4 >> 2"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-1"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=11111111111111111111111111111100"},{"type":4,"line":"  res=11111111111111111111111111111111"},{"type":4,"line":" NOTE: bits shift out right side"},{"type":4,"line":"Expression: -1 = -4 >> 3"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-1"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=11111111111111111111111111111100"},{"type":4,"line":"  res=11111111111111111111111111111111"},{"type":4,"line":" NOTE: same result as above; can not shift beyond -1"},{"type":4,"line":"Expression: 8 = 4 << 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=8"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=00000000000000000000000000001000"},{"type":4,"line":" NOTE: zeros fill in right side"},{"type":4,"line":"Expression: 1073741824 = 4 << 28"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=1073741824"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=01000000000000000000000000000000"},{"type":4,"line":"Expression: -2147483648 = 4 << 29"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=-2147483648"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=10000000000000000000000000000000"},{"type":4,"line":" NOTE: sign bits get shifted out"},{"type":4,"line":"Expression: 0 = 4 << 30"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=00000000000000000000000000000100"},{"type":4,"line":"  res=00000000000000000000000000000000"},{"type":4,"line":" NOTE: bits shift out left side"},{"type":4,"line":"Expression: -8 = -4 << 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-8"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=11111111111111111111111111111100"},{"type":4,"line":"  res=11111111111111111111111111111000"},{"type":4,"line":" NOTE: zeros fill in right side"},{"type":4,"line":"Expression: -2147483648 = -4 << 29"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-2147483648"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=11111111111111111111111111111100"},{"type":4,"line":"  res=10000000000000000000000000000000"},{"type":4,"line":"Expression: 0 = -4 << 30"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=11111111111111111111111111111100"},{"type":4,"line":"  res=00000000000000000000000000000000"},{"type":4,"line":" NOTE: bits shift out left side, including sign bit"},{"type":4,"line":"以上例程在 64 位机器上的输出:"},{"type":4,"line":"Expression: 2 = 4 >> 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=2"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000000010"},{"type":4,"line":" NOTE: copy of sign bit shifted into left side"},{"type":4,"line":"Expression: 1 = 4 >> 2"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=1"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000000001"},{"type":4,"line":"Expression: 0 = 4 >> 3"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":" NOTE: bits shift out right side"},{"type":4,"line":"Expression: 0 = 4 >> 4"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":" NOTE: same result as above; can not shift beyond 0"},{"type":4,"line":"Expression: -2 = -4 >> 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-2"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=1111111111111111111111111111111111111111111111111111111111111100"},{"type":4,"line":"  res=1111111111111111111111111111111111111111111111111111111111111110"},{"type":4,"line":" NOTE: copy of sign bit shifted into left side"},{"type":4,"line":"Expression: -1 = -4 >> 2"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-1"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=1111111111111111111111111111111111111111111111111111111111111100"},{"type":4,"line":"  res=1111111111111111111111111111111111111111111111111111111111111111"},{"type":4,"line":" NOTE: bits shift out right side"},{"type":4,"line":"Expression: -1 = -4 >> 3"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-1"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=1111111111111111111111111111111111111111111111111111111111111100"},{"type":4,"line":"  res=1111111111111111111111111111111111111111111111111111111111111111"},{"type":4,"line":" NOTE: same result as above; can not shift beyond -1"},{"type":4,"line":"Expression: 8 = 4 << 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=8"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000001000"},{"type":4,"line":" NOTE: zeros fill in right side"},{"type":4,"line":"Expression: 4611686018427387904 = 4 << 60"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=4611686018427387904"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0100000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":"Expression: -9223372036854775808 = 4 << 61"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=-9223372036854775808"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=1000000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":" NOTE: sign bits get shifted out"},{"type":4,"line":"Expression: 0 = 4 << 62"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=0000000000000000000000000000000000000000000000000000000000000100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":" NOTE: bits shift out left side"},{"type":4,"line":"Expression: -8 = -4 << 1"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-8"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=1111111111111111111111111111111111111111111111111111111111111100"},{"type":4,"line":"  res=1111111111111111111111111111111111111111111111111111111111111000"},{"type":4,"line":" NOTE: zeros fill in right side"},{"type":4,"line":"Expression: -9223372036854775808 = -4 << 61"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=-9223372036854775808"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=1111111111111111111111111111111111111111111111111111111111111100"},{"type":4,"line":"  res=1000000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":"Expression: 0 = -4 << 62"},{"type":4,"line":" Decimal:"},{"type":4,"line":"  val=-4"},{"type":4,"line":"  res=0"},{"type":4,"line":" Binary:"},{"type":4,"line":"  val=1111111111111111111111111111111111111111111111111111111111111100"},{"type":4,"line":"  res=0000000000000000000000000000000000000000000000000000000000000000"},{"type":4,"line":" NOTE: bits shift out left side, including sign bit"},{"type":4,"line":"**Warning**"},{"type":4,"line":"Shifting integers by values greater than or equal to the system long integer width results in undefined behavior. In other words, don't shift more than 31 bits on a 32-bit system, and don't shift more than 63 bits on a 64-bit system."},{"type":4,"line":"使用 [gmp](book.gmp.html) 扩展对超出 _PHP\\_INT\\_MAX_ 的数值来进行位操作。"},{"type":4,"line":"参见 [pack()](function.pack.html), [unpack()](function.unpack.html), [gmp\\_and()](function.gmp-and.html), [gmp\\_or()](function.gmp-or.html), [gmp\\_xor()](function.gmp-xor.html), [gmp\\_testbit()](function.gmp-testbit.html), [gmp\\_clrbit()](function.gmp-clrbit.html)"},{"type":3,"line":"6.5 比较运算符"},{"type":4,"line":"比较运算符，如同它们名称所暗示的，允许对两个值进行比较。还可以参考 [PHP 类型比较表](types.comparisons.html)看不同类型相互比较的例子。"},{"type":4,"line":"**比较运算符**"},{"type":4,"line":"例子"},{"type":4,"line":"名称"},{"type":4,"line":"结果"},{"type":4,"line":"$a == $b"},{"type":4,"line":"等于"},{"type":4,"line":"**`TRUE`**，如果类型转换后 $a 等于 $b。"},{"type":4,"line":"$a === $b"},{"type":4,"line":"全等"},{"type":4,"line":"**`TRUE`**，如果 $a 等于 $b，并且它们的类型也相同。"},{"type":4,"line":"$a != $b"},{"type":4,"line":"不等"},{"type":4,"line":"**`TRUE`**，如果类型转换后 $a 不等于 $b。"},{"type":4,"line":"$a <> $b"},{"type":4,"line":"不等"},{"type":4,"line":"**`TRUE`**，如果类型转换后 $a 不等于 $b。"},{"type":4,"line":"$a !== $b"},{"type":4,"line":"不全等"},{"type":4,"line":"**`TRUE`**，如果 $a 不等于 $b，或者它们的类型不同。"},{"type":4,"line":"$a < $b"},{"type":4,"line":"小与"},{"type":4,"line":"**`TRUE`**，如果 $a 严格小于 $b。"},{"type":4,"line":"$a > $b"},{"type":4,"line":"大于"},{"type":4,"line":"**`TRUE`**，如果 $a 严格大于 $b。"},{"type":4,"line":"$a <= $b"},{"type":4,"line":"小于等于"},{"type":4,"line":"**`TRUE`**，如果 $a 小于或者等于 $b。"},{"type":4,"line":"$a >= $b"},{"type":4,"line":"大于等于"},{"type":4,"line":"**`TRUE`**，如果 $a 大于或者等于 $b。"},{"type":4,"line":"$a <=> $b"},{"type":4,"line":"太空船运算符（组合比较符）"},{"type":4,"line":"当$a小于、等于、大于$b时 分别返回一个小于、等于、大于0的[integer](language.types.integer.html) 值。 PHP7开始提供."},{"type":4,"line":"$a ?? $b ?? $c"},{"type":4,"line":"NULL 合并操作符"},{"type":4,"line":"从左往右第一个存在且不为 **`NULL`** 的操作数。如果都没有定义且不为 **`NULL`**，则返回 **`NULL`**。PHP7开始提供。"},{"type":4,"line":"如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被[转换为数值](language.types.string.html#language.types.string.conversion)并且比较按照数值来进行。此规则也适用于 [switch](control-structures.switch.html) 语句。当用 === 或 !== 进行比较时则不进行类型转换，因为此时类型和数值都要比对。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"var_dump(0 == \"a\"); // 0 == 0 -> true  "},{"type":4,"line":"var_dump(\"1\" == \"01\"); // 1 == 1 -> true  "},{"type":4,"line":"var_dump(\"10\" == \"1e1\"); // 10 == 10 -> true  "},{"type":4,"line":"var_dump(100 == \"1e2\"); // 100 == 100 -> true  "},{"type":4,"line":"  "},{"type":4,"line":"switch (\"a\") {  "},{"type":5,"line":"case 0:  "},{"type":5,"line":"    echo \"0\";  "},{"type":4,"line":"    break;  "},{"type":5,"line":"case \"a\": // never reached because \"a\" is already matched with 0  "},{"type":5,"line":"    echo \"a\";  "},{"type":4,"line":"    break;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"```php"},{"type":4,"line":"<?php    "},{"type":4,"line":"// Integers  "},{"type":4,"line":"echo 1 <=> 1; // 0  "},{"type":4,"line":"echo 1 <=> 2; // -1  "},{"type":5,"line":"echo 2 <=> 1; // 1  "},{"type":4,"line":"   "},{"type":4,"line":"// Floats  "},{"type":4,"line":"echo 1.5 <=> 1.5; // 0  "},{"type":4,"line":"echo 1.5 <=> 2.5; // -1  "},{"type":5,"line":"echo 2.5 <=> 1.5; // 1  "},{"type":4,"line":"   "},{"type":4,"line":"// Strings  "},{"type":4,"line":"echo \"a\" <=> \"a\"; // 0  "},{"type":4,"line":"echo \"a\" <=> \"b\"; // -1  "},{"type":5,"line":"echo \"b\" <=> \"a\"; // 1  "},{"type":4,"line":"   "},{"type":4,"line":"echo \"a\" <=> \"aa\"; // -1  "},{"type":5,"line":"echo \"zz\" <=> \"aa\"; // 1  "},{"type":4,"line":"   "},{"type":4,"line":"// Arrays  "},{"type":4,"line":"echo [] <=> []; // 0  "},{"type":4,"line":"echo [1, 2, 3] <=> [1, 2, 3]; // 0  "},{"type":4,"line":"echo [1, 2, 3] <=> []; // 1  "},{"type":4,"line":"echo [1, 2, 3] <=> [1, 2, 1]; // 1  "},{"type":5,"line":"echo [1, 2, 3] <=> [1, 2, 4]; // -1  "},{"type":4,"line":"   "},{"type":4,"line":"// Objects  "},{"type":4,"line":"$a = (object) [\"a\" => \"b\"];   "},{"type":4,"line":"$b = (object) [\"a\" => \"b\"];   "},{"type":5,"line":"echo $a <=> $b; // 0  "},{"type":4,"line":"   "},{"type":4,"line":"$a = (object) [\"a\" => \"b\"];   "},{"type":4,"line":"$b = (object) [\"a\" => \"c\"];   "},{"type":5,"line":"echo $a <=> $b; // -1  "},{"type":4,"line":"   "},{"type":4,"line":"$a = (object) [\"a\" => \"c\"];   "},{"type":4,"line":"$b = (object) [\"a\" => \"b\"];   "},{"type":5,"line":"echo $a <=> $b; // 1  "},{"type":4,"line":"   "},{"type":4,"line":"// only values are compared  "},{"type":4,"line":"$a = (object) [\"a\" => \"b\"];   "},{"type":4,"line":"$b = (object) [\"b\" => \"b\"];   "},{"type":4,"line":"echo $a <=> $b; // 1  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"对于多种类型，比较运算符根据下表比较（按顺序）。"},{"type":4,"line":"**比较多种类型**"},{"type":4,"line":"运算数 1 类型"},{"type":4,"line":"运算数 2 类型"},{"type":4,"line":"结果"},{"type":4,"line":"[null](language.types.null.html) 或 [string](language.types.string.html)"},{"type":4,"line":"[string](language.types.string.html)"},{"type":4,"line":"将 **`NULL`** 转换为 \"\"，进行数字或词汇比较"},{"type":4,"line":"[bool](language.types.boolean.html) 或 [null](language.types.null.html)"},{"type":4,"line":"任何其它类型"},{"type":4,"line":"转换为 [bool](language.types.boolean.html)，**`FALSE`** < **`TRUE`**"},{"type":4,"line":"[object](language.types.object.html)"},{"type":4,"line":"[object](language.types.object.html)"},{"type":4,"line":"内置类可以定义自己的比较，不同类不能比较，相同类和数组同样方式比较属性（PHP 4 中），PHP 5 有其自己的[说明](language.oop5.object-comparison.html)"},{"type":4,"line":"[string](language.types.string.html)，[resource](language.types.resource.html) 或 [number](language.pseudo-types.html#language.types.number)"},{"type":4,"line":"[string](language.types.string.html)，[resource](language.types.resource.html) 或 [number](language.pseudo-types.html#language.types.number)"},{"type":4,"line":"将字符串和资源转换成数字，按普通数学比较"},{"type":4,"line":"[array](language.types.array.html)"},{"type":4,"line":"[array](language.types.array.html)"},{"type":4,"line":"具有较少成员的数组较小，如果运算数 1 中的键不存在于运算数 2 中则数组无法比较，否则挨个值比较（见下例）"},{"type":4,"line":"[object](language.types.object.html)"},{"type":4,"line":"任何其它类型"},{"type":4,"line":"[object](language.types.object.html) 总是更大"},{"type":4,"line":"[array](language.types.array.html)"},{"type":4,"line":"任何其它类型"},{"type":4,"line":"[array](language.types.array.html) 总是更大"},{"type":4,"line":"**Example #1 标准数组比较代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 数组是用标准比较运算符这样比较的  "},{"type":4,"line":"function standard_array_compare($op1, $op2)  "},{"type":5,"line":"{  "},{"type":5,"line":"    if (count($op1) < count($op2)) {  "},{"type":5,"line":"        return -1; // $op1 < $op2  "},{"type":5,"line":"    } elseif (count($op1) > count($op2)) {  "},{"type":5,"line":"        return 1; // $op1 > $op2  "},{"type":5,"line":"    }  "},{"type":5,"line":"    foreach ($op1 as $key => $val) {  "},{"type":5,"line":"        if (!array_key_exists($key, $op2)) {  "},{"type":5,"line":"            return null; // uncomparable  "},{"type":5,"line":"        } elseif ($val < $op2[$key]) {  "},{"type":5,"line":"            return -1;  "},{"type":5,"line":"        } elseif ($val > $op2[$key]) {  "},{"type":5,"line":"            return 1;  "},{"type":5,"line":"        }  "},{"type":5,"line":"    }  "},{"type":4,"line":"    return 0; // $op1 == $op2  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 Transcription of standard array comparison**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Arrays are compared like this with standard comparison operators  "},{"type":4,"line":"function standard_array_compare($op1, $op2)  "},{"type":5,"line":"{  "},{"type":5,"line":"    if (count($op1) < count($op2)) {  "},{"type":5,"line":"        return -1; // $op1 < $op2  "},{"type":5,"line":"    } elseif (count($op1) > count($op2)) {  "},{"type":5,"line":"        return 1; // $op1 > $op2  "},{"type":5,"line":"    }  "},{"type":5,"line":"    foreach ($op1 as $key => $val) {  "},{"type":5,"line":"        if (!array_key_exists($key, $op2)) {  "},{"type":5,"line":"            return null; // uncomparable  "},{"type":5,"line":"        } elseif ($val < $op2[$key]) {  "},{"type":5,"line":"            return -1;  "},{"type":5,"line":"        } elseif ($val > $op2[$key]) {  "},{"type":5,"line":"            return 1;  "},{"type":5,"line":"        }  "},{"type":5,"line":"    }  "},{"type":4,"line":"    return 0; // $op1 == $op2  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见 [strcasecmp()](function.strcasecmp.html)，[strcmp()](function.strcmp.html)，[数组运算符](language.operators.array.html)和[类型](language.types.html)章节。"},{"type":4,"line":"**Warning**"},{"type":2,"line":"比较浮点数"},{"type":4,"line":"由于浮点数 [float](language.types.float.html) 的内部表达方式，不应比较两个浮点数[float](language.types.float.html)是否相等。"},{"type":4,"line":"更多信息参见 [float](language.types.float.html)。"},{"type":4,"line":"### 三元运算符"},{"type":4,"line":"另一个条件运算符是“?:”（或三元）运算符 。"},{"type":4,"line":"**Example #3 赋默认值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Example usage for: Ternary Operator  "},{"type":4,"line":"$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];  "},{"type":4,"line":"  "},{"type":4,"line":"// The above is identical to this if/else statement  "},{"type":5,"line":"if (empty($_POST['action'])) {  "},{"type":4,"line":"    $action = 'default';  "},{"type":5,"line":"} else {  "},{"type":4,"line":"    $action = $_POST['action'];  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"表达式 _(expr1) ? (expr2) : (expr3)_ 在 expr1 求值为 **`TRUE`** 时的值为 expr2，在 expr1 求值为 **`FALSE`** 时的值为 expr3。"},{"type":4,"line":"自 PHP 5.3 起，可以省略三元运算符中间那部分。表达式 _expr1 ?: expr3_ 在 expr1 求值为 **`TRUE`** 时返回 expr1，否则返回 expr3。"},{"type":4,"line":"> **Note**: 注意三元运算符是个语句，因此其求值不是变量，而是语句的结果。如果想通过引用返回一个变量这点就很重要。在一个通过引用返回的函数中语句 _return $var == 42 ? $a : $b;_ 将不起作用，以后的 PHP 版本会为此发出一条警告。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 建议避免将三元运算符堆积在一起使用。当在一条语句中使用多个三元运算符时会造成 PHP 运算结果不清晰："},{"type":4,"line":"> "},{"type":4,"line":"> **Example #4 不清晰的三元运算符行为**"},{"type":4,"line":"> "},{"type":4,"line":">"},{"type":4,"line":" "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> // 乍看起来下面的输出是 'true'  "},{"type":4,"line":"> echo (true?'true':false?'t':'f');  "},{"type":4,"line":">   "},{"type":4,"line":"> // 然而，上面语句的实际输出是't'，因为三元运算符是从左往右计算的  "},{"type":4,"line":">   "},{"type":4,"line":"> // 下面是与上面等价的语句，但更清晰  "},{"type":4,"line":"> echo ((true ? 'true' : 'false') ? 't' : 'f');  "},{"type":4,"line":">   "},{"type":4,"line":"> // here, you can see that the first expression is evaluated to 'true', which  "},{"type":4,"line":"> // in turn evaluates to (bool)true, thus returning the true branch of the  "},{"type":4,"line":"> // second ternary expression.  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":3,"line":"6.6 错误控制运算符"},{"type":4,"line":"PHP 支持一个错误控制运算符：@。当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都被忽略掉。"},{"type":4,"line":"如果用 [set\\_error\\_handler()](function.set-error-handler.html) 设定了自定义的错误处理函数，仍然会被调用，但是此错误处理函数可以（并且也应该）调用 [error\\_reporting()](function.error-reporting.html)，而该函数在出错语句前有 @ 时将返回 0。"},{"type":4,"line":"如果激活了 [**track\\_errors**](errorfunc.configuration.html#ini.track-errors) 特性，表达式所产生的任何错误信息都被存放在变量 [$php\\_errormsg](reserved.variables.phperrormsg.html) 中。此变量在每次出错时都会被覆盖，所以如果想用它的话就要尽早检查。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* Intentional file error */  "},{"type":5,"line":"$my_file = @file ('non_existent_file') or  "},{"type":4,"line":"    die (\"Failed opening file: error was '$php_errormsg'\");  "},{"type":4,"line":"  "},{"type":4,"line":"// this works for any expression, not just functions:  "},{"type":4,"line":"$value = @$cache[$key];  "},{"type":4,"line":"// will not issue a notice if the index $key doesn't exist.  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**: @ 运算符只对[表达式](language.expressions.html)有效。对新手来说一个简单的规则就是：如果能从某处得到值，就能在它前面加上 @ 运算符。例如，可以把它放在变量，函数和 [include](function.include.html) 调用，常量，等等之前。不能把它放在函数或类的定义之前，也不能用于条件结构例如 _if_ 和 [foreach](control-structures.foreach.html) 等。"},{"type":4,"line":"参见 [error\\_reporting()](function.error-reporting.html) 及手册中[错误处理及日志函数](ref.errorfunc.html)的有关章节。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"目前的“@”错误控制运算符前缀甚至使导致脚本终止的严重错误的错误报告也失效。这意味着如果在某个不存在或者敲错了字母的函数调用前用了“@”来抑制错误信息，那脚本会没有任何迹象显示原因而死在那里。"},{"type":3,"line":"6.7 执行运算符"},{"type":4,"line":"PHP 支持一个执行运算符：反引号（\\`\\`）。注意这不是单引号！PHP 将尝试将反引号中的内容作为 shell 命令来执行，并将其输出信息返回（即，可以赋给一个变量而不是简单地丢弃到标准输出）。使用反引号运算符“\\`”的效果与函数 [shell\\_exec()](function.shell-exec.html) 相同。"},{"type":4,"line":"````php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$output = `ls -al`;  "},{"type":4,"line":"echo \"<pre>$output</pre>\";  "},{"type":4,"line":"?>"},{"type":4,"line":"````"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 反引号运算符在激活了[安全模式](ini.sect.safe-mode.html#ini.safe-mode)或者关闭了 [shell\\_exec()](function.shell-exec.html) 时是无效的。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 与其它某些语言不同，反引号不能在双引号字符串中使用。"},{"type":4,"line":"参见手册中[程序执行函数](ref.exec.html)，[popen()](function.popen.html)，[proc\\_open()](function.proc-open.html) 以及 [PHP 的命令行模式](features.commandline.html)。"},{"type":3,"line":"6.8 递增／递减运算符"},{"type":4,"line":"PHP 支持 C 风格的前／后递增与递减运算符。"},{"type":4,"line":"> **Note**: 递增／递减运算符不影响布尔值。递减 **`NULL`** 值也没有效果，但是递增 **`NULL`** 的结果是 _1_。"},{"type":4,"line":"**递增／递减运算符**"},{"type":4,"line":"例子"},{"type":4,"line":"名称"},{"type":4,"line":"效果"},{"type":4,"line":"++$a"},{"type":4,"line":"前加"},{"type":4,"line":"$a 的值加一，然后返回 $a。"},{"type":4,"line":"$a++"},{"type":4,"line":"后加"},{"type":4,"line":"返回 $a，然后将 $a 的值加一。"},{"type":4,"line":"\\--$a"},{"type":4,"line":"前减"},{"type":4,"line":"$a 的值减一， 然后返回 $a。"},{"type":4,"line":"$a--"},{"type":4,"line":"后减"},{"type":4,"line":"返回 $a，然后将 $a 的值减一。"},{"type":4,"line":"一个简单的示例脚本："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo \"<h3>Postincrement</h3>\";  "},{"type":4,"line":"$a = 5;  "},{"type":4,"line":"echo \"Should be 5: \" . $a++ . \"<br />\\n\";  "},{"type":4,"line":"echo \"Should be 6: \" . $a . \"<br />\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"<h3>Preincrement</h3>\";  "},{"type":4,"line":"$a = 5;  "},{"type":4,"line":"echo \"Should be 6: \" . ++$a . \"<br />\\n\";  "},{"type":4,"line":"echo \"Should be 6: \" . $a . \"<br />\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"<h3>Postdecrement</h3>\";  "},{"type":4,"line":"$a = 5;  "},{"type":4,"line":"echo \"Should be 5: \" . $a-- . \"<br />\\n\";  "},{"type":4,"line":"echo \"Should be 4: \" . $a . \"<br />\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"<h3>Predecrement</h3>\";  "},{"type":4,"line":"$a = 5;  "},{"type":4,"line":"echo \"Should be 4: \" . --$a . \"<br />\\n\";  "},{"type":4,"line":"echo \"Should be 4: \" . $a . \"<br />\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在处理字符变量的算数运算时，PHP 沿袭了 Perl 的习惯，而非 C 的。例如，在 Perl 中 _$a = 'Z'; $a++;_ 将把 _$a_ 变成_'AA'_，而在 C 中，_a = 'Z'; a++;_ 将把 _a_ 变成 _'\\['_（_'Z'_ 的 ASCII 值是 90，_'\\['_ 的 ASCII 值是 91）。注意字符变量只能递增，不能递减，并且只支持纯字母（a-z 和 A-Z）。递增／递减其他字符变量则无效，原字符串没有变化。"},{"type":4,"line":"**Example #1 涉及字符变量的算数运算**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo '== Alphabets ==' . PHP_EOL;  "},{"type":4,"line":"$s = 'W';  "},{"type":5,"line":"for ($n=0; $n<6; $n++) {  "},{"type":4,"line":"    echo ++$s . PHP_EOL;  "},{"type":4,"line":"}  "},{"type":4,"line":"// Digit characters behave differently  "},{"type":4,"line":"echo '== Digits ==' . PHP_EOL;  "},{"type":4,"line":"$d = 'A8';  "},{"type":5,"line":"for ($n=0; $n<6; $n++) {  "},{"type":4,"line":"    echo ++$d . PHP_EOL;  "},{"type":4,"line":"}  "},{"type":4,"line":"$d = 'A08';  "},{"type":5,"line":"for ($n=0; $n<6; $n++) {  "},{"type":4,"line":"    echo ++$d . PHP_EOL;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"\\== Characters =="},{"type":4,"line":"X"},{"type":4,"line":"Y"},{"type":4,"line":"Z"},{"type":4,"line":"AA"},{"type":4,"line":"AB"},{"type":4,"line":"AC"},{"type":4,"line":"== Digits =="},{"type":4,"line":"A9"},{"type":4,"line":"B0"},{"type":4,"line":"B1"},{"type":4,"line":"B2"},{"type":4,"line":"B3"},{"type":4,"line":"B4"},{"type":4,"line":"A09"},{"type":4,"line":"A10"},{"type":4,"line":"A11"},{"type":4,"line":"A12"},{"type":4,"line":"A13"},{"type":4,"line":"A14"},{"type":4,"line":"递增或递减布尔值没有效果。"},{"type":3,"line":"6.9 逻辑运算符"},{"type":4,"line":"**逻辑运算符**"},{"type":4,"line":"例子"},{"type":4,"line":"名称"},{"type":4,"line":"结果"},{"type":4,"line":"$a and $b"},{"type":4,"line":"And（逻辑与）"},{"type":4,"line":"**`TRUE`**，如果 $a 和 $b 都为 **`TRUE`**。"},{"type":4,"line":"$a or $b"},{"type":4,"line":"Or（逻辑或）"},{"type":4,"line":"**`TRUE`**，如果 $a 或 $b 任一为 **`TRUE`**。"},{"type":4,"line":"$a xor $b"},{"type":4,"line":"Xor（逻辑异或）"},{"type":4,"line":"**`TRUE`**，如果 $a 或 $b 任一为 **`TRUE`**，但不同时是。"},{"type":4,"line":"! $a"},{"type":4,"line":"Not（逻辑非）"},{"type":4,"line":"**`TRUE`**，如果 $a 不为 **`TRUE`**。"},{"type":4,"line":"$a && $b"},{"type":4,"line":"And（逻辑与）"},{"type":4,"line":"**`TRUE`**，如果 $a 和 $b 都为 **`TRUE`**。"},{"type":4,"line":"$a || $b"},{"type":4,"line":"Or（逻辑或）"},{"type":4,"line":"**`TRUE`**，如果 $a 或 $b 任一为 **`TRUE`**。"},{"type":4,"line":"“与”和“或”有两种不同形式运算符的原因是它们运算的优先级不同（见[运算符优先级](language.operators.precedence.html)）。"},{"type":4,"line":"**Example #1 逻辑运算符示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"// --------------------  "},{"type":4,"line":"// foo() 根本没机会被调用，被运算符“短路”了  "},{"type":4,"line":"  "},{"type":4,"line":"$a = (false && foo());  "},{"type":4,"line":"$b = (true  || foo());  "},{"type":4,"line":"$c = (false and foo());  "},{"type":4,"line":"$d = (true  or  foo());  "},{"type":4,"line":"  "},{"type":4,"line":"// --------------------  "},{"type":4,"line":"// \"||\" 比 \"or\" 的优先级高  "},{"type":4,"line":"  "},{"type":4,"line":"// 表达式 (false || true) 的结果被赋给 $e  "},{"type":4,"line":"// 等同于：($e = (false || true))  "},{"type":4,"line":"$e = false || true;  "},{"type":4,"line":"  "},{"type":4,"line":"// 常量 false 被赋给 $f，true 被忽略  "},{"type":4,"line":"// 等同于：(($f = false) or true)  "},{"type":4,"line":"$f = false or true;  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($e, $f);  "},{"type":4,"line":"  "},{"type":4,"line":"// --------------------  "},{"type":4,"line":"// \"&&\" 比 \"and\" 的优先级高  "},{"type":4,"line":"  "},{"type":4,"line":"// 表达式 (true && false) 的结果被赋给 $g  "},{"type":4,"line":"// 等同于：($g = (true && false))  "},{"type":4,"line":"$g = true && false;  "},{"type":4,"line":"  "},{"type":4,"line":"// 常量 true 被赋给 $h，false 被忽略  "},{"type":4,"line":"// 等同于：(($h = true) and false)  "},{"type":4,"line":"$h = true and false;  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($g, $h);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"bool(true)"},{"type":3,"line":"6.10 字符串运算符"},{"type":4,"line":"有两个字符串（[string](language.types.string.html)）运算符。第一个是连接运算符（“.”），它返回其左右参数连接后的字符串。第二个是连接赋值运算符（“.=”），它将右边参数附加到左边的参数之后。更多信息见[赋值运算符](language.operators.assignment.html)。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = \"Hello \";  "},{"type":4,"line":"$b = $a . \"World!\"; // now $b contains \"Hello World!\"  "},{"type":4,"line":"  "},{"type":4,"line":"$a = \"Hello \";  "},{"type":4,"line":"$a .= \"World!\";     // now $a contains \"Hello World!\"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见[字符串类型](language.types.string.html)和[字符串函数](ref.strings.html)章节。"},{"type":3,"line":"6.11 数组运算符"},{"type":4,"line":"**数组运算符**"},{"type":4,"line":"例子"},{"type":4,"line":"名称"},{"type":4,"line":"结果"},{"type":4,"line":"$a + $b"},{"type":4,"line":"联合"},{"type":4,"line":"$a 和 $b 的联合。"},{"type":4,"line":"$a == $b"},{"type":4,"line":"相等"},{"type":4,"line":"如果 $a 和 $b 具有相同的键／值对则为 **`TRUE`**。"},{"type":4,"line":"$a === $b"},{"type":4,"line":"全等"},{"type":4,"line":"如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 **`TRUE`**。"},{"type":4,"line":"$a != $b"},{"type":4,"line":"不等"},{"type":4,"line":"如果 $a 不等于 $b 则为 **`TRUE`**。"},{"type":4,"line":"$a <> $b"},{"type":4,"line":"不等"},{"type":4,"line":"如果 $a 不等于 $b 则为 **`TRUE`**。"},{"type":4,"line":"$a !== $b"},{"type":4,"line":"不全等"},{"type":4,"line":"如果 $a 不全等于 $b 则为 **`TRUE`**。"},{"type":4,"line":"_+_ 运算符把右边的数组元素附加到左边的数组后面，两个数组中都有的键名，则只用左边数组中的，右边的被忽略。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = array(\"a\" => \"apple\", \"b\" => \"banana\");  "},{"type":4,"line":"$b = array(\"a\" => \"pear\", \"b\" => \"strawberry\", \"c\" => \"cherry\");  "},{"type":4,"line":"  "},{"type":4,"line":"$c = $a + $b; // Union of $a and $b  "},{"type":4,"line":"echo \"Union of \\$a and \\$b: \\n\";  "},{"type":4,"line":"var_dump($c);  "},{"type":4,"line":"  "},{"type":4,"line":"$c = $b + $a; // Union of $b and $a  "},{"type":4,"line":"echo \"Union of \\$b and \\$a: \\n\";  "},{"type":4,"line":"var_dump($c);  "},{"type":4,"line":"  "},{"type":4,"line":"$a += $b; // Union of $a += $b is $a and $b  "},{"type":4,"line":"echo \"Union of \\$a += \\$b: \\n\";  "},{"type":4,"line":"var_dump($a);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"执行后，此脚本会显示："},{"type":4,"line":"Union of $a and $b:"},{"type":4,"line":"array(3) {"},{"type":4,"line":"  \\[\"a\"\\]=>"},{"type":4,"line":"  string(5) \"apple\""},{"type":4,"line":"  \\[\"b\"\\]=>"},{"type":4,"line":"  string(6) \"banana\""},{"type":4,"line":"  \\[\"c\"\\]=>"},{"type":4,"line":"  string(6) \"cherry\""},{"type":4,"line":"}"},{"type":4,"line":"Union of $b and $a:"},{"type":4,"line":"array(3) {"},{"type":4,"line":"  \\[\"a\"\\]=>"},{"type":4,"line":"  string(4) \"pear\""},{"type":4,"line":"  \\[\"b\"\\]=>"},{"type":4,"line":"  string(10) \"strawberry\""},{"type":4,"line":"  \\[\"c\"\\]=>"},{"type":4,"line":"  string(6) \"cherry\""},{"type":4,"line":"}"},{"type":4,"line":"Union of $a += $b:"},{"type":4,"line":"array(3) {"},{"type":4,"line":"  'a' =>"},{"type":4,"line":"  string(5) \"apple\""},{"type":4,"line":"  'b' =>"},{"type":4,"line":"  string(6) \"banana\""},{"type":4,"line":"  'c' =>"},{"type":4,"line":"  string(6) \"cherry\""},{"type":4,"line":"}"},{"type":4,"line":"数组中的单元如果具有相同的键名和值则比较时相等。"},{"type":4,"line":"**Example #1 比较数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = array(\"apple\", \"banana\");  "},{"type":4,"line":"$b = array(1 => \"banana\", \"0\" => \"apple\");  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($a == $b); // bool(true)  "},{"type":4,"line":"var_dump($a === $b); // bool(false)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见[数组类型](language.types.array.html)和[数组函数](ref.array.html)章节。"},{"type":3,"line":"6.12 类型运算符"},{"type":4,"line":"_instanceof_ 用于确定一个 PHP 变量是否属于某一类 [class](language.oop5.basic.html#language.oop5.basic.class) 的实例："},{"type":4,"line":"**Example #1 对类使用 _instanceof_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyClass  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class NotMyClass  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($a instanceof MyClass);  "},{"type":4,"line":"var_dump($a instanceof NotMyClass);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"_instanceof_　也可用来确定一个变量是不是继承自某一父类的子类的实例："},{"type":4,"line":"**Example #2 对继承类使用 _instanceof_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class ParentClass  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class MyClass extends ParentClass  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($a instanceof MyClass);  "},{"type":4,"line":"var_dump($a instanceof ParentClass);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(true)"},{"type":4,"line":"检查一个对象是否_不是_某个类的实例，可以使用[逻辑运算符 _not_](language.operators.logical.html)。"},{"type":4,"line":"**Example #3 使用 _instanceof_ 检查对象_不是_某个类的实例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyClass  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"var_dump(!($a instanceof stdClass));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(true)"},{"type":4,"line":"最后，_instanceof_也可用于确定一个变量是不是实现了某个[接口](language.oop5.interfaces.html)的对象的实例:"},{"type":4,"line":"**Example #4 对接口使用 _instanceof_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"interface MyInterface  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class MyClass implements MyInterface  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($a instanceof MyClass);  "},{"type":4,"line":"var_dump($a instanceof MyInterface);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(true)"},{"type":4,"line":"虽然 _instanceof_ 通常直接与类名一起使用，但也可以使用对象或字符串变量："},{"type":4,"line":"**Example #5 对其它变量使用 _instanceof_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"interface MyInterface  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class MyClass implements MyInterface  "},{"type":4,"line":"{  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new MyClass;  "},{"type":4,"line":"$b = new MyClass;  "},{"type":4,"line":"$c = 'MyClass';  "},{"type":4,"line":"$d = 'NotMyClass';  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($a instanceof $b); // $b is an object of class MyClass  "},{"type":4,"line":"var_dump($a instanceof $c); // $c is a string 'MyClass'  "},{"type":4,"line":"var_dump($a instanceof $d); // $d is a string 'NotMyClass'  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"如果被检测的变量不是对象，instanceof 并不发出任何错误信息而是返回 **`FALSE`**。不允许用来检测常量。"},{"type":4,"line":"**Example #6 用 _instanceof_ 检测其它变量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"$b = NULL;  "},{"type":4,"line":"$c = imagecreate(5, 5);  "},{"type":4,"line":"var_dump($a instanceof stdClass); // $a is an integer  "},{"type":4,"line":"var_dump($b instanceof stdClass); // $b is NULL  "},{"type":4,"line":"var_dump($c instanceof stdClass); // $c is a resource  "},{"type":4,"line":"var_dump(FALSE instanceof stdClass);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(false)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"bool(false)"},{"type":4,"line":"PHP Fatal error:  instanceof expects an object instance, constant given"},{"type":4,"line":"然而 instanceof 的使用还有一些陷阱必须了解。在 PHP 5.1.0 之前，如果要检查的类名称不存在，_instanceof_ 会调用 [\\_\\_autoload()](function.autoload.html)。另外，如果该类没有被装载则会产生一个致命错误。可以通过使用动态类引用或用一个包含类名的字符串变量来避开这种问题："},{"type":4,"line":"**Example #7 避免 PHP 5.0 中 instanceof 引起的类名查找和致命错误问题**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$d = 'NotMyClass';  "},{"type":4,"line":"var_dump($a instanceof $d); // no fatal error here  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(false)"},{"type":4,"line":"_instanceof_ 运算符是 PHP 5 引进的。在此之前用 [is\\_a()](function.is-a.html)，但是后来 [is\\_a()](function.is-a.html) 被废弃而用 _instanceof_ 替代了。注意自 PHP 5.3.0 起，又恢复使用 [is\\_a()](function.is-a.html) 了。"},{"type":4,"line":"参见 [get\\_class()](function.get-class.html) 和 [is\\_a()](function.is-a.html)。"},{"type":1,"line":"7. 流程控制"},{"type":4,"line":"7.1 简介"},{"type":4,"line":"--"},{"type":4,"line":"任何 PHP 脚本都是由一系列语句构成的。一条语句可以是一个赋值语句，一个函数调用，一个循环，一个条件语句或者甚至是一个什么也不做的语句（空语句）。语句通常以分号结束。此外，还可以用花括号将一组语句封装成一个语句组。语句组本身可以当作是一行语句。本章介绍了各种语句类型。"},{"type":3,"line":"7.2 _if_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_if_ 结构是很多语言包括 PHP 在内最重要的特性之一，它允许按照条件执行代码片段。PHP 的 _if_ 结构和 C 语言相似："},{"type":4,"line":"```php"},{"type":4,"line":"<?php"},{"type":4,"line":"if (expr)"},{"type":4,"line":"  statement"},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"如同在[表达式](language.expressions.html)一章中定义的，expr 按照布尔求值。如果 expr 的值为 **`TRUE`**，PHP 将执行 statement，如果值为 **`FALSE`** ——将忽略 statement。有关哪些值被视为 **`FALSE`** 的更多信息参见[转换为布尔值](language.types.boolean.html#language.types.boolean.casting)一节。"},{"type":4,"line":"如果 $a 大于 $b，则以下例子将显示 a is bigger than b："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"if ($a > $b)  "},{"type":4,"line":"  echo \"a is bigger than b\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"经常需要按照条件执行不止一条语句，当然并不需要给每条语句都加上一个 _if_ 子句。可以将这些语句放入语句组中。例如，如果 $a 大于 $b，以下代码将显示 a is bigger than b 并且将 $a 的值赋给 $b："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"if ($a > $b) {  "},{"type":4,"line":"  echo \"a is bigger than b\";  "},{"type":4,"line":"  $b = $a;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"_if_ 语句可以无限层地嵌套在其它 _if_ 语句中，这给程序的不同部分的条件执行提供了充分的弹性。"},{"type":3,"line":"7.3 _else_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"经常需要在满足某个条件时执行一条语句，而在不满足该条件时执行其它语句，这正是 _else_ 的功能。_else_ 延伸了 _if_ 语句，可以在 _if_ 语句中的表达式的值为 **`FALSE`** 时执行语句。例如以下代码在 $a 大于 $b 时显示 a is bigger than b，反之则显示 a is NOT bigger than b："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"if ($a > $b) {  "},{"type":4,"line":"  echo \"a is greater than b\";  "},{"type":4,"line":"} else {  "},{"type":4,"line":"  echo \"a is NOT greater than b\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"_else_ 语句仅在 _if_ 以及 _elseif_（如果有的话）语句中的表达式的值为 **`FALSE`** 时执行（参见 [elseif](control-structures.elseif.html)）。"},{"type":3,"line":"7.4 _elseif_/_else if_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_elseif_，和此名称暗示的一样，是 _if_ 和 _else_ 的组合。和 _else_ 一样，它延伸了 _if_ 语句，可以在原来的 _if_ 表达式值为 **`FALSE`** 时执行不同语句。但是和 _else_ 不一样的是，它仅在 _elseif_ 的条件表达式值为 **`TRUE`** 时执行语句。例如以下代码将根据条件分别显示 a is bigger than b，a equal to b 或者 a is smaller than b："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"if ($a > $b) {  "},{"type":4,"line":"    echo \"a is bigger than b\";  "},{"type":5,"line":"} elseif ($a == $b) {  "},{"type":4,"line":"    echo \"a is equal to b\";  "},{"type":5,"line":"} else {  "},{"type":4,"line":"    echo \"a is smaller than b\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在同一个 _if_ 语句中可以有多个 _elseif_ 部分，其中第一个表达式值为 **`TRUE`**（如果有的话）的 _elseif_ 部分将会执行。在 PHP 中，也可以写成“else if”（两个单词），它和“elseif”（一个单词）的行为完全一样。句法分析的含义有少许区别（如果你熟悉 C 语言的话，与之行为相同），但是底线是两者会产生完全一样的行为。"},{"type":4,"line":"_elseif_ 的语句仅在之前的 _if_ 和所有之前 _elseif_ 的表达式值为 **`FALSE`**，并且当前的 _elseif_ 表达式值为 **`TRUE`** 时执行。"},{"type":4,"line":"> **Note**: 必须要注意的是 _elseif_ 与 _else if_ 只有在类似上例中使用花括号的情况下才认为是完全相同。如果用冒号来定义 _if_/_elseif_ 条件，那就不能用两个单词的 _else if_，否则 PHP 会产生解析错误。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"/* 不正确的使用方法： */  "},{"type":5,"line":"if ($a > $b):  "},{"type":4,"line":"    echo $a.\" is greater than \".$b;  "},{"type":5,"line":"else if ($a == $b): // 将无法编译  "},{"type":4,"line":"    echo \"The above line causes a parse error.\";  "},{"type":4,"line":"endif;  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"/* 正确的使用方法： */  "},{"type":5,"line":"if ($a > $b):  "},{"type":4,"line":"    echo $a.\" is greater than \".$b;  "},{"type":5,"line":"elseif ($a == $b): // 注意使用了一个单词的 elseif  "},{"type":4,"line":"    echo $a.\" equals \".$b;  "},{"type":5,"line":"else:  "},{"type":4,"line":"    echo $a.\" is neither greater than or equal to \".$b;  "},{"type":4,"line":"endif;  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"7.5 流程控制的替代语法"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"PHP 提供了一些流程控制的替代语法，包括 _if_，_while_，_for_，_foreach_ 和 _switch_。替代语法的基本形式是把左花括号（{）换成冒号（:），把右花括号（}）分别换成 _endif;_，_endwhile;_，_endfor;_，_endforeach;_ 以及 _endswitch;_。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php if ($a == 5): ?>  "},{"type":4,"line":"A is equal to 5  "},{"type":4,"line":"<?php endif; ?>"},{"type":4,"line":"```"},{"type":4,"line":"在上面的例子中，HTML 内容“A is equal to 5”用替代语法嵌套在 _if_ 语句中。该 HTML 的内容仅在 $a 等于 5 时显示。"},{"type":4,"line":"替代语法同样可以用在 _else_ 和 _elseif_ 中。下面是一个包括 _elseif_ 和 _else_ 的 _if_ 结构用替代语法格式写的例子："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"if ($a == 5):  "},{"type":5,"line":"    echo \"a equals 5\";  "},{"type":4,"line":"    echo \"...\";  "},{"type":5,"line":"elseif ($a == 6):  "},{"type":5,"line":"    echo \"a equals 6\";  "},{"type":4,"line":"    echo \"!!!\";  "},{"type":5,"line":"else:  "},{"type":4,"line":"    echo \"a is neither 5 nor 6\";  "},{"type":4,"line":"endif;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 不支持在同一个控制块内混合使用两种语法。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"_switch_ 和第一个 _case_ 之间的任何输出（含空格）将导致语法错误。例如，这样是无效的："},{"type":4,"line":"```php"},{"type":5,"line":"<?php switch ($foo): ?>  "},{"type":5,"line":"    <?php case 1: ?>  "},{"type":4,"line":"    ...  "},{"type":4,"line":"<?php endswitch ?>"},{"type":4,"line":"```"},{"type":4,"line":"而这样是有效的，因为 _switch_ 之后的换行符被认为是结束标记 _?>_ 的一部分，所以在 _switch_ 和 _case_ 之间不能有任何输出："},{"type":4,"line":"```php"},{"type":4,"line":"<?php switch ($foo): ?>  "},{"type":5,"line":"<?php case 1: ?>  "},{"type":4,"line":"    ...  "},{"type":4,"line":"<?php endswitch ?>"},{"type":4,"line":"```"},{"type":4,"line":"更多例子参见 [while](control-structures.while.html)，[for](control-structures.for.html) 和 [if](control-structures.if.html)。"},{"type":3,"line":"7.6 _while_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_while_ 循环是 PHP 中最简单的循环类型。它和 C 语言中的 _while_ 表现地一样。_while_ 语句的基本格式是："},{"type":5,"line":"while (expr)"},{"type":4,"line":"    statement"},{"type":4,"line":"_while_ 语句的含意很简单，它告诉 PHP 只要 _while_ 表达式的值为 **`TRUE`** 就重复执行嵌套中的循环语句。表达式的值在每次开始循环时检查，所以即使这个值在循环语句中改变了，语句也不会停止执行，直到本次循环结束。有时候如果 _while_ 表达式的值一开始就是 **`FALSE`**，则循环语句一次都不会执行。"},{"type":4,"line":"和 _if_ 语句一样，可以在 _while_ 循环中用花括号括起一个语句组，或者用替代语法："},{"type":5,"line":"while (expr):"},{"type":5,"line":"    statement"},{"type":4,"line":"    ..."},{"type":4,"line":"endwhile;"},{"type":4,"line":"下面两个例子完全一样，都显示数字 1 到 10："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* example 1 */  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 1;  "},{"type":5,"line":"while ($i <= 10) {  "},{"type":5,"line":"    echo $i++;  /* the printed value would be  "},{"type":5,"line":"                    $i before the increment  "},{"type":4,"line":"                    (post-increment) */  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* example 2 */  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 1;  "},{"type":5,"line":"while ($i <= 10):  "},{"type":5,"line":"    print $i;  "},{"type":4,"line":"    $i++;  "},{"type":4,"line":"endwhile;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"7.7 _do-while_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_do-while_ 循环和 _while_ 循环非常相似，区别在于表达式的值是在每次循环结束时检查而不是开始时。和一般的 _while_ 循环主要的区别是 _do-while_ 的循环语句保证会执行一次（表达式的真值在每次循环结束后检查），然而在一般的 _while_ 循环中就不一定了（表达式真值在循环开始时检查，如果一开始就为 **`FALSE`** 则整个循环立即终止）。"},{"type":4,"line":"_do-while_ 循环只有一种语法："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$i = 0;  "},{"type":5,"line":"do {  "},{"type":4,"line":"   echo $i;  "},{"type":4,"line":"} while ($i > 0);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上循环将正好运行一次，因为经过第一次循环后，当检查表达式的真值时，其值为 **`FALSE`**（$i 不大于 0）而导致循环终止。"},{"type":4,"line":"资深的 C 语言用户可能熟悉另一种不同的 _do-while_ 循环用法，把语句放在 _do-while_(0) 之中，在循环内部用 [_break_](control-structures.break.html) 语句来结束执行循环。以下代码片段示范了此方法："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"do {  "},{"type":5,"line":"    if ($i < 5) {  "},{"type":5,"line":"        echo \"i is not big enough\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    $i *= $factor;  "},{"type":5,"line":"    if ($i < $minimum_limit) {  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    echo \"i is ok\";  "},{"type":5,"line":"  "},{"type":4,"line":"    /* process i */  "},{"type":4,"line":"  "},{"type":4,"line":"} while(0);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"如果还不能立刻理解也不用担心。即使不用此“特性”也照样可以写出强大的代码来。自 PHP 5.3.0 起，还可以使用 [_goto_](control-structures.goto.html) 来跳出循环。"},{"type":3,"line":"7.8 _for_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_for_ 循环是 PHP 中最复杂的循环结构。它的行为和 C 语言的相似。 _for_ 循环的语法是："},{"type":5,"line":"for (expr1; expr2; expr3)"},{"type":4,"line":"    statement"},{"type":4,"line":"第一个表达式（expr1）在循环开始前无条件求值（并执行）一次。"},{"type":4,"line":"expr2 在每次循环开始前求值。如果值为 **`TRUE`**，则继续循环，执行嵌套的循环语句。如果值为 **`FALSE`**，则终止循环。"},{"type":4,"line":"expr3 在每次循环之后被求值（并执行）。"},{"type":4,"line":"每个表达式都可以为空或包括逗号分隔的多个表达式。表达式 expr2 中，所有用逗号分隔的表达式都会计算，但只取最后一个结果。expr2 为空意味着将无限循环下去（和 C 一样，PHP 暗中认为其值为 **`TRUE`**）。这可能不像想象中那样没有用，因为经常会希望用有条件的 [_break_](control-structures.break.html) 语句来结束循环而不是用 _for_ 的表达式真值判断。"},{"type":4,"line":"考虑以下的例子，它们都显示数字 1 到 10："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* example 1 */  "},{"type":4,"line":"  "},{"type":5,"line":"for ($i = 1; $i <= 10; $i++) {  "},{"type":4,"line":"    echo $i;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* example 2 */  "},{"type":4,"line":"  "},{"type":5,"line":"for ($i = 1; ; $i++) {  "},{"type":5,"line":"    if ($i > 10) {  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    echo $i;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* example 3 */  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 1;  "},{"type":5,"line":"for (;;) {  "},{"type":5,"line":"    if ($i > 10) {  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    echo $i;  "},{"type":4,"line":"    $i++;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* example 4 */  "},{"type":4,"line":"  "},{"type":4,"line":"for ($i = 1, $j = 0; $i <= 10; $j += $i, print $i, $i++);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当然，第一个例子看上去最简洁（或者有人认为是第四个），但用户可能会发现在 _for_ 循环中用空的表达式在很多场合下会很方便。"},{"type":4,"line":"PHP 也支持用冒号的 _for_ 循环的替代语法。"},{"type":5,"line":"for (expr1; expr2; expr3):"},{"type":5,"line":"    statement;"},{"type":4,"line":"    ..."},{"type":4,"line":"endfor;"},{"type":4,"line":"有时经常需要像下面这样例子一样对数组进行遍历："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/*  "},{"type":4,"line":" * 此数组将在遍历的过程中改变其中某些单元的值  "},{"type":4,"line":" */  "},{"type":5,"line":"$people = Array(  "},{"type":5,"line":"        Array('name' => 'Kalle', 'salt' => 856412),   "},{"type":5,"line":"        Array('name' => 'Pierre', 'salt' => 215863)  "},{"type":4,"line":"        );  "},{"type":4,"line":"  "},{"type":4,"line":"for($i = 0; $i < count($people); ++$i)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $people[$i]['salt'] = rand(000000, 999999);  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上代码可能执行很慢，因为每次循环时都要计算一遍数组的长度。由于数组的长度始终不变，可以用一个中间变量来储存数组长度以优化而不是不停调用 [count()](function.count.html)："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$people = Array(  "},{"type":5,"line":"        Array('name' => 'Kalle', 'salt' => 856412),   "},{"type":5,"line":"        Array('name' => 'Pierre', 'salt' => 215863)  "},{"type":4,"line":"        );  "},{"type":4,"line":"  "},{"type":4,"line":"for($i = 0, $size = count($people); $i < $size; ++$i)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $people[$i]['salt'] = rand(000000, 999999);  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"7.9 _foreach_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_foreach_ 语法结构提供了遍历数组的简单方式。_foreach_ 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法："},{"type":5,"line":"foreach (array\\_expression as $value)"},{"type":4,"line":"    statement"},{"type":5,"line":"foreach (array\\_expression as $key => $value)"},{"type":4,"line":"    statement"},{"type":4,"line":"第一种格式遍历给定的 _array\\_expression_ 数组。每次循环中，当前单元的值被赋给 _$value_ 并且数组内部的指针向前移一步（因此下一次循环中将会得到下一个单元）。"},{"type":4,"line":"第二种格式做同样的事，只除了当前单元的键名也会在每次循环中被赋给变量 _$key_。"},{"type":4,"line":"还能够自定义[遍历对象](language.oop5.iterations.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 当 _foreach_ 开始执行时，数组内部的指针会自动指向第一个单元。这意味着不需要在 _foreach_ 循环之前调用 [reset()](function.reset.html)。"},{"type":4,"line":"> "},{"type":4,"line":"> 由于 _foreach_ 依赖内部数组指针，在循环中修改其值将可能导致意外的行为。"},{"type":4,"line":"可以很容易地通过在 _$value_ 之前加上 & 来修改数组的元素。此方法将以[引用](language.references.html)赋值而不是拷贝一个值。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$arr = array(1, 2, 3, 4);  "},{"type":5,"line":"foreach ($arr as &$value) {  "},{"type":4,"line":"    $value = $value * 2;  "},{"type":4,"line":"}  "},{"type":4,"line":"// $arr is now array(2, 4, 6, 8)  "},{"type":4,"line":"unset($value); // 最后取消掉引用  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"_$value_ 的引用仅在被遍历的数组可以被引用时才可用（例如是个变量）。以下代码则无法运行："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"foreach (array(1, 2, 3, 4) as &$value) {  "},{"type":4,"line":"    $value = $value * 2;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Warning**"},{"type":4,"line":"数组最后一个元素的 _$value_ 引用在 _foreach_ 循环之后仍会保留。建议使用 [unset()](function.unset.html) 来将其销毁。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> _foreach_ 不支持用“@”来抑制错误信息的能力。"},{"type":4,"line":"用户可能注意到了以下的代码功能完全相同："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$arr = array(\"one\", \"two\", \"three\");  "},{"type":4,"line":"reset($arr);  "},{"type":5,"line":"while (list(, $value) = each($arr)) {  "},{"type":4,"line":"    echo \"Value: $value<br>\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($arr as $value) {  "},{"type":4,"line":"    echo \"Value: $value<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以下代码功能也完全相同："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$arr = array(\"one\", \"two\", \"three\");  "},{"type":4,"line":"reset($arr);  "},{"type":5,"line":"while (list($key, $value) = each($arr)) {  "},{"type":4,"line":"    echo \"Key: $key; Value: $value<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($arr as $key => $value) {  "},{"type":4,"line":"    echo \"Key: $key; Value: $value<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"示范用法的更多例子："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/* foreach example 1: value only */  "},{"type":4,"line":"  "},{"type":4,"line":"$a = array(1, 2, 3, 17);  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($a as $v) {  "},{"type":4,"line":"   echo \"Current value of \\$a: $v.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* foreach example 2: value (with its manual access notation printed for illustration) */  "},{"type":4,"line":"  "},{"type":4,"line":"$a = array(1, 2, 3, 17);  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 0; /* for illustrative purposes only */  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($a as $v) {  "},{"type":5,"line":"    echo \"\\$a[$i] => $v.\\n\";  "},{"type":4,"line":"    $i++;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* foreach example 3: key and value */  "},{"type":4,"line":"  "},{"type":5,"line":"$a = array(  "},{"type":5,"line":"    \"one\" => 1,  "},{"type":5,"line":"    \"two\" => 2,  "},{"type":5,"line":"    \"three\" => 3,  "},{"type":4,"line":"    \"seventeen\" => 17  "},{"type":4,"line":");  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($a as $k => $v) {  "},{"type":4,"line":"    echo \"\\$a[$k] => $v.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* foreach example 4: multi-dimensional arrays */  "},{"type":4,"line":"$a = array();  "},{"type":4,"line":"$a[0][0] = \"a\";  "},{"type":4,"line":"$a[0][1] = \"b\";  "},{"type":4,"line":"$a[1][0] = \"y\";  "},{"type":4,"line":"$a[1][1] = \"z\";  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($a as $v1) {  "},{"type":5,"line":"    foreach ($v1 as $v2) {  "},{"type":5,"line":"        echo \"$v2\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* foreach example 5: dynamic arrays */  "},{"type":4,"line":"  "},{"type":5,"line":"foreach (array(1, 2, 3, 4, 5) as $v) {  "},{"type":4,"line":"    echo \"$v\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 用 list() 给嵌套的数组解包"},{"type":4,"line":"(PHP 5 >= 5.5.0, PHP 7)"},{"type":4,"line":"PHP 5.5 增添了遍历一个数组的数组的功能并且把嵌套的数组解包到循环变量中，只需将 [list()](function.list.html) 作为值提供。"},{"type":4,"line":"例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = [  "},{"type":5,"line":"    [1, 2],  "},{"type":4,"line":"    [3, 4],  "},{"type":4,"line":"];  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($array as list($a, $b)) {  "},{"type":5,"line":"    // $a contains the first element of the nested array,  "},{"type":5,"line":"    // and $b contains the second element.  "},{"type":4,"line":"    echo \"A: $a; B: $b\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"A: 1; B: 2"},{"type":4,"line":"A: 3; B: 4"},{"type":4,"line":"[list()](function.list.html) 中的单元可以少于嵌套数组的，此时多出来的数组单元将被忽略："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = [  "},{"type":5,"line":"    [1, 2],  "},{"type":4,"line":"    [3, 4],  "},{"type":4,"line":"];  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($array as list($a)) {  "},{"type":5,"line":"    // Note that there is no $b here.  "},{"type":4,"line":"    echo \"$a\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"1"},{"type":4,"line":"3"},{"type":4,"line":"如果 [list()](function.list.html) 中列出的单元多于嵌套数组则会发出一条消息级别的错误信息："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"$array = [  "},{"type":5,"line":"    [1, 2],  "},{"type":4,"line":"    [3, 4],  "},{"type":4,"line":"];  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($array as list($a, $b, $c)) {  "},{"type":4,"line":"    echo \"A: $a; B: $b; C: $c\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Notice: Undefined offset: 2 in example.php on line 7"},{"type":4,"line":"A: 1; B: 2; C: "},{"type":4,"line":"Notice: Undefined offset: 2 in example.php on line 7"},{"type":4,"line":"A: 3; B: 4; C:"},{"type":3,"line":"7.10 _break_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_break_ 结束当前 _for_，_foreach_，_while_，_do-while_ 或者 _switch_ 结构的执行。"},{"type":4,"line":"_break_ 可以接受一个可选的数字参数来决定跳出几重循环。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$arr = array('one', 'two', 'three', 'four', 'stop', 'five');  "},{"type":5,"line":"while (list (, $val) = each($arr)) {  "},{"type":5,"line":"    if ($val == 'stop') {  "},{"type":5,"line":"        break;    /* You could also write 'break 1;' here. */  "},{"type":5,"line":"    }  "},{"type":4,"line":"    echo \"$val<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* 使用可选参数 */  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 0;  "},{"type":5,"line":"while (++$i) {  "},{"type":5,"line":"    switch ($i) {  "},{"type":5,"line":"    case 5:  "},{"type":5,"line":"        echo \"At 5<br />\\n\";  "},{"type":5,"line":"        break 1;  /* 只退出 switch. */  "},{"type":5,"line":"    case 10:  "},{"type":5,"line":"        echo \"At 10; quitting<br />\\n\";  "},{"type":5,"line":"        break 2;  /* 退出 switch 和 while 循环 */  "},{"type":5,"line":"    default:  "},{"type":5,"line":"        break;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**_break_ 的更新记录**"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.4.0"},{"type":4,"line":"_break 0;_ 不再合法。这在之前的版本被解析为 _break 1;_。"},{"type":4,"line":"5.4.0"},{"type":4,"line":"取消变量作为参数传递（例如 _$num = 2; break $num;_）。"},{"type":3,"line":"7.11 _continue_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_continue_ 在循环结构用用来跳过本次循环中剩余的代码并在条件求值为真时开始执行下一次循环。"},{"type":4,"line":"> **Note**: 注意在 PHP 中 [switch](control-structures.switch.html) 语句被认为是可以使用 _continue_ 的一种循环结构。"},{"type":4,"line":"_continue_ 接受一个可选的数字参数来决定跳过几重循环到循环结尾。默认值是 _1_，即跳到当前循环末尾。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"while (list ($key, $value) = each($arr)) {  "},{"type":5,"line":"    if (!($key % 2)) { // skip odd members  "},{"type":5,"line":"        continue;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    do_something_odd($value);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$i = 0;  "},{"type":5,"line":"while ($i++ < 5) {  "},{"type":5,"line":"    echo \"Outer<br />\\n\";  "},{"type":5,"line":"    while (1) {  "},{"type":5,"line":"        echo \"Middle<br />\\n\";  "},{"type":5,"line":"        while (1) {  "},{"type":5,"line":"            echo \"Inner<br />\\n\";  "},{"type":5,"line":"            continue 3;  "},{"type":5,"line":"        }  "},{"type":5,"line":"        echo \"This never gets output.<br />\\n\";  "},{"type":5,"line":"    }  "},{"type":4,"line":"    echo \"Neither does this.<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"省略 _continue_ 后面的分号会导致混淆。以下例子示意了不应该这样做。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"  for ($i = 0; $i < 5; ++$i) {  "},{"type":5,"line":"      if ($i == 2)  "},{"type":5,"line":"          continue  "},{"type":4,"line":"      print \"$i\\n\";  "},{"type":4,"line":"  }  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"希望得到的结果是："},{"type":4,"line":"0"},{"type":4,"line":"1"},{"type":4,"line":"3"},{"type":4,"line":"4"},{"type":4,"line":"可实际的输出是："},{"type":4,"line":"2"},{"type":4,"line":"因为整个 _continue print \"$i\\\\n\";_ 被当做单一的表达式而求值，所以 [print](function.print.html) 函数只有在 _$i == 2_ 为真时才被调用（_print_ 的值被当成了上述的可选数字参数而传递给了 _continue_）。"},{"type":4,"line":"**_continue_ 的更新记录**"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.4.0"},{"type":4,"line":"_continue 0;_ 不再合法。这在之前的版本被解析为 _continue 1;_。"},{"type":4,"line":"5.4.0"},{"type":4,"line":"取消变量作为参数传递（例如 _$num = 2; continue $num;_）。"},{"type":3,"line":"7.12 _switch_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_switch_ 语句类似于具有同一个表达式的一系列 _if_ 语句。很多场合下需要把同一个变量（或表达式）与很多不同的值比较，并根据它等于哪个值来执行不同的代码。这正是 _switch_ 语句的用途。"},{"type":4,"line":"> **Note**: 注意和其它语言不同，[continue](control-structures.continue.html) 语句作用到 switch 上的作用类似于 _break_。如果在循环中有一个 switch 并希望 continue 到外层循环中的下一轮循环，用 _continue 2_。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 注意 switch/case 作的是[松散比较](types.comparisons.html#types.comparisions-loose)。"},{"type":4,"line":"下面两个例子使用两种不同方法实现同样的事，一个用一系列的 _if_ 和 _elseif_ 语句，另一个用 _switch_ 语句："},{"type":4,"line":"**Example #1 _switch_ 结构**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"if ($i == 0) {  "},{"type":4,"line":"    echo \"i equals 0\";  "},{"type":5,"line":"} elseif ($i == 1) {  "},{"type":4,"line":"    echo \"i equals 1\";  "},{"type":5,"line":"} elseif ($i == 2) {  "},{"type":4,"line":"    echo \"i equals 2\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"switch ($i) {  "},{"type":5,"line":"    case 0:  "},{"type":5,"line":"        echo \"i equals 0\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 1:  "},{"type":5,"line":"        echo \"i equals 1\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 2:  "},{"type":5,"line":"        echo \"i equals 2\";  "},{"type":4,"line":"        break;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 _switch_ 结构可以用字符串**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"switch ($i) {  "},{"type":5,"line":"case \"apple\":  "},{"type":5,"line":"    echo \"i is apple\";  "},{"type":4,"line":"    break;  "},{"type":5,"line":"case \"bar\":  "},{"type":5,"line":"    echo \"i is bar\";  "},{"type":4,"line":"    break;  "},{"type":5,"line":"case \"cake\":  "},{"type":5,"line":"    echo \"i is cake\";  "},{"type":4,"line":"    break;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"为避免错误，理解 _switch_ 是怎样执行的非常重要。_switch_ 语句一行接一行地执行（实际上是语句接语句）。开始时没有代码被执行。仅当一个 _case_ 语句中的值和 _switch_ 表达式的值匹配时 PHP 才开始执行语句，直到 _switch_ 的程序段结束或者遇到第一个 _break_ 语句为止。如果不在 case 的语句段最后写上 _break_ 的话，PHP 将继续执行下一个 case 中的语句段。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"switch ($i) {  "},{"type":5,"line":"    case 0:  "},{"type":5,"line":"        echo \"i equals 0\";  "},{"type":5,"line":"    case 1:  "},{"type":5,"line":"        echo \"i equals 1\";  "},{"type":5,"line":"    case 2:  "},{"type":4,"line":"        echo \"i equals 2\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"这里如果 $i 等于 0，PHP 将执行所有的 echo 语句！如果 $i 等于 1，PHP 将执行后面两条 echo 语句。只有当 $i 等于 2 时，才会得到“预期”的结果——只显示“i equals 2”。所以，别忘了 _break_ 语句就很重要（即使在某些情况下故意想避免提供它们时）。"},{"type":4,"line":"在 _switch_ 语句中条件只求值一次并用来和每个 _case_ 语句比较。在 _elseif_ 语句中条件会再次求值。如果条件比一个简单的比较要复杂得多或者在一个很多次的循环中，那么用 _switch_ 语句可能会快一些。"},{"type":4,"line":"在一个 case 中的语句也可以为空，这样只不过将控制转移到了下一个 case 中的语句。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"switch ($i) {  "},{"type":5,"line":"    case 0:  "},{"type":5,"line":"    case 1:  "},{"type":5,"line":"    case 2:  "},{"type":5,"line":"        echo \"i is less than 3 but not negative\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 3:  "},{"type":4,"line":"        echo \"i is 3\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"一个 case 的特例是 _default_。它匹配了任何和其它 case 都不匹配的情况。例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"switch ($i) {  "},{"type":5,"line":"    case 0:  "},{"type":5,"line":"        echo \"i equals 0\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 1:  "},{"type":5,"line":"        echo \"i equals 1\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 2:  "},{"type":5,"line":"        echo \"i equals 2\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    default:  "},{"type":4,"line":"        echo \"i is not equal to 0, 1 or 2\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"_case_ 表达式可以是任何求值为简单类型的表达式，即整型或浮点数以及字符串。不能用数组或对象，除非它们被解除引用成为简单类型。"},{"type":4,"line":"_switch_ 支持替代语法的流程控制。更多信息见[流程控制的替代语法](control-structures.alternative-syntax.html)一节。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"switch ($i):  "},{"type":5,"line":"    case 0:  "},{"type":5,"line":"        echo \"i equals 0\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 1:  "},{"type":5,"line":"        echo \"i equals 1\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    case 2:  "},{"type":5,"line":"        echo \"i equals 2\";  "},{"type":5,"line":"        break;  "},{"type":5,"line":"    default:  "},{"type":4,"line":"        echo \"i is not equal to 0, 1 or 2\";  "},{"type":4,"line":"endswitch;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"允许使用分号代替 case 语句后的冒号，例如："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"switch($beer)  "},{"type":5,"line":"{  "},{"type":5,"line":"    case 'tuborg';  "},{"type":5,"line":"    case 'carlsberg';  "},{"type":5,"line":"    case 'heineken';  "},{"type":5,"line":"        echo 'Good choice';  "},{"type":5,"line":"    break;  "},{"type":5,"line":"    default;  "},{"type":5,"line":"        echo 'Please make a new selection...';  "},{"type":4,"line":"    break;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"7.13 _declare_"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_declare_ 结构用来设定一段代码的执行指令。_declare_ 的语法和其它流程控制结构相似："},{"type":5,"line":"declare (directive)"},{"type":4,"line":"    statement"},{"type":4,"line":"_directive_ 部分允许设定 _declare_ 代码段的行为。目前只认识两个指令：_ticks_（更多信息见下面 [ticks](control-structures.declare.html#control-structures.declare.ticks) 指令）以及 _encoding_（更多信息见下面 [encoding](control-structures.declare.html#control-structures.declare.encoding) 指令）。"},{"type":4,"line":"> **Note**: encoding 是 PHP 5.3.0 新增指令。"},{"type":4,"line":"_declare_ 代码段中的 _statement_ 部分将被执行——怎样执行以及执行中有什么副作用出现取决于 _directive_ 中设定的指令。"},{"type":4,"line":"_declare_ 结构也可用于全局范围，影响到其后的所有代码（但如果有 _declare_ 结构的文件被其它文件包含，则对包含它的父文件不起作用）。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// these are the same:  "},{"type":4,"line":"  "},{"type":4,"line":"// you can use this:  "},{"type":5,"line":"declare(ticks=1) {  "},{"type":4,"line":"    // entire script here  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// or you can use this:  "},{"type":4,"line":"declare(ticks=1);  "},{"type":4,"line":"// entire script here  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Ticks"},{"type":4,"line":"Tick（时钟周期）是一个在 _declare_ 代码段中解释器每执行 N 条可计时的低级语句就会发生的事件。N 的值是在 _declare_ 中的 _directive_ 部分用 `ticks=N` 来指定的。"},{"type":4,"line":"不是所有语句都可计时。通常条件表达式和参数表达式都不可计时。"},{"type":4,"line":"在每个 tick 中出现的事件是由 [register\\_tick\\_function()](function.register-tick-function.html) 来指定的。更多细节见下面的例子。注意每个 tick 中可以出现多个事件。"},{"type":4,"line":"**Example #1 Tick 的用法示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"declare(ticks=1);  "},{"type":4,"line":"  "},{"type":4,"line":"// A function called on each tick event  "},{"type":4,"line":"function tick_handler()  "},{"type":5,"line":"{  "},{"type":4,"line":"    echo \"tick_handler() called\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"register_tick_function('tick_handler');  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"  "},{"type":5,"line":"if ($a > 0) {  "},{"type":5,"line":"    $a += 2;  "},{"type":4,"line":"    print($a);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 Ticks 的用法示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"function tick_handler()  "},{"type":4,"line":"{  "},{"type":4,"line":"  echo \"tick_handler() called\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = 1;  "},{"type":4,"line":"tick_handler();  "},{"type":4,"line":"  "},{"type":5,"line":"if ($a > 0) {  "},{"type":5,"line":"    $a += 2;  "},{"type":5,"line":"    tick_handler();  "},{"type":5,"line":"    print($a);  "},{"type":4,"line":"    tick_handler();  "},{"type":4,"line":"}  "},{"type":4,"line":"tick_handler();  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见 [register\\_tick\\_function()](function.register-tick-function.html) 和 [unregister\\_tick\\_function()](function.unregister-tick-function.html)。"},{"type":4,"line":"### Encoding"},{"type":4,"line":"可以用 encoding 指令来对每段脚本指定其编码方式。"},{"type":4,"line":"**Example #3 对脚本指定编码方式**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"declare(encoding='ISO-8859-1');  "},{"type":4,"line":"// code here  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Caution**"},{"type":4,"line":"当和命名空间结合起来时 declare 的唯一合法语法是 _declare(encoding='...');_，其中 _..._ 是编码的值。而 _declare(encoding='...') {}_ 将在与命名空间结合时产生解析错误。"},{"type":4,"line":"在 PHP 5.3 中除非在编译时指定了 _\\--enable-zend-multibyte_，否则 declare 中的 encoding 值会被忽略。"},{"type":4,"line":"注意除非用 [phpinfo()](function.phpinfo.html)，否则 PHP 不会显示出是否在编译时指定了 _\\--enable-zend-multibyte_。"},{"type":4,"line":"参见 [zend.script\\_encoding](ini.core.html#ini.zend.script-encoding)。"},{"type":3,"line":"7.14 return"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"如果在一个函数中调用 **return** 语句，将立即结束此函数的执行并将它的参数作为函数的值返回。**return** 也会终止 [eval()](function.eval.html) 语句或者脚本文件的执行。"},{"type":4,"line":"如果在全局范围中调用，则当前脚本文件中止运行。如果当前脚本文件是被 [include](function.include.html) 的或者 [require](function.require.html) 的，则控制交回调用文件。此外，如果当前脚本是被 [include](function.include.html) 的，则 **return** 的值会被当作 [include](function.include.html) 调用的返回值。如果在主脚本文件中调用 **return**，则脚本中止运行。如果当前脚本文件是在 php.ini 中的配置选项 [auto\\_prepend\\_file](ini.core.html#ini.auto-prepend-file) 或者 [auto\\_append\\_file](ini.core.html#ini.auto-append-file) 所指定的，则此脚本文件中止运行。"},{"type":4,"line":"更多信息见[返回值](functions.returning-values.html)。"},{"type":4,"line":"> **Note**: 注意既然 **return** 是语言结构而不是函数，因此其参数没有必要用括号将其括起来。通常都不用括号，实际上也应该不用，这样可以降低 PHP 的负担。"},{"type":4,"line":"> **Note**: 如果没有提供参数，则一定不能用括号，此时返回 **`NULL`**。如果调用 _return_ 时加上了括号却又没有参数会导致解析错误。"},{"type":4,"line":"> **Note**: 当用引用返回值时_永远不要_使用括号，这样行不通。只能通过引用返回变量，而不是语句的结果。如果使用 _return ($a);_ 时其实不是返回一个变量，而是表达式 _($a)_ 的值（当然，此时该值也正是 $a 的值）。"},{"type":3,"line":"7.15 require"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_require_ 和 [include](function.include.html) 几乎完全一样，除了处理失败的方式不同之外。**require** 在出错时产生 **`E_COMPILE_ERROR`** 级别的错误。换句话说将导致脚本中止而 [include](function.include.html) 只产生警告（**`E_WARNING`**），脚本会继续运行。"},{"type":4,"line":"参见 [include](function.include.html) 文档了解详情。"},{"type":3,"line":"7.16 **include**"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_include_ 语句包含并运行指定文件。"},{"type":4,"line":"以下文档也适用于 [require](function.require.html)。"},{"type":4,"line":"被包含文件先按参数给出的路径寻找，如果没有给出目录（只有文件名）时则按照 [include\\_path](ini.core.html#ini.include-path) 指定的目录寻找。如果在 [include\\_path](ini.core.html#ini.include-path) 下没找到该文件则 _include_ 最后才在调用脚本文件所在的目录和当前工作目录下寻找。如果最后仍未找到文件则 _include_ 结构会发出一条警告；这一点和 [require](function.require.html) 不同，后者会发出一个致命错误。"},{"type":4,"line":"如果定义了路径——不管是绝对路径（在 Windows 下以盘符或者 _\\\\_ 开头，在 Unix/Linux 下以 _/_ 开头）还是当前目录的相对路径（以 _._ 或者 _.._ 开头）——[include\\_path](ini.core.html#ini.include-path) 都会被完全忽略。例如一个文件以 _../_ 开头，则解析器会在当前目录的父目录下寻找该文件。"},{"type":4,"line":"有关 PHP 怎样处理包含文件和包含路径的更多信息参见 [include\\_path](ini.core.html#ini.include-path) 部分的文档。"},{"type":4,"line":"当一个文件被包含时，其中所包含的代码继承了 include 所在行的[变量范围](language.variables.scope.html)。从该处开始，调用文件在该行处可用的任何变量在被调用的文件中也都可用。不过所有在包含文件中定义的函数和类都具有全局作用域。"},{"type":4,"line":"**Example #1 基本的 _include_ 例子**"},{"type":4,"line":"`vars.php  "},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$color = 'green';  "},{"type":4,"line":"$fruit = 'apple';  "},{"type":4,"line":"  "},{"type":4,"line":"?>  "},{"type":4,"line":"  "},{"type":4,"line":"test.php  "},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"A $color$fruit\"; // A  "},{"type":4,"line":"  "},{"type":4,"line":"include 'vars.php';  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"A $color$fruit\"; // A green apple  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"如果 include 出现于调用文件中的一个函数里，则被调用的文件中所包含的所有代码将表现得如同它们是在该函数内部定义的一样。所以它将遵循该函数的变量范围。此规则的一个例外是[魔术常量](language.constants.predefined.html)，它们是在发生包含之前就已被解析器处理的。"},{"type":4,"line":"**Example #2 函数中的包含**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"function foo()  "},{"type":5,"line":"{  "},{"type":4,"line":"    global $color;  "},{"type":5,"line":"  "},{"type":4,"line":"    include 'vars.php';  "},{"type":5,"line":"  "},{"type":4,"line":"    echo \"A $color$fruit\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* vars.php is in the scope of foo() so     *  "},{"type":4,"line":" * $fruit is NOT available outside of this  *  "},{"type":4,"line":" * scope.  $color is because we declared it *  "},{"type":4,"line":" * as global.                               */  "},{"type":4,"line":"  "},{"type":4,"line":"foo();                    // A green apple  "},{"type":4,"line":"echo \"A $color$fruit\";   // A green  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当一个文件被包含时，语法解析器在目标文件的开头脱离 PHP 模式并进入 HTML 模式，到文件结尾处恢复。由于此原因，目标文件中需要作为 PHP 代码执行的任何代码都必须被包括在[有效的 PHP 起始和结束标记](language.basic-syntax.phpmode.html)之中。"},{"type":4,"line":"如果“[URL include wrappers](filesystem.configuration.html#ini.allow-url-include)”在 PHP 中被激活，可以用 URL（通过 HTTP 或者其它支持的封装协议——见[支持的协议和封装协议](wrappers.html)）而不是本地文件来指定要被包含的文件。如果目标服务器将目标文件作为 PHP 代码解释，则可以用适用于 HTTP GET 的 URL 请求字符串来向被包括的文件传递变量。严格的说这和包含一个文件并继承父文件的变量空间并不是一回事；该脚本文件实际上已经在远程服务器上运行了，而本地脚本则包括了其结果。"},{"type":4,"line":"**Example #3 通过 HTTP 进行的 _include_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"/* This example assumes that www.example.com is configured to parse .php *  "},{"type":4,"line":" * files and not .txt files. Also, 'Works' here means that the variables *  "},{"type":4,"line":" * $foo and $bar are available within the included file.                 */  "},{"type":4,"line":"  "},{"type":4,"line":"// Won't work; file.txt wasn't handled by www.example.com as PHP  "},{"type":4,"line":"include 'http://www.example.com/file.txt?foo=1&bar=2';  "},{"type":4,"line":"  "},{"type":4,"line":"// Won't work; looks for a file named 'file.php?foo=1&bar=2' on the  "},{"type":4,"line":"// local filesystem.  "},{"type":4,"line":"include 'file.php?foo=1&bar=2';  "},{"type":4,"line":"  "},{"type":4,"line":"// Works.  "},{"type":4,"line":"include 'http://www.example.com/file.php?foo=1&bar=2';  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = 1;  "},{"type":4,"line":"$bar = 2;  "},{"type":4,"line":"include 'file.txt';  // Works.  "},{"type":4,"line":"include 'file.php';  // Works.  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Warning**"},{"type":2,"line":"安全警告"},{"type":4,"line":"远程文件可能会经远程服务器处理（根据文件后缀以及远程服务器是否在运行 PHP 而定），但必须产生出一个合法的 PHP 脚本，因为其将被本地服务器处理。如果来自远程服务器的文件应该在远端运行而只输出结果，那用 [readfile()](function.readfile.html) 函数更好。另外还要格外小心以确保远程的脚本产生出合法并且是所需的代码。"},{"type":4,"line":"相关信息参见[使用远程文件](features.remote-files.html)，[fopen()](function.fopen.html) 和 [file()](function.file.html)。"},{"type":4,"line":"处理返回值：在失败时 _include_ 返回 _FALSE_ 并且发出警告。成功的包含则返回 _1_，除非在包含文件中另外给出了返回值。可以在被包括的文件中使用 [return](function.return.html) 语句来终止该文件中程序的执行并返回调用它的脚本。同样也可以从被包含的文件中返回值。可以像普通函数一样获得 include 调用的返回值。不过这在包含远程文件时却不行，除非远程文件的输出具有[合法的 PHP 开始和结束标记](language.basic-syntax.phpmode.html)（如同任何本地文件一样）。可以在标记内定义所需的变量，该变量在文件被包含的位置之后就可用了。"},{"type":4,"line":"因为 _include_ 是一个特殊的语言结构，其参数不需要括号。在比较其返回值时要注意。"},{"type":4,"line":"**Example #4 比较 include 的返回值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// won't work, evaluated as include(('vars.php') == TRUE), i.e. include('')  "},{"type":5,"line":"if (include('vars.php') == TRUE) {  "},{"type":4,"line":"    echo 'OK';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// works  "},{"type":5,"line":"if ((include 'vars.php') == TRUE) {  "},{"type":4,"line":"    echo 'OK';  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #5 _include_ 和 [return](function.return.html) 语句**"},{"type":4,"line":"`return.php  "},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$var = 'PHP';  "},{"type":4,"line":"  "},{"type":4,"line":"return $var;  "},{"type":4,"line":"  "},{"type":4,"line":"?>  "},{"type":4,"line":"  "},{"type":4,"line":"noreturn.php  "},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$var = 'PHP';  "},{"type":4,"line":"  "},{"type":4,"line":"?>  "},{"type":4,"line":"  "},{"type":4,"line":"testreturns.php  "},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = include 'return.php';  "},{"type":4,"line":"  "},{"type":4,"line":"echo $foo; // prints 'PHP'  "},{"type":4,"line":"  "},{"type":4,"line":"$bar = include 'noreturn.php';  "},{"type":4,"line":"  "},{"type":4,"line":"echo $bar; // prints 1  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"_$bar_ 的值为 _1_ 是因为 include 成功运行了。注意以上例子中的区别。第一个在被包含的文件中用了 [return](function.return.html) 而另一个没有。如果文件不能被包含，则返回 **`FALSE`** 并发出一个 **`E_WARNING`** 警告。"},{"type":4,"line":"如果在包含文件中定义有函数，这些函数不管是在 [return](function.return.html) 之前还是之后定义的，都可以独立在主文件中使用。如果文件被包含两次，PHP 5 发出致命错误因为函数已经被定义，但是 PHP 4 不会对在 [return](function.return.html) 之后定义的函数报错。推荐使用 [include\\_once](function.include-once.html) 而不是检查文件是否已包含并在包含文件中有条件返回。"},{"type":4,"line":"另一个将 PHP 文件“包含”到一个变量中的方法是用[输出控制函数](ref.outcontrol.html)结合 **include** 来捕获其输出，例如："},{"type":4,"line":"**Example #6 使用输出缓冲来将 PHP 文件包含入一个字符串**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$string = get_include_contents('somefile.php');  "},{"type":4,"line":"  "},{"type":5,"line":"function get_include_contents($filename) {  "},{"type":5,"line":"    if (is_file($filename)) {  "},{"type":5,"line":"        ob_start();  "},{"type":5,"line":"        include $filename;  "},{"type":5,"line":"        $contents = ob_get_contents();  "},{"type":5,"line":"        ob_end_clean();  "},{"type":5,"line":"        return $contents;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    return false;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"要在脚本中自动包含文件，参见 php.ini 中的 [auto\\_prepend\\_file](ini.core.html#ini.auto-prepend-file) 和 [auto\\_append\\_file](ini.core.html#ini.auto-append-file) 配置选项。"},{"type":4,"line":"> **Note**: 因为是一个语言构造器而不是一个函数，不能被 [可变函数](functions.variable-functions.html) 调用。"},{"type":4,"line":"参见 [require](function.require.html)，[require\\_once](function.require-once.html)，[include\\_once](function.include-once.html)，[get\\_included\\_files()](function.get-included-files.html)，[readfile()](function.readfile.html)，[virtual()](function.virtual.html) 和 [include\\_path](ini.core.html#ini.include-path)。"},{"type":3,"line":"7.17 **require\\_once**"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_require\\_once_ 语句和 [require](function.require.html) 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。"},{"type":4,"line":"参见 [include\\_once](function.include-once.html) 的文档来理解 _\\_once_ 的含义，并理解与没有 _\\_once_ 时候有什么不同。"},{"type":3,"line":"7.18 **include\\_once**"},{"type":4,"line":"(PHP 4, PHP 5, PHP 7)"},{"type":4,"line":"_include\\_once_ 语句在脚本执行期间包含并运行指定文件。此行为和 [include](function.include.html) 语句类似，唯一区别是如果该文件中已经被包含过，则不会再次包含。如同此语句名字暗示的那样，只会包含一次。"},{"type":4,"line":"_include\\_once_ 可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。"},{"type":4,"line":"更多信息参见 [include](function.include.html) 文档。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在 PHP 4中，_\\_once_ 的行为在不区分大小写字母的操作系统（例如 Windows）中有所不同，例如："},{"type":4,"line":"> "},{"type":4,"line":"> **Example #1 **include\\_once** 在 PHP 4 运行于不区分大小写的操作系统中**"},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> include_once \"a.php\"; // 这将包含 a.php  "},{"type":4,"line":"> include_once \"A.php\"; // 这将再次包含 a.php！（仅 PHP 4）  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"> "},{"type":4,"line":"> 此行为在 PHP 5 中改了，例如在 Windows 中路径先被规格化，因此 C:\\\\PROGRA~1\\\\A.php 和 C:\\\\Program Files\\\\a.php 的实现一样，文件只会被包含一次。"},{"type":3,"line":"7.19 _goto_"},{"type":4,"line":"(PHP 5 >= 5.3.0, PHP 7)"},{"type":4,"line":"![What's the worse thing that could happen if you use goto?](images/0baa1b9fae6aec55bbb73037f3016001-xkcd-goto.png)"},{"type":4,"line":"此漫画鸣谢 [» xkcd](http://xkcd.com/292)"},{"type":4,"line":"_goto_ 操作符可以用来跳转到程序中的另一位置。该目标位置可以用目标名称加上冒号来标记，而跳转指令是 _goto_ 之后接上目标位置的标记。PHP 中的 _goto_ 有一定限制，目标位置只能位于同一个文件和作用域，也就是说无法跳出一个函数或类方法，也无法跳入到另一个函数。也无法跳入到任何循环或者 switch 结构中。可以跳出循环或者 switch，通常的用法是用 _goto_ 代替多层的 _break_。"},{"type":4,"line":"**Example #1 _goto_ 示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"goto a;  "},{"type":5,"line":"echo 'Foo';  "},{"type":4,"line":"   "},{"type":4,"line":"a:  "},{"type":4,"line":"echo 'Bar';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Bar"},{"type":4,"line":"**Example #2 _goto_ 跳出循环示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"for($i=0,$j=50; $i<100; $i++) {  "},{"type":5,"line":"  while($j--) {  "},{"type":4,"line":"    if($j==17) goto end;   "},{"type":4,"line":"  }    "},{"type":4,"line":"}  "},{"type":4,"line":"echo \"i = $i\";  "},{"type":4,"line":"end:  "},{"type":4,"line":"echo 'j hit 17';  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"j hit 17"},{"type":4,"line":"**Example #3 以下写法无效**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"goto loop;  "},{"type":4,"line":"for($i=0,$j=50; $i<100; $i++) {  "},{"type":5,"line":"  while($j--) {  "},{"type":4,"line":"    loop:  "},{"type":4,"line":"  }  "},{"type":4,"line":"}  "},{"type":4,"line":"echo \"$i = $i\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Fatal error: 'goto' into loop or switch statement is disallowed in"},{"type":4,"line":"script on line 2"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> _goto_ 操作符仅在 PHP 5.3及以上版本有效。"},{"type":1,"line":"8. 函数"},{"type":3,"line":"8.1 用户自定义函数"},{"type":4,"line":"一个函数可由以下的语法来定义："},{"type":4,"line":"**Example #1 展示函数用途的伪代码**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo($arg_1, $arg_2, /* ..., */ $arg_n)  "},{"type":5,"line":"{  "},{"type":5,"line":"    echo \"Example function.\\n\";  "},{"type":4,"line":"    return $retval;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"任何有效的 PHP 代码都有可能出现在函数内部，甚至包括其它函数和[类](language.oop5.basic.html#language.oop5.basic.class)定义。"},{"type":4,"line":"函数名和 PHP 中的其它标识符命名规则相同。有效的函数名以字母或下划线打头，后面跟字母，数字或下划线。可以用正则表达式表示为：_\\[a-zA-Z\\_\\\\x7f-\\\\xff\\]\\[a-zA-Z0-9\\_\\\\x7f-\\\\xff\\]\\*_。"},{"type":4,"line":"**Tip**"},{"type":4,"line":"请参见[用户空间命名指南](userlandnaming.html)。"},{"type":4,"line":"函数无需在调用之前被定义，_除非_是下面两个例子中函数是有条件被定义时。"},{"type":4,"line":"当一个函数是有条件被定义时，必须在调用函数_之前_定义。"},{"type":4,"line":"**Example #2 有条件的函数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$makefoo = true;  "},{"type":4,"line":"  "},{"type":5,"line":"/* 不能在此处调用foo()函数，  "},{"type":4,"line":"   因为它还不存在，但可以调用bar()函数。*/  "},{"type":4,"line":"  "},{"type":4,"line":"bar();  "},{"type":4,"line":"  "},{"type":4,"line":"if ($makefoo) {  "},{"type":4,"line":"  function foo()  "},{"type":5,"line":"  {  "},{"type":4,"line":"    echo \"I don't exist until program execution reaches me.\\n\";  "},{"type":4,"line":"  }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"/* 现在可以安全调用函数 foo()了，  "},{"type":4,"line":"   因为 $makefoo 值为真 */  "},{"type":4,"line":"  "},{"type":4,"line":"if ($makefoo) foo();  "},{"type":4,"line":"  "},{"type":4,"line":"function bar()  "},{"type":4,"line":"{  "},{"type":4,"line":"  echo \"I exist immediately upon program start.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #3 函数中的函数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function foo()  "},{"type":4,"line":"{  "},{"type":4,"line":"  function bar()  "},{"type":5,"line":"  {  "},{"type":4,"line":"    echo \"I don't exist until foo() is called.\\n\";  "},{"type":4,"line":"  }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/* 现在还不能调用bar()函数，因为它还不存在 */  "},{"type":4,"line":"  "},{"type":4,"line":"foo();  "},{"type":4,"line":"  "},{"type":5,"line":"/* 现在可以调用bar()函数了，因为foo()函数  "},{"type":4,"line":"   的执行使得bar()函数变为已定义的函数 */  "},{"type":4,"line":"  "},{"type":4,"line":"bar();  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"PHP 中的所有函数和类都具有全局作用域，可以定义在一个函数之内而在之外调用，反之亦然。"},{"type":4,"line":"PHP 不支持函数重载，也不可能取消定义或者重定义已声明的函数。"},{"type":4,"line":"> **Note**: 函数名是大小写无关的，不过在调用函数的时候，使用其在定义时相同的形式是个好习惯。"},{"type":4,"line":"PHP 的函数支持[可变数量的参数](functions.arguments.html#functions.variable-arg-list)和[默认参数](functions.arguments.html#functions.arguments.default)。参见 [func\\_num\\_args()](function.func-num-args.html)，[func\\_get\\_arg()](function.func-get-arg.html) 和 [func\\_get\\_args()](function.func-get-args.html)。"},{"type":4,"line":"在 PHP 中可以调用递归函数。"},{"type":4,"line":"**Example #4 递归函数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function recursion($a)  "},{"type":5,"line":"{  "},{"type":5,"line":"    if ($a < 20) {  "},{"type":5,"line":"        echo \"$a\\n\";  "},{"type":5,"line":"        recursion($a + 1);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**: 但是要避免递归函数／方法调用超过 100-200 层，因为可能会使堆栈崩溃从而使当前脚本终止。 无限递归可视为编程错误。"},{"type":3,"line":"8.2 函数的参数"},{"type":4,"line":"通过参数列表可以传递信息到函数，即以逗号作为分隔符的表达式列表。参数是从左向右求值的。"},{"type":4,"line":"PHP 支持按值传递参数（默认），[通过引用传递参数](functions.arguments.html#functions.arguments.by-reference)以及[默认参数](functions.arguments.html#functions.arguments.default)。也支持[可变长度参数列表](functions.arguments.html#functions.variable-arg-list)。"},{"type":4,"line":"**Example #1 向函数传递数组**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function takes_array($input)  "},{"type":5,"line":"{  "},{"type":4,"line":"    echo \"$input[0] + $input[1] = \", $input[0]+$input[1];  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 通过引用传递参数"},{"type":4,"line":"默认情况下，函数参数通过值传递（因而即使在函数内部改变参数的值，它并不会改变函数外部的值）。如果希望允许函数修改它的参数值，必须通过引用传递参数。"},{"type":4,"line":"如果想要函数的一个参数总是通过引用传递，可以在函数定义中该参数的前面加上符号 &："},{"type":4,"line":"**Example #2 用引用传递函数参数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function add_some_extra(&$string)  "},{"type":5,"line":"{  "},{"type":4,"line":"    $string .= 'and something extra.';  "},{"type":4,"line":"}  "},{"type":4,"line":"$str = 'This is a string, ';  "},{"type":4,"line":"add_some_extra($str);  "},{"type":4,"line":"echo $str;    // outputs 'This is a string, and something extra.'  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 默认参数的值"},{"type":4,"line":"函数可以定义 C++ 风格的标量参数默认值，如下所示："},{"type":4,"line":"**Example #3 在函数中使用默认参数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function makecoffee($type = \"cappuccino\")  "},{"type":5,"line":"{  "},{"type":4,"line":"    return \"Making a cup of $type.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"echo makecoffee();  "},{"type":4,"line":"echo makecoffee(null);  "},{"type":4,"line":"echo makecoffee(\"espresso\");  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Making a cup of cappuccino."},{"type":4,"line":"Making a cup of ."},{"type":4,"line":"Making a cup of espresso."},{"type":4,"line":"PHP 还允许使用数组 [array](language.types.array.html) 和特殊类型 **`NULL`** 作为默认参数，例如："},{"type":4,"line":"**Example #4 使用非标量类型作为默认参数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function makecoffee($types = array(\"cappuccino\"), $coffeeMaker = NULL)  "},{"type":5,"line":"{  "},{"type":5,"line":"    $device = is_null($coffeeMaker) ? \"hands\" : $coffeeMaker;  "},{"type":4,"line":"    return \"Making a cup of \".join(\", \", $types).\" with $device.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"echo makecoffee();  "},{"type":4,"line":"echo makecoffee(array(\"cappuccino\", \"lavazza\"), \"teapot\");  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"默认值必须是常量表达式，不能是诸如变量，类成员，或者函数调用等。"},{"type":4,"line":"注意当使用默认参数时，任何默认参数必须放在任何非默认参数的右侧；否则，函数将不会按照预期的情况工作。考虑下面的代码片断："},{"type":4,"line":"**Example #5 函数默认参数的不正确用法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function makeyogurt($type = \"acidophilus\", $flavour)  "},{"type":5,"line":"{  "},{"type":4,"line":"    return \"Making a bowl of $type$flavour.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo makeyogurt(\"raspberry\");   // won't work as expected  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Warning: Missing argument 2 in call to makeyogurt() in "},{"type":4,"line":"/usr/local/etc/httpd/htdocs/phptest/functest.html on line 41"},{"type":4,"line":"Making a bowl of raspberry ."},{"type":4,"line":"现在，比较上面的例子和这个例子："},{"type":4,"line":"**Example #6 函数默认参数正确的用法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function makeyogurt($flavour, $type = \"acidophilus\")  "},{"type":5,"line":"{  "},{"type":4,"line":"    return \"Making a bowl of $type$flavour.\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo makeyogurt(\"raspberry\");   // works as expected  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Making a bowl of acidophilus raspberry."},{"type":4,"line":"> **Note**: 自 PHP 5 起，传引用的参数也可以有默认值。"},{"type":4,"line":"### 类型声明"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在PHP 5中，类型声明也被称为类型提示。"},{"type":4,"line":"类型声明允许函数在调用时要求参数为特定类型。 如果给出的值类型不对，那么将会产生一个错误： 在PHP 5中，这将是一个可恢复的致命错误，而在PHP 7中将会抛出一个**TypeError**异常。"},{"type":4,"line":"为了指定一个类型声明，类型应该加到参数名前。这个声明可以通过将参数的默认值设为**`NULL`**来实现允许传递**`NULL`**。"},{"type":4,"line":"#### Valid types"},{"type":4,"line":"Type"},{"type":4,"line":"Description"},{"type":4,"line":"Minimum PHP version"},{"type":4,"line":"Class/interface name"},{"type":4,"line":"The parameter must be an [_instanceof_](language.operators.type.html) the given class or interface name."},{"type":4,"line":"PHP 5.0.0"},{"type":4,"line":"_self_"},{"type":4,"line":"The parameter must be an [_instanceof_](language.operators.type.html) the same class as the one the method is defined on. This can only be used on class and instance methods."},{"type":4,"line":"PHP 5.0.0"},{"type":4,"line":"[array](language.types.array.html)"},{"type":4,"line":"The parameter must be an [array](language.types.array.html)."},{"type":4,"line":"PHP 5.1.0"},{"type":4,"line":"[callable](language.types.callable.html)"},{"type":4,"line":"The parameter must be a valid [callable](language.types.callable.html)."},{"type":4,"line":"PHP 5.4.0"},{"type":4,"line":"[bool](language.types.boolean.html)"},{"type":4,"line":"The parameter must be a [boolean](language.types.boolean.html) value."},{"type":4,"line":"PHP 7.0.0"},{"type":4,"line":"[float](language.types.float.html)"},{"type":4,"line":"The parameter must be a [float](language.types.float.html)ing point number."},{"type":4,"line":"PHP 7.0.0"},{"type":4,"line":"[int](language.types.integer.html)"},{"type":4,"line":"The parameter must be an [integer](language.types.integer.html)."},{"type":4,"line":"PHP 7.0.0"},{"type":4,"line":"[string](language.types.string.html)"},{"type":4,"line":"The parameter must be a [string](language.types.string.html)."},{"type":4,"line":"PHP 7.0.0"},{"type":4,"line":"**Warning**"},{"type":4,"line":"Aliases for the above scalar types are not supported. Instead, they are treated as class or interface names. For example, using _boolean_ as a parameter or return type will require an argument or return value that is an [_instanceof_](language.operators.type.html) the class or interface _boolean_, rather than of type [bool](language.types.boolean.html):"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":" function test(boolean $param) {}  "},{"type":4,"line":" test(true);  "},{"type":4,"line":" ?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":" Fatal error: Uncaught TypeError: Argument 1 passed to test() must be an instance of boolean, boolean given, called in - on line 1 and defined in -:1"},{"type":4,"line":" "},{"type":4,"line":"#### 范例"},{"type":4,"line":"**Example #7 Basic class type declaration**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class C {}  "},{"type":4,"line":"class D extends C {}  "},{"type":4,"line":"  "},{"type":4,"line":"// This doesn't extend C.  "},{"type":4,"line":"class E {}  "},{"type":4,"line":"  "},{"type":5,"line":"function f(C $c) {  "},{"type":4,"line":"    echo get_class($c).\"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"f(new C);  "},{"type":4,"line":"f(new D);  "},{"type":4,"line":"f(new E);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"C"},{"type":4,"line":"D"},{"type":4,"line":"Fatal error: Uncaught TypeError: Argument 1 passed to f() must be an instance of C, instance of E given, called in - on line 14 and defined in -:8"},{"type":4,"line":"Stack trace:"},{"type":4,"line":"#0 -(14): f(Object(E))"},{"type":4,"line":"#1 {main}"},{"type":4,"line":"  thrown in - on line 8"},{"type":4,"line":"**Example #8 Basic interface type declaration**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"interface I { public function f(); }  "},{"type":4,"line":"class C implements I { public function f() {} }  "},{"type":4,"line":"  "},{"type":4,"line":"// This doesn't implement I.  "},{"type":4,"line":"class E {}  "},{"type":4,"line":"  "},{"type":5,"line":"function f(I $i) {  "},{"type":4,"line":"    echo get_class($i).\"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"f(new C);  "},{"type":4,"line":"f(new E);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"C"},{"type":4,"line":"Fatal error: Uncaught TypeError: Argument 1 passed to f() must implement interface I, instance of E given, called in - on line 13 and defined in -:8"},{"type":4,"line":"Stack trace:"},{"type":4,"line":"#0 -(13): f(Object(E))"},{"type":4,"line":"#1 {main}"},{"type":4,"line":"  thrown in - on line 8"},{"type":4,"line":"**Example #9 Nullable type declaration**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class C {}  "},{"type":4,"line":"  "},{"type":5,"line":"function f(C $c = null) {  "},{"type":4,"line":"    var_dump($c);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"f(new C);  "},{"type":4,"line":"f(null);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"object(C)#1 (0) {"},{"type":4,"line":"}"},{"type":4,"line":"NULL"},{"type":4,"line":"#### 严格类型"},{"type":4,"line":"默认情况下，如果能做到的话，PHP将会强迫错误类型的值转为函数期望的标量类型。 例如，一个函数的一个参数期望是[string](language.types.string.html)，但传入的是[integer](language.types.integer.html)，最终函数得到的将会是一个[string](language.types.string.html)类型的值。"},{"type":4,"line":"可以基于每一个文件开启严格模式。在严格模式中，只有一个与类型声明完全相符的变量才会被接受，否则将会抛出一个**TypeError**。 唯一的一个例外是可以将[integer](language.types.integer.html)传给一个期望[float](language.types.float.html)的函数。"},{"type":4,"line":"使用 [_declare_](control-structures.declare.html) 语句和_strict\\_types_ 声明来启用严格模式："},{"type":4,"line":"**Caution**"},{"type":4,"line":"启用严格模式同时也会影响[返回值类型声明](functions.returning-values.html#functions.returning-values.type-declaration)."},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 严格类型适用于在_启用严格模式的文件内_的函数调用，而不是在那个文件内声明的函数。 一个没有启用严格模式的文件内调用了一个在启用严格模式的文件中定义的函数，那么将会遵循调用者的偏好（弱类型），而这个值将会被转换。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 严格类型仅用于标量类型声明，也正是因为如此，这需要PHP 7.0.0 或更新版本，因为标量类型声明也是在那个版本中添加的。"},{"type":4,"line":"**Example #10 Strict typing**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"declare(strict_types=1);  "},{"type":4,"line":"  "},{"type":5,"line":"function sum(int $a, int $b) {  "},{"type":4,"line":"    return $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(sum(1, 2));  "},{"type":4,"line":"var_dump(sum(1.5, 2.5));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"int(3)"},{"type":4,"line":"Fatal error: Uncaught TypeError: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 9 and defined in -:4"},{"type":4,"line":"Stack trace:"},{"type":4,"line":"#0 -(9): sum(1.5, 2.5)"},{"type":4,"line":"#1 {main}"},{"type":4,"line":"  thrown in - on line 4"},{"type":4,"line":"**Example #11 Weak typing**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function sum(int $a, int $b) {  "},{"type":4,"line":"    return $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(sum(1, 2));  "},{"type":4,"line":"  "},{"type":4,"line":"// These will be coerced to integers: note the output below!  "},{"type":4,"line":"var_dump(sum(1.5, 2.5));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"int(3)"},{"type":4,"line":"int(3)"},{"type":4,"line":"**Example #12 Catching **TypeError****"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"declare(strict_types=1);  "},{"type":4,"line":"  "},{"type":5,"line":"function sum(int $a, int $b) {  "},{"type":4,"line":"    return $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"try {  "},{"type":5,"line":"    var_dump(sum(1, 2));  "},{"type":4,"line":"    var_dump(sum(1.5, 2.5));  "},{"type":5,"line":"} catch (TypeError $e) {  "},{"type":4,"line":"    echo 'Error: '.$e->getMessage();  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"int(3)"},{"type":4,"line":"Error: Argument 1 passed to sum() must be of the type integer, float given, called in - on line 10"},{"type":4,"line":"### 可变数量的参数列表"},{"type":4,"line":"PHP 在用户自定义函数中支持可变数量的参数列表。在 PHP 5.6 及以上的版本中，由 _..._ 语法实现；在 PHP 5.5 及更早版本中，使用函数 [func\\_num\\_args()](function.func-num-args.html)，[func\\_get\\_arg()](function.func-get-arg.html)，和 [func\\_get\\_args()](function.func-get-args.html) 。"},{"type":4,"line":"#### _..._ in PHP 5.6+"},{"type":4,"line":"In PHP 5.6 and later, argument lists may include the _..._ token to denote that the function accepts a variable number of arguments. The arguments will be passed into the given variable as an array; for example:"},{"type":4,"line":"**Example #13 Using _..._ to access variable arguments**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function sum(...$numbers) {  "},{"type":5,"line":"    $acc = 0;  "},{"type":5,"line":"    foreach ($numbers as $n) {  "},{"type":5,"line":"        $acc += $n;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    return $acc;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo sum(1, 2, 3, 4);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"10"},{"type":4,"line":"You can also use _..._ when calling functions to unpack an [array](language.types.array.html) or **Traversable** variable or literal into the argument list:"},{"type":4,"line":"**Example #14 Using _..._ to provide arguments**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function add($a, $b) {  "},{"type":4,"line":"    return $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo add(...[1, 2]).\"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$a = [1, 2];  "},{"type":4,"line":"echo add(...$a);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"3"},{"type":4,"line":"3"},{"type":4,"line":"You may specify normal positional arguments before the _..._ token. In this case, only the trailing arguments that don't match a positional argument will be added to the array generated by _..._."},{"type":4,"line":"It is also possible to add a [type hint](language.oop5.typehinting.html) before the _..._ token. If this is present, then all arguments captured by _..._ must be objects of the hinted class."},{"type":4,"line":"**Example #15 Type hinted variable arguments**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function total_intervals($unit, DateInterval ...$intervals) {  "},{"type":5,"line":"    $time = 0;  "},{"type":5,"line":"    foreach ($intervals as $interval) {  "},{"type":5,"line":"        $time += $interval->$unit;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    return $time;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new DateInterval('P1D');  "},{"type":4,"line":"$b = new DateInterval('P2D');  "},{"type":4,"line":"echo total_intervals('d', $a, $b).' days';  "},{"type":4,"line":"  "},{"type":4,"line":"// This will fail, since null isn't a DateInterval object.  "},{"type":4,"line":"echo total_intervals('d', null);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"3 days"},{"type":4,"line":"Catchable fatal error: Argument 2 passed to total\\_intervals() must be an instance of DateInterval, null given, called in - on line 14 and defined in - on line 2"},{"type":4,"line":"Finally, you may also pass variable arguments [by reference](functions.arguments.html#functions.arguments.by-reference) by prefixing the _..._ with an ampersand (_&_)."},{"type":4,"line":"#### Older versions of PHP"},{"type":4,"line":"No special syntax is required to note that a function is variadic; however access to the function's arguments must use [func\\_num\\_args()](function.func-num-args.html), [func\\_get\\_arg()](function.func-get-arg.html) and [func\\_get\\_args()](function.func-get-args.html)."},{"type":4,"line":"The first example above would be implemented as follows in PHP 5.5 and earlier:"},{"type":4,"line":"**Example #16 Accessing variable arguments in PHP 5.5 and earlier**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function sum() {  "},{"type":5,"line":"    $acc = 0;  "},{"type":5,"line":"    foreach (func_get_args() as $n) {  "},{"type":5,"line":"        $acc += $n;  "},{"type":5,"line":"    }  "},{"type":4,"line":"    return $acc;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo sum(1, 2, 3, 4);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"10"},{"type":3,"line":"8.3 返回值"},{"type":4,"line":"值通过使用可选的返回语句返回。可以返回包括数组和对象的任意类型。返回语句会立即中止函数的运行，并且将控制权交回调用该函数的代码行。更多信息见 [return](function.return.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果省略了 [return](function.return.html)，则返回值为 **`NULL`**。"},{"type":4,"line":"### return 的使用"},{"type":4,"line":"**Example #1 [return](function.return.html) 的使用**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function square($num)  "},{"type":5,"line":"{  "},{"type":4,"line":"    return $num * $num;  "},{"type":4,"line":"}  "},{"type":4,"line":"echo square(4);   // outputs '16'.  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"函数不能返回多个值，但可以通过返回一个数组来得到类似的效果。"},{"type":4,"line":"**Example #2 返回一个数组以得到多个返回值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function small_numbers()  "},{"type":5,"line":"{  "},{"type":4,"line":"    return array (0, 1, 2);  "},{"type":4,"line":"}  "},{"type":4,"line":"list ($zero, $one, $two) = small_numbers();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"从函数返回一个引用，必须在函数声明和指派返回值给一个变量时都使用引用运算符 &："},{"type":4,"line":"**Example #3 从函数返回一个引用**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function &returns_reference()  "},{"type":5,"line":"{  "},{"type":4,"line":"    return $someref;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$newref =& returns_reference();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"有关引用的更多信息, 请查看[引用的解释](language.references.html)。"},{"type":4,"line":"### 返回值类型声明"},{"type":4,"line":"PHP 7 增加了对返回值类型声明的支持。 就如 [类型声明](functions.arguments.html#functions.arguments.type-declaration)一样, 返回值类型声明将指定该函数返回值的类型。同样，返回值类型声明也与 [有效类型](functions.arguments.html#functions.arguments.type-declaration.types) 中可用的参数类型声明一致。"},{"type":4,"line":"[严格类型](functions.arguments.html#functions.arguments.type-declaration.strict) 也会影响返回值类型声明。在默认的弱模式中，如果返回值与返回值的类型不一致，则会被强制转换为返回值声明的类型。在强模式中，返回值的类型必须正确，否则将会抛出一个**TypeError**异常."},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 当覆盖一个父类方法时，子类方法的返回值类型声明必须与父类一致。如果父类方法没有定义返回类型，那么子类方法可以定义任意的返回值类型声明。"},{"type":4,"line":"#### 范例"},{"type":4,"line":"**Example #4 基础返回值类型声明**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function sum($a, $b): float {  "},{"type":4,"line":"    return $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// Note that a float will be returned.  "},{"type":4,"line":"var_dump(sum(1, 2));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"float(3)"},{"type":4,"line":"**Example #5 严格模式下执行**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"declare(strict_types=1);  "},{"type":4,"line":"  "},{"type":5,"line":"function sum($a, $b): int {  "},{"type":4,"line":"    return $a + $b;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(sum(1, 2));  "},{"type":4,"line":"var_dump(sum(1, 2.5));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"int(3)"},{"type":4,"line":"Fatal error: Uncaught TypeError: Return value of sum() must be of the type integer, float returned in - on line 5 in -:5"},{"type":4,"line":"Stack trace:"},{"type":4,"line":"#0 -(9): sum(1, 2.5)"},{"type":4,"line":"#1 {main}"},{"type":4,"line":"  thrown in - on line 5"},{"type":4,"line":"**Example #6 返回一个对象**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class C {}  "},{"type":4,"line":"  "},{"type":5,"line":"function getC(): C {  "},{"type":4,"line":"    return new C;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(getC());  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"object(C)#1 (0) {"},{"type":4,"line":"}"},{"type":3,"line":"8.4 可变函数"},{"type":4,"line":"PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。"},{"type":4,"line":"可变函数不能用于例如 [echo](function.echo.html)，[print](function.print.html)，[unset()](function.unset.html)，[isset()](function.isset.html)，[empty()](function.empty.html)，[include](function.include.html)，[require](function.require.html) 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。"},{"type":4,"line":"**Example #1 可变函数示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"function foo() {  "},{"type":4,"line":"    echo \"In foo()<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"function bar($arg = '') {  "},{"type":4,"line":"    echo \"In bar(); argument was '$arg'.<br />\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 使用 echo 的包装函数  "},{"type":4,"line":"function echoit($string)  "},{"type":5,"line":"{  "},{"type":4,"line":"    echo $string;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$func = 'foo';  "},{"type":4,"line":"$func();        // This calls foo()  "},{"type":4,"line":"  "},{"type":4,"line":"$func = 'bar';  "},{"type":4,"line":"$func('test');  // This calls bar()  "},{"type":4,"line":"  "},{"type":4,"line":"$func = 'echoit';  "},{"type":4,"line":"$func('test');  // This calls echoit()  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"也可以用可变函数的语法来调用一个对象的方法。"},{"type":4,"line":"**Example #2 可变方法范例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    function Variable()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $name = 'Bar';  "},{"type":5,"line":"        $this->$name(); // This calls the Bar() method  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    function Bar()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"This is Bar\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new Foo();  "},{"type":4,"line":"$funcname = \"Variable\";  "},{"type":4,"line":"$foo->$funcname();   // This calls $foo->Variable()  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当调用静态方法时，函数调用要比静态属性优先："},{"type":4,"line":"**Example #3 Variable 方法和静态属性示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    static $variable = 'static property';  "},{"type":5,"line":"    static function Variable()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo 'Method Variable called';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo Foo::$variable; // This prints 'static property'. It does need a $variable in this scope.  "},{"type":4,"line":"$variable = \"Variable\";  "},{"type":4,"line":"Foo::$variable();  // This calls $foo->Variable() reading $variable in this scope.  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"As of PHP 5.4.0, you can call any [callable](language.types.callable.html) stored in a variable."},{"type":4,"line":"**Example #4 Complex callables**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    static function bar()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"bar\\n\";  "},{"type":5,"line":"    }  "},{"type":5,"line":"    function baz()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"baz\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$func = array(\"Foo\", \"bar\");  "},{"type":4,"line":"$func(); // prints \"bar\"  "},{"type":4,"line":"$func = array(new Foo, \"baz\");  "},{"type":4,"line":"$func(); // prints \"baz\"  "},{"type":4,"line":"$func = \"Foo::bar\";  "},{"type":4,"line":"$func(); // prints \"bar\" as of PHP 7.0.0; prior, it raised a fatal error  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见 [is\\_callable()](function.is-callable.html)，[call\\_user\\_func()](function.call-user-func.html)，[可变变量](language.variables.variable.html)和 [function\\_exists()](function.function-exists.html)。"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"7.0.0"},{"type":4,"line":"'ClassName::methodName' is allowed as variable function."},{"type":4,"line":"5.4.0"},{"type":4,"line":"Arrays, which are valid callables, are allowed as variable functions."},{"type":3,"line":"8.5 内部（内置）函数"},{"type":4,"line":"PHP 有很多标准的函数和结构。还有一些函数需要和特定地 PHP 扩展模块一起编译，否则在使用它们的时候就会得到一个致命的“未定义函数”错误。例如，要使用 [image](ref.image.html) 函数中的 [imagecreatetruecolor()](function.imagecreatetruecolor.html)，需要在编译 PHP 的时候加上 GD 的支持。或者，要使用 [mysql\\_connect()](function.mysql-connect.html) 函数，就需要在编译 PHP 的时候加上 [MySQL](ref.mysql.html) 支持。有很多核心函数已包含在每个版本的 PHP 中如[字符串](ref.strings.html)和[变量](ref.var.html)函数。调用 [phpinfo()](function.phpinfo.html) 或者 [get\\_loaded\\_extensions()](function.get-loaded-extensions.html) 可以得知 PHP 加载了那些扩展库。同时还应该注意，很多扩展库默认就是有效的。PHP 手册按照不同的扩展库组织了它们的文档。请参阅[配置](configuration.html)，[安装](install.html)以及各自的扩展库章节以获取有关如何设置 PHP 的信息。"},{"type":4,"line":"手册中[如何阅读函数原型](about.prototypes.html)讲解了如何阅读和理解一个函数的原型。确认一个函数将返回什么，或者函数是否直接作用于传递的参数是很重要的。例如，[str\\_replace()](function.str-replace.html) 函数将返回修改过的字符串，而 [usort()](function.usort.html) 却直接作用于传递的参数变量本身。手册中，每一个函数的页面中都有关于函数参数、行为改变、成功与否的返回值以及使用条件等信息。了解这些重要的（常常是细微的）差别是编写正确的 PHP 代码的关键。"},{"type":4,"line":"> **Note**: 如果传递给函数的参数类型与实际的类型不一致，例如将一个 [array](language.types.array.html) 传递给一个 [string](language.types.string.html) 类型的变量，那么函数的返回值是不确定的。在这种情况下，通常函数会返回 **`NULL`**。但这仅仅是一个惯例，并不一定如此。"},{"type":4,"line":"参见 [function\\_exists()](function.function-exists.html)，[函数参考](funcref.html)，[get\\_extension\\_funcs()](function.get-extension-funcs.html) 和 [dl()](function.dl.html)。"},{"type":3,"line":"8.6 匿名函数"},{"type":4,"line":"匿名函数（Anonymous functions），也叫闭包函数（_closures_），允许 临时创建一个没有指定名称的函数。最经常用作回调函数（[callback](language.pseudo-types.html#language.types.callback)）参数的值。当然，也有其它应用的情况。"},{"type":4,"line":"匿名函数目前是通过 [](class.closure.html)[Closure](class.closure.html) 类来实现的。"},{"type":4,"line":"**Example #1 匿名函数示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"echo preg_replace_callback('~-([a-z])~', function ($match) {  "},{"type":4,"line":"    return strtoupper($match[1]);  "},{"type":4,"line":"}, 'hello-world');  "},{"type":4,"line":"// 输出 helloWorld  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"闭包函数也可以作为变量的值来使用。PHP 会自动把此种表达式转换成内置类 [Closure](class.closure.html) 的对象实例。把一个 closure 对象赋值给一个变量的方式与普通变量赋值的语法是一样的，最后也要加上分号："},{"type":4,"line":"**Example #2 匿名函数变量赋值示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$greet = function($name)  "},{"type":5,"line":"{  "},{"type":4,"line":"    printf(\"Hello %s\\r\\n\", $name);  "},{"type":4,"line":"};  "},{"type":4,"line":"  "},{"type":4,"line":"$greet('World');  "},{"type":4,"line":"$greet('PHP');  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"闭包可以从父作用域中继承变量。 任何此类变量都应该用 _use_ 语言结构传递进去。 PHP 7.1 起，不能传入此类变量： [superglobals](language.variables.predefined.html)、 $this 或者和参数重名。"},{"type":4,"line":"**Example #3 从父作用域继承变量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$message = 'hello';  "},{"type":4,"line":"  "},{"type":4,"line":"// 没有 \"use\"  "},{"type":5,"line":"$example = function () {  "},{"type":4,"line":"    var_dump($message);  "},{"type":4,"line":"};  "},{"type":4,"line":"echo $example();  "},{"type":4,"line":"  "},{"type":4,"line":"// 继承 $message  "},{"type":5,"line":"$example = function () use ($message) {  "},{"type":4,"line":"    var_dump($message);  "},{"type":4,"line":"};  "},{"type":4,"line":"echo $example();  "},{"type":4,"line":"  "},{"type":4,"line":"// Inherited variable's value is from when the function  "},{"type":4,"line":"// is defined, not when called  "},{"type":4,"line":"$message = 'world';  "},{"type":4,"line":"echo $example();  "},{"type":4,"line":"  "},{"type":4,"line":"// Reset message  "},{"type":4,"line":"$message = 'hello';  "},{"type":4,"line":"  "},{"type":4,"line":"// Inherit by-reference  "},{"type":5,"line":"$example = function () use (&$message) {  "},{"type":4,"line":"    var_dump($message);  "},{"type":4,"line":"};  "},{"type":4,"line":"echo $example();  "},{"type":4,"line":"  "},{"type":4,"line":"// The changed value in the parent scope  "},{"type":4,"line":"// is reflected inside the function call  "},{"type":4,"line":"$message = 'world';  "},{"type":4,"line":"echo $example();  "},{"type":4,"line":"  "},{"type":4,"line":"// Closures can also accept regular arguments  "},{"type":5,"line":"$example = function ($arg) use ($message) {  "},{"type":4,"line":"    var_dump($arg . ' ' . $message);  "},{"type":4,"line":"};  "},{"type":4,"line":"$example(\"hello\");  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"Notice: Undefined variable: message in /example.php on line 6"},{"type":4,"line":"NULL"},{"type":4,"line":"string(5) \"hello\""},{"type":4,"line":"string(5) \"hello\""},{"type":4,"line":"string(5) \"hello\""},{"type":4,"line":"string(5) \"world\""},{"type":4,"line":"string(11) \"hello world\""},{"type":4,"line":"这些变量都必须在函数或类的头部声明。 从父作用域中继承变量与使用全局变量是_不同_的。全局变量存在于一个全局的范围，无论当前在执行的是哪个函数。而 闭包的父作用域是定义该闭包的函数（不一定是调用它的函数）。示例如下："},{"type":4,"line":"**Example #4 Closures 和作用域**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。  "},{"type":4,"line":"// 其中有一个方法用来计算购物车中所有商品的总价格，该方法使  "},{"type":4,"line":"// 用了一个 closure 作为回调函数。  "},{"type":4,"line":"class Cart  "},{"type":5,"line":"{  "},{"type":5,"line":"    const PRICE_BUTTER  = 1.00;  "},{"type":5,"line":"    const PRICE_MILK    = 3.00;  "},{"type":4,"line":"    const PRICE_EGGS    = 6.95;  "},{"type":5,"line":"  "},{"type":5,"line":"    protected   $products = array();  "},{"type":5,"line":"      "},{"type":5,"line":"    public function add($product, $quantity)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->products[$product] = $quantity;  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    public function getQuantity($product)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        return isset($this->products[$product]) ? $this->products[$product] :  "},{"type":5,"line":"               FALSE;  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    public function getTotal($tax)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $total = 0.00;  "},{"type":5,"line":"          "},{"type":5,"line":"        $callback =  "},{"type":5,"line":"            function ($quantity, $product) use ($tax, &$total)  "},{"type":5,"line":"            {  "},{"type":5,"line":"                $pricePerItem = constant(__CLASS__ . \"::PRICE_\" .  "},{"type":5,"line":"                    strtoupper($product));  "},{"type":5,"line":"                $total += ($pricePerItem * $quantity) * ($tax + 1.0);  "},{"type":5,"line":"            };  "},{"type":5,"line":"          "},{"type":5,"line":"        array_walk($this->products, $callback);  "},{"type":5,"line":"        return round($total, 2);;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$my_cart = new Cart;  "},{"type":4,"line":"  "},{"type":4,"line":"// 往购物车里添加条目  "},{"type":4,"line":"$my_cart->add('butter', 1);  "},{"type":4,"line":"$my_cart->add('milk', 3);  "},{"type":4,"line":"$my_cart->add('eggs', 6);  "},{"type":4,"line":"  "},{"type":4,"line":"// 打出出总价格，其中有 5% 的销售税.  "},{"type":4,"line":"print $my_cart->getTotal(0.05) . \"\\n\";  "},{"type":4,"line":"// 最后结果是 54.29  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #5 Automatic binding of _$this_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"class Test  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function testing()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        return function() {  "},{"type":5,"line":"            var_dump($this);  "},{"type":5,"line":"        };  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$object = new Test;  "},{"type":4,"line":"$function = $object->testing();  "},{"type":5,"line":"$function();  "},{"type":4,"line":"      "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"object(Test)#1 (0) {"},{"type":4,"line":"}"},{"type":4,"line":"以上例程在PHP 5.3中的输出："},{"type":4,"line":"Notice: Undefined variable: this in script.php on line 8"},{"type":4,"line":"NULL"},{"type":4,"line":"As of PHP 5.4.0, when declared in the context of a class, the current class is automatically bound to it, making _$this_ available inside of the function's scope. If this automatic binding of the current class is not wanted, then [static anonymous functions](functions.anonymous.html#functions.anonymous-functions.static) may be used instead."},{"type":4,"line":"### Static anonymous functions"},{"type":4,"line":"As of PHP 5.4, anonymous functions may be declared statically. This prevents them from having the current class automatically bound to them. Objects may also not be bound to them at runtime."},{"type":4,"line":"**Example #6 Attempting to use _$this_ inside a static anonymous function**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    function __construct()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $func = static function() {  "},{"type":5,"line":"            var_dump($this);  "},{"type":5,"line":"        };  "},{"type":5,"line":"        $func();  "},{"type":4,"line":"    }  "},{"type":4,"line":"};  "},{"type":4,"line":"new Foo();  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Notice: Undefined variable: this in %s on line %d"},{"type":4,"line":"NULL"},{"type":4,"line":"**Example #7 Attempting to bind an object to a static anonymous function**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":5,"line":"$func = static function() {  "},{"type":4,"line":"    // function body  "},{"type":4,"line":"};  "},{"type":4,"line":"$func = $func->bindTo(new StdClass);  "},{"type":4,"line":"$func();  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Warning: Cannot bind an instance to a static closure in %s on line %d"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"7.1.0"},{"type":4,"line":"Anonymous functions may not close over [superglobals](language.variables.predefined.html), $this, or any variable with the same name as a parameter."},{"type":4,"line":"5.4.0"},{"type":4,"line":"$this 可用于匿名函数。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"可以使用匿名函数。"},{"type":4,"line":"### 注释"},{"type":4,"line":"> **Note**: 可以在闭包中使用 [func\\_num\\_args()](function.func-num-args.html)，[func\\_get\\_arg()](function.func-get-arg.html) 和 [func\\_get\\_args()](function.func-get-args.html)。"},{"type":1,"line":"9. 类与对象"},{"type":4,"line":"9.1 简介"},{"type":4,"line":"--"},{"type":4,"line":"自 PHP 5 起完全重写了对象模型以得到更佳性能和更多特性。这是自 PHP 4 以来的最大变化。PHP 5 具有完整的对象模型。"},{"type":4,"line":"PHP 5 中的新特性包括[访问控制](language.oop5.visibility.html)，[抽象类](language.oop5.abstract.html)和 [final](language.oop5.final.html) 类与方法，附加的[魔术方法](language.oop5.magic.html)，[接口](language.oop5.interfaces.html)，[对象复制](language.oop5.cloning.html)和[类型约束](language.oop5.typehinting.html)。"},{"type":4,"line":"PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的引用，而不是整个对象的拷贝。参见[对象和引用](language.oop5.references.html)。"},{"type":4,"line":"**Tip**"},{"type":4,"line":"请参见[用户空间命名指南](userlandnaming.html)。"},{"type":3,"line":"9.2 基本概念"},{"type":4,"line":"### class"},{"type":4,"line":"每个类的定义都以关键字 _class_ 开头，后面跟着类名，后面跟着一对花括号，里面包含有类的属性与方法的定义。"},{"type":4,"line":"类名可以是任何非 PHP [保留字](reserved.html)的合法标签。一个合法类名以字母或下划线开头，后面跟着若干字母，数字或下划线。以正则表达式表示为：_\\[a-zA-Z\\_\\\\x7f-\\\\xff\\]\\[a-zA-Z0-9\\_\\\\x7f-\\\\xff\\]\\*_。"},{"type":4,"line":"一个类可以包含有属于自己的[常量](language.oop5.constants.html)，[变量](language.oop5.properties.html)（称为“属性”）以及函数（称为“方法”）。"},{"type":4,"line":"**Example #1 简单的类定义**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class SimpleClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 声明属性  "},{"type":4,"line":"    public $var = 'a default value';  "},{"type":5,"line":"  "},{"type":5,"line":"    // 声明方法  "},{"type":5,"line":"    public function displayVar() {  "},{"type":5,"line":"        echo $this->var;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象[静态](language.oop5.static.html)调用时也可能是另一个对象）。"},{"type":4,"line":"**Example #2 $this 伪变量的示例**"},{"type":4,"line":"We're assuming that error\\_reporting is disabled for this example; otherwise the following code would trigger deprecated and strict notices, respectively, depending on the PHP version."},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class A  "},{"type":5,"line":"{  "},{"type":5,"line":"    function foo()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        if (isset($this)) {  "},{"type":5,"line":"            echo '$this is defined (';  "},{"type":5,"line":"            echo get_class($this);  "},{"type":5,"line":"            echo \")\\n\";  "},{"type":5,"line":"        } else {  "},{"type":5,"line":"            echo \"\\$this is not defined.\\n\";  "},{"type":5,"line":"        }  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class B  "},{"type":5,"line":"{  "},{"type":5,"line":"    function bar()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        A::foo();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new A();  "},{"type":4,"line":"$a->foo();  "},{"type":4,"line":"  "},{"type":4,"line":"A::foo();  "},{"type":4,"line":"  "},{"type":4,"line":"$b = new B();  "},{"type":4,"line":"$b->bar();  "},{"type":4,"line":"  "},{"type":4,"line":"B::bar();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"Output of the above example in PHP 5:"},{"type":4,"line":"$this is defined (A)"},{"type":4,"line":"$this is not defined."},{"type":4,"line":"$this is defined (B)"},{"type":4,"line":"$this is not defined."},{"type":4,"line":"Output of the above example in PHP 7:"},{"type":4,"line":"$this is defined (A)"},{"type":4,"line":"$this is not defined."},{"type":4,"line":"$this is not defined."},{"type":4,"line":"$this is not defined."},{"type":4,"line":"### new"},{"type":4,"line":"要创建一个类的实例，必须使用 _new_ 关键字。当创建新对象时该对象总是被赋值，除非该对象定义了[构造函数](language.oop5.decon.html)并且在出错时抛出了一个[异常](language.exceptions.html)。类应在被实例化之前定义（某些情况下则必须这样）。"},{"type":4,"line":"如果在 _new_ 之后跟着的是一个包含有类名的字符串 [string](language.types.string.html)，则该类的一个实例被创建。如果该类属于一个命名空间，则必须使用其完整名称。"},{"type":4,"line":"**Example #3 创建实例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"$instance = new SimpleClass();  "},{"type":4,"line":"  "},{"type":4,"line":"// 也可以这样做：  "},{"type":4,"line":"$className = 'Foo';  "},{"type":4,"line":"$instance = new $className(); // Foo()  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"在类定义内部，可以用 _new self_ 和 _new parent_ 创建新对象。"},{"type":4,"line":"当把一个对象已经创建的实例赋给一个新变量时，新变量会访问同一个实例，就和用该对象赋值一样。此行为和给函数传递入实例时一样。可以用[克隆](language.oop5.cloning.html)给一个已创建的对象建立一个新实例。"},{"type":4,"line":"**Example #4 对象赋值**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"$instance = new SimpleClass();  "},{"type":4,"line":"  "},{"type":4,"line":"$assigned   =  $instance;  "},{"type":4,"line":"$reference  =& $instance;  "},{"type":4,"line":"  "},{"type":4,"line":"$instance->var = '$assigned will have this value';  "},{"type":4,"line":"  "},{"type":4,"line":"$instance = null; // $instance and $reference become null  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump($instance);  "},{"type":4,"line":"var_dump($reference);  "},{"type":4,"line":"var_dump($assigned);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"NULL"},{"type":4,"line":"NULL"},{"type":5,"line":"object(SimpleClass)#1 (1) {"},{"type":5,"line":"   \\[\"var\"\\]=>"},{"type":4,"line":"     string(30) \"$assigned will have this value\""},{"type":4,"line":"}"},{"type":4,"line":"PHP 5.3.0 引进了两个新方法来创建一个对象的实例："},{"type":4,"line":"**Example #5 创建新对象**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Test  "},{"type":5,"line":"{  "},{"type":5,"line":"    static public function getNew()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        return new static;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class Child extends Test  "},{"type":4,"line":"{}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj1 = new Test();  "},{"type":4,"line":"$obj2 = new $obj1;  "},{"type":4,"line":"var_dump($obj1 !== $obj2);  "},{"type":4,"line":"  "},{"type":4,"line":"$obj3 = Test::getNew();  "},{"type":4,"line":"var_dump($obj3 instanceof Test);  "},{"type":4,"line":"  "},{"type":4,"line":"$obj4 = Child::getNew();  "},{"type":4,"line":"var_dump($obj4 instanceof Child);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(true)"},{"type":4,"line":"bool(true)"},{"type":4,"line":"PHP 5.4.0 起，可以通过一个表达式来访问新创建对象的成员："},{"type":4,"line":"**Example #6 访问新创建对象的成员**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"echo (new DateTime())->format('Y');  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程的输出类似于："},{"type":4,"line":"2016"},{"type":4,"line":"### Properties and methods"},{"type":4,"line":"Class properties and methods live in separate \"namespaces\", so it is possible to have a property and a method with the same name. Referring to both a property and a method has the same notation, and whether a property will be accessed or a method will be called, solely depends on the context, i.e. whether the usage is a variable access or a function call."},{"type":4,"line":"**Example #7 Property access vs. method call**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $bar = 'property';  "},{"type":5,"line":"      "},{"type":5,"line":"    public function bar() {  "},{"type":5,"line":"        return 'method';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new Foo();  "},{"type":4,"line":"echo $obj->bar, PHP_EOL, $obj->bar(), PHP_EOL;`"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"property"},{"type":4,"line":"method"},{"type":4,"line":"That means that calling an [anonymous function](functions.anonymous.html) which has been assigned to a property is not directly possible. Instead the property has to be assigned to a variable first, for instance. As of PHP 7.0.0 it is possible to call such a property directly by enclosing it in parentheses."},{"type":4,"line":"**Example #8 Calling an anonymous function stored in a property**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $bar;  "},{"type":5,"line":"      "},{"type":5,"line":"    public function __construct() {  "},{"type":5,"line":"        $this->bar = function() {  "},{"type":5,"line":"            return 42;  "},{"type":5,"line":"        };  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new Foo();  "},{"type":4,"line":"  "},{"type":4,"line":"// as of PHP 5.3.0:  "},{"type":4,"line":"$func = $obj->bar;  "},{"type":4,"line":"echo $func(), PHP_EOL;  "},{"type":4,"line":"  "},{"type":4,"line":"// alternatively, as of PHP 7.0.0:  "},{"type":4,"line":"echo ($obj->bar)(), PHP_EOL;`"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"42"},{"type":4,"line":"### extends"},{"type":4,"line":"一个类可以在声明中用 _extends_ 关键字继承另一个类的方法和属性。PHP不支持多重继承，一个类只能继承一个基类。"},{"type":4,"line":"被继承的方法和属性可以通过用同样的名字重新声明被覆盖。但是如果父类定义方法时使用了 [final](language.oop5.final.html)，则该方法不可被覆盖。可以通过 [parent::](language.oop5.paamayim-nekudotayim.html) 来访问被覆盖的方法或属性。"},{"type":4,"line":"当覆盖方法时，参数必须保持一致否则 PHP 将发出 **`E_STRICT`** 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。"},{"type":4,"line":"**Example #9 简单的类继承**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class ExtendClass extends SimpleClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // Redefine the parent method  "},{"type":5,"line":"    function displayVar()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"Extending class\\n\";  "},{"type":5,"line":"        parent::displayVar();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$extended = new ExtendClass();  "},{"type":4,"line":"$extended->displayVar();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Extending class"},{"type":4,"line":"a default value"},{"type":4,"line":"### ::class"},{"type":4,"line":"自 PHP 5.5 起，关键词 _class_ 也可用于类名的解析。使用 _ClassName::class_ 你可以获取一个字符串，包含了类 _ClassName_ 的完全限定名称。这对使用了 [命名空间](language.namespaces.html) 的类尤其有用。"},{"type":4,"line":"**Example #10 类名的解析**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"namespace NS {  "},{"type":5,"line":"    class ClassName {  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":4,"line":"    echo ClassName::class;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"NS\\\\ClassName"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> The class name resolution using _::class_ is a compile time transformation. That means at the time the class name string is created no autoloading has happened yet. As a consequence, class names are expanded even if the class does not exist. No error is issued in that case."},{"type":4,"line":"9.3 属性"},{"type":4,"line":"--"},{"type":4,"line":"类的变量成员叫做“属性”，或者叫“字段”、“特征”，在本文档统一称为“属性”。属性声明是由关键字 _public_，_protected_ 或者 _private_ 开头，然后跟一个普通的变量声明来组成。属性中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。"},{"type":4,"line":"有关 _public_，_protected_ 和 _private_ 的更多详细信息，请查看[访问控制（可见性）](language.oop5.visibility.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 为了向后兼容 PHP 4，PHP 5 声明属性依然可以直接使用关键字 _var_ 来替代（或者附加于）_public_，_protected_ 或 _private_。但是已不再需要 _var_ 了。在 PHP 5.0 到 5.1.3，_var_ 会被认为是废弃的，而且抛出 **`E_STRICT`** 警告，但是 5.1.3 之后就不再认为是废弃，也不会抛出警告。"},{"type":4,"line":"> "},{"type":4,"line":"> 如果直接使用 _var_ 声明属性，而没有用 _public_，_protected_ 或 _private_ 之一，PHP 5 会将其视为 _public_。"},{"type":4,"line":"在类的成员方法里面，可以用 _\\->_（对象运算符）：$this->property（其中 _property_ 是该属性名）这种方式来访问非静态属性。静态属性则是用 _::_（双冒号）：self::$property 来访问。更多静态属性与非静态属性的区别参见 [Static 关键字](language.oop5.static.html)。"},{"type":4,"line":"当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this 是一个到主叫对象的引用（通常是该方法所从属的对象，但如果是从第二个对象[静态](language.oop5.static.html)调用时也可能是另一个对象）。"},{"type":4,"line":"**Example #1 属性声明**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class SimpleClass  "},{"type":5,"line":"{  "},{"type":5,"line":"   // 错误的属性声明  "},{"type":5,"line":"   public $var1 = 'hello ' . 'world';  "},{"type":4,"line":"   public $var2 = <<<EOD  "},{"type":4,"line":"hello world  "},{"type":5,"line":"EOD;  "},{"type":5,"line":"   public $var3 = 1+2;  "},{"type":5,"line":"   public $var4 = self::myStaticMethod();  "},{"type":4,"line":"   public $var5 = $myVar;  "},{"type":5,"line":"  "},{"type":5,"line":"   // 正确的属性声明  "},{"type":5,"line":"   public $var6 = myConstant;  "},{"type":4,"line":"   public $var7 = array(true, false);  "},{"type":5,"line":"  "},{"type":5,"line":"   //在 PHP 5.3.0 及之后，下面的声明也正确  "},{"type":4,"line":"   public $var8 = <<<'EOD'  "},{"type":4,"line":"hello world  "},{"type":4,"line":"EOD;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 更多关于类／对象的处理函数，请查看[类／对象函数](ref.classobj.html)。"},{"type":4,"line":"跟 [heredocs](language.types.string.html#language.types.string.syntax.heredoc) 不同，[nowdocs](language.types.string.html#language.types.string.syntax.nowdoc) 可在任何静态数据上下文中使用，包括属性声明。"},{"type":4,"line":"**Example #2 示例：使用 nowdoc 初始化属性**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class foo {  "},{"type":5,"line":"   // 自 5.3.0 起  "},{"type":4,"line":"   public $bar = <<<'EOT'  "},{"type":4,"line":"bar  "},{"type":4,"line":"EOT;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> Nowdoc 支持是在 PHP 5.3.0 新增的。"},{"type":3,"line":"9.4 类常量"},{"type":4,"line":"可以把在类中始终保持不变的值定义为常量。在定义和使用常量的时候不需要使用 $ 符号。"},{"type":4,"line":"常量的值必须是一个定值，不能是变量，类属性，数学运算的结果或函数调用。"},{"type":4,"line":"接口（interface）中也可以定义常量。更多示例见文档中的[接口](language.oop5.interfaces.html)部分。"},{"type":4,"line":"自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字（如 _self_，_parent_ 或 _static_）。"},{"type":4,"line":"**Example #1 定义和使用一个类常量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyClass  "},{"type":5,"line":"{  "},{"type":4,"line":"    const constant = 'constant value';  "},{"type":5,"line":"  "},{"type":5,"line":"    function showConstant() {  "},{"type":5,"line":"        echo  self::constant . \"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo MyClass::constant . \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$classname = \"MyClass\";  "},{"type":4,"line":"echo $classname::constant . \"\\n\"; // 自 5.3.0 起  "},{"type":4,"line":"  "},{"type":4,"line":"$class = new MyClass();  "},{"type":4,"line":"$class->showConstant();  "},{"type":4,"line":"  "},{"type":4,"line":"echo $class::constant.\"\\n\"; // 自 PHP 5.3.0 起  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 静态数据示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class foo {  "},{"type":5,"line":"    // 自 PHP 5.3.0 起  "},{"type":4,"line":"    const bar = <<<'EOT'  "},{"type":4,"line":"bar  "},{"type":4,"line":"EOT;  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"和 heredoc 不同，nowdoc 可以用在任何静态数据中。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> Nowdoc 支持是在 PHP 5.3.0 新增的。"},{"type":3,"line":"9.5 类的自动加载"},{"type":4,"line":"在编写面向对象（OOP） 程序时，很多开发者为每个类新建一个 PHP 文件。 这会带来一个烦恼：每个脚本的开头，都需要包含（include）一个长长的列表（每个类都有个文件）。"},{"type":4,"line":"在 PHP 5 中，已经不再需要这样了。 [spl\\_autoload\\_register()](function.spl-autoload-register.html) 函数可以注册任意数量的自动加载器，当使用尚未被定义的类（class）和接口（interface）时自动去加载。通过注册自动加载器，脚本引擎在 PHP 出错失败前有了最后一个机会加载所需的类。"},{"type":4,"line":"**Tip**"},{"type":4,"line":"尽管 [\\_\\_autoload()](function.autoload.html) 函数也能自动加载类和接口，但更建议使用 [spl\\_autoload\\_register()](function.spl-autoload-register.html) 函数。 [spl\\_autoload\\_register()](function.spl-autoload-register.html) 提供了一种更加灵活的方式来实现类的自动加载（同一个应用中，可以支持任意数量的加载器，比如第三方库中的）。因此，不再建议使用 [\\_\\_autoload()](function.autoload.html) 函数，在以后的版本中它可能被弃用。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在 PHP 5.3 之前，\\_\\_autoload 函数抛出的异常不能被 [catch](language.exceptions.html) 语句块捕获并会导致一个致命错误（Fatal Error）。 自 PHP 5.3 起，能够 thrown 自定义的异常（Exception），随后自定义异常类即可使用。 \\_\\_autoload 函数可以递归的自动加载自定义异常类。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 自动加载不可用于 PHP 的 CLI [交互模式](features.commandline.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 如果类名比如被用于 [call\\_user\\_func()](function.call-user-func.html)，则它可能包含一些危险的字符，比如 _../_。 建议您在这样的函数中不要使用用户的输入，起码需要在 [\\_\\_autoload()](function.autoload.html) 时验证下输入。"},{"type":4,"line":"**Example #1 自动加载示例**"},{"type":4,"line":"本例尝试分别从 MyClass1.php 和 MyClass2.php 文件中加载 _MyClass1_ 和 _MyClass2_ 类。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"spl_autoload_register(function ($class_name) {  "},{"type":4,"line":"    require_once $class_name . '.php';  "},{"type":4,"line":"});  "},{"type":4,"line":"  "},{"type":4,"line":"$obj  = new MyClass1();  "},{"type":4,"line":"$obj2 = new MyClass2();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 另一个例子**"},{"type":4,"line":"本例尝试加载接口 _ITest_。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":5,"line":"spl_autoload_register(function ($name) {  "},{"type":4,"line":"    var_dump($name);  "},{"type":4,"line":"});  "},{"type":4,"line":"  "},{"type":4,"line":"class Foo implements ITest {  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/*  "},{"type":4,"line":"string(5) \"ITest\"  "},{"type":4,"line":"  "},{"type":4,"line":"Fatal error: Interface 'ITest' not found in ...  "},{"type":4,"line":"*/  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #3 自动加载在 PHP 5.3.0+ 中的异常处理**"},{"type":4,"line":"本例抛出一个异常并在 try/catch 语句块中演示。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"spl_autoload_register(function ($name) {  "},{"type":5,"line":"    echo \"Want to load $name.\\n\";  "},{"type":4,"line":"    throw new Exception(\"Unable to load $name.\");  "},{"type":4,"line":"});  "},{"type":4,"line":"  "},{"type":5,"line":"try {  "},{"type":4,"line":"    $obj = new NonLoadableClass();  "},{"type":5,"line":"} catch (Exception $e) {  "},{"type":4,"line":"    echo $e->getMessage(), \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Want to load NonLoadableClass."},{"type":4,"line":"Unable to load NonLoadableClass."},{"type":4,"line":"**Example #4 自动加载在 PHP 5.3.0+ 中的异常处理 - 没有自定义异常机制**"},{"type":4,"line":"本例将一个异常抛给不存在的自定义异常处理函数。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"spl_autoload_register(function ($name) {  "},{"type":5,"line":"    echo \"Want to load $name.\\n\";  "},{"type":4,"line":"    throw new MissingException(\"Unable to load $name.\");  "},{"type":4,"line":"});  "},{"type":4,"line":"  "},{"type":5,"line":"try {  "},{"type":4,"line":"    $obj = new NonLoadableClass();  "},{"type":5,"line":"} catch (Exception $e) {  "},{"type":4,"line":"    echo $e->getMessage(), \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Want to load NonLoadableClass."},{"type":4,"line":"Want to load MissingException."},{"type":4,"line":"Fatal error: Class 'MissingException' not found in testMissingException.php on line 4"},{"type":4,"line":"### 参见"},{"type":4,"line":"*   [unserialize()](function.unserialize.html)"},{"type":4,"line":"*   [unserialize\\_callback\\_func](var.configuration.html#unserialize-callback-func)"},{"type":4,"line":"*   [spl\\_autoload\\_register()](function.spl-autoload-register.html)"},{"type":4,"line":"*   [spl\\_autoload()](function.spl-autoload.html)"},{"type":4,"line":"*   [\\_\\_autoload()](function.autoload.html)"},{"type":3,"line":"9.6 构造函数和析构函数"},{"type":4,"line":"### 构造函数"},{"type":4,"line":"**\\_\\_construct** (\\[ [mixed](language.pseudo-types.html#language.types.mixed) `$args` \\[, `$...` \\]\\] ) : void"},{"type":4,"line":"PHP 5 允行开发者在一个类中定义一个方法作为构造函数。具有构造函数的类会在每次创建新对象时先调用此方法，所以非常适合在使用对象之前做一些初始化工作。"},{"type":4,"line":"> **Note**: 如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 **parent::\\_\\_construct()**。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承（假如没有被定义为 private 的话）。"},{"type":4,"line":"**Example #1 使用新标准的构造函数**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class BaseClass {  "},{"type":5,"line":"   function __construct() {  "},{"type":5,"line":"       print \"In BaseClass constructor\\n\";  "},{"type":4,"line":"   }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class SubClass extends BaseClass {  "},{"type":5,"line":"   function __construct() {  "},{"type":5,"line":"       parent::__construct();  "},{"type":5,"line":"       print \"In SubClass constructor\\n\";  "},{"type":4,"line":"   }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class OtherSubClass extends BaseClass {  "},{"type":4,"line":"    // inherits BaseClass's constructor  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// In BaseClass constructor  "},{"type":4,"line":"$obj = new BaseClass();  "},{"type":4,"line":"  "},{"type":4,"line":"// In BaseClass constructor  "},{"type":4,"line":"// In SubClass constructor  "},{"type":4,"line":"$obj = new SubClass();  "},{"type":4,"line":"  "},{"type":4,"line":"// In BaseClass constructor  "},{"type":4,"line":"$obj = new OtherSubClass();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"为了实现向后兼容性，如果 PHP 5 在类中找不到 [\\_\\_construct()](language.oop5.decon.html#object.construct) 函数并且也没有从父类继承一个的话，它就会尝试寻找旧式的构造函数，也就是和类同名的函数。因此唯一会产生兼容性问题的情况是：类中已有一个名为 **\\_\\_construct()** 的方法却被用于其它用途时。"},{"type":4,"line":"与其它方法不同，当 [\\_\\_construct()](language.oop5.decon.html#object.construct) 被与父类 [\\_\\_construct()](language.oop5.decon.html#object.construct) 具有不同参数的方法覆盖时，PHP 不会产生一个 **`E_STRICT`** 错误信息。"},{"type":4,"line":"自 PHP 5.3.3 起，在命名空间中，与类名同名的方法不再作为构造函数。这一改变不影响不在命名空间中的类。"},{"type":4,"line":"**Example #2 Constructors in namespaced classes**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"namespace Foo;  "},{"type":5,"line":"class Bar {  "},{"type":5,"line":"    public function Bar() {  "},{"type":5,"line":"        // treated as constructor in PHP 5.3.0-5.3.2  "},{"type":5,"line":"        // treated as regular method as of PHP 5.3.3  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 析构函数"},{"type":4,"line":"**\\_\\_destruct** ( void ) : void"},{"type":4,"line":"PHP 5 引入了析构函数的概念，这类似于其它面向对象的语言，如 C++。析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。"},{"type":4,"line":"**Example #3 析构函数示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class MyDestructableClass {  "},{"type":5,"line":"   function __construct() {  "},{"type":5,"line":"       print \"In constructor\\n\";  "},{"type":5,"line":"       $this->name = \"MyDestructableClass\";  "},{"type":4,"line":"   }  "},{"type":5,"line":"  "},{"type":5,"line":"   function __destruct() {  "},{"type":5,"line":"       print \"Destroying \" . $this->name . \"\\n\";  "},{"type":4,"line":"   }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new MyDestructableClass();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"和构造函数一样，父类的析构函数不会被引擎暗中调用。要执行父类的析构函数，必须在子类的析构函数体中显式调用 **parent::\\_\\_destruct()**。此外也和构造函数一样，子类如果自己没有定义析构函数则会继承父类的。"},{"type":4,"line":"析构函数即使在使用 [exit()](function.exit.html) 终止脚本运行时也会被调用。在析构函数中调用 [exit()](function.exit.html) 将会中止其余关闭操作的运行。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 析构函数在脚本关闭时调用，此时所有的 HTTP 头信息已经发出。脚本关闭时的工作目录有可能和在 SAPI（如 apache）中时不同。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 试图在析构函数（在脚本终止时被调用）中抛出一个异常会导致致命错误。"},{"type":3,"line":"9.7 访问控制（可见性）"},{"type":4,"line":"对属性或方法的访问控制，是通过在前面添加关键字 _public_（公有），_protected_（受保护）或 _private_（私有）来实现的。被定义为公有的类成员可以在任何地方被访问。被定义为受保护的类成员则可以被其自身以及其子类和父类访问。被定义为私有的类成员则只能被其定义所在的类访问。"},{"type":4,"line":"### 属性的访问控制"},{"type":4,"line":"类属性必须定义为公有，受保护，私有之一。如果用 _var_ 定义，则被视为公有。"},{"type":4,"line":"**Example #1 属性声明**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/**  "},{"type":4,"line":" * Define MyClass  "},{"type":4,"line":" */  "},{"type":4,"line":"class MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $public = 'Public';  "},{"type":5,"line":"    protected $protected = 'Protected';  "},{"type":4,"line":"    private $private = 'Private';  "},{"type":5,"line":"  "},{"type":5,"line":"    function printHello()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo $this->public;  "},{"type":5,"line":"        echo $this->protected;  "},{"type":5,"line":"        echo $this->private;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new MyClass();  "},{"type":4,"line":"echo $obj->public; // 这行能被正常执行  "},{"type":4,"line":"echo $obj->protected; // 这行会产生一个致命错误  "},{"type":4,"line":"echo $obj->private; // 这行也会产生一个致命错误  "},{"type":4,"line":"$obj->printHello(); // 输出 Public、Protected 和 Private  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"/**  "},{"type":4,"line":" * Define MyClass2  "},{"type":4,"line":" */  "},{"type":4,"line":"class MyClass2 extends MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 可以对 public 和 protected 进行重定义，但 private 而不能  "},{"type":4,"line":"    protected $protected = 'Protected2';  "},{"type":5,"line":"  "},{"type":5,"line":"    function printHello()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo $this->public;  "},{"type":5,"line":"        echo $this->protected;  "},{"type":5,"line":"        echo $this->private;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj2 = new MyClass2();  "},{"type":4,"line":"echo $obj2->public; // 这行能被正常执行  "},{"type":4,"line":"echo $obj2->private; // 未定义 private  "},{"type":4,"line":"echo $obj2->protected; // 这行会产生一个致命错误  "},{"type":4,"line":"$obj2->printHello(); // 输出 Public、Protected2 和 Undefined  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**: 为了兼容性考虑，在 PHP 4 中使用 _var_ 关键字对变量进行定义的方法在 PHP 5 中仍然有效（只是作为 public 关键字的一个别名）。在 PHP 5.1.3 之前的版本，该语法会产生一个 **`E_STRICT`** 警告。"},{"type":4,"line":"### 方法的访问控制"},{"type":4,"line":"类中的方法可以被定义为公有，私有或受保护。如果没有设置这些关键字，则该方法默认为公有。"},{"type":4,"line":"**Example #2 方法声明**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"/**  "},{"type":4,"line":" * Define MyClass  "},{"type":4,"line":" */  "},{"type":4,"line":"class MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 声明一个公有的构造函数  "},{"type":4,"line":"    public function __construct() { }  "},{"type":5,"line":"  "},{"type":5,"line":"    // 声明一个公有的方法  "},{"type":4,"line":"    public function MyPublic() { }  "},{"type":5,"line":"  "},{"type":5,"line":"    // 声明一个受保护的方法  "},{"type":4,"line":"    protected function MyProtected() { }  "},{"type":5,"line":"  "},{"type":5,"line":"    // 声明一个私有的方法  "},{"type":4,"line":"    private function MyPrivate() { }  "},{"type":5,"line":"  "},{"type":5,"line":"    // 此方法为公有  "},{"type":5,"line":"    function Foo()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->MyPublic();  "},{"type":5,"line":"        $this->MyProtected();  "},{"type":5,"line":"        $this->MyPrivate();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$myclass = new MyClass;  "},{"type":4,"line":"$myclass->MyPublic(); // 这行能被正常执行  "},{"type":4,"line":"$myclass->MyProtected(); // 这行会产生一个致命错误  "},{"type":4,"line":"$myclass->MyPrivate(); // 这行会产生一个致命错误  "},{"type":4,"line":"$myclass->Foo(); // 公有，受保护，私有都可以执行  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"/**  "},{"type":4,"line":" * Define MyClass2  "},{"type":4,"line":" */  "},{"type":4,"line":"class MyClass2 extends MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 此方法为公有  "},{"type":5,"line":"    function Foo2()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->MyPublic();  "},{"type":5,"line":"        $this->MyProtected();  "},{"type":5,"line":"        $this->MyPrivate(); // 这行会产生一个致命错误  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$myclass2 = new MyClass2;  "},{"type":4,"line":"$myclass2->MyPublic(); // 这行能被正常执行  "},{"type":4,"line":"$myclass2->Foo2(); // 公有的和受保护的都可执行，但私有的不行  "},{"type":4,"line":"  "},{"type":4,"line":"class Bar   "},{"type":5,"line":"{  "},{"type":5,"line":"    public function test() {  "},{"type":5,"line":"        $this->testPrivate();  "},{"type":5,"line":"        $this->testPublic();  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function testPublic() {  "},{"type":5,"line":"        echo \"Bar::testPublic\\n\";  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    private function testPrivate() {  "},{"type":5,"line":"        echo \"Bar::testPrivate\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class Foo extends Bar   "},{"type":5,"line":"{  "},{"type":5,"line":"    public function testPublic() {  "},{"type":5,"line":"        echo \"Foo::testPublic\\n\";  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    private function testPrivate() {  "},{"type":5,"line":"        echo \"Foo::testPrivate\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$myFoo = new foo();  "},{"type":5,"line":"$myFoo->test(); // Bar::testPrivate   "},{"type":4,"line":"                // Foo::testPublic  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 其它对象的访问控制"},{"type":4,"line":"同一个类的对象即使不是同一个实例也可以互相访问对方的私有与受保护成员。这是由于在这些对象的内部具体实现的细节都是已知的。"},{"type":4,"line":"**Example #3 访问同一个对象类型的私有成员**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Test  "},{"type":5,"line":"{  "},{"type":4,"line":"    private $foo;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct($foo)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->foo = $foo;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    private function bar()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo 'Accessed the private method.';  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function baz(Test $other)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        // We can change the private property:  "},{"type":5,"line":"        $other->foo = 'hello';  "},{"type":4,"line":"        var_dump($other->foo);  "},{"type":5,"line":"  "},{"type":5,"line":"        // We can also call the private method:  "},{"type":5,"line":"        $other->bar();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$test = new Test('test');  "},{"type":4,"line":"  "},{"type":4,"line":"$test->baz(new Test('other'));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"string(5) \"hello\""},{"type":4,"line":"Accessed the private method."},{"type":3,"line":"9.8 对象继承"},{"type":4,"line":"继承已为大家所熟知的一个程序设计特性，PHP 的对象模型也使用了继承。继承将会影响到类与类，对象与对象之间的关系。"},{"type":4,"line":"比如，当扩展一个类，子类就会继承父类所有公有的和受保护的方法。除非子类覆盖了父类的方法，被继承的方法都会保留其原有功能。"},{"type":4,"line":"继承对于功能的设计和抽象是非常有用的，而且对于类似的对象增加新功能就无须重新再写这些公用的功能。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 除非使用了自动加载，否则一个类必须在使用之前被定义。如果一个类扩展了另一个，则父类必须在子类之前被声明。此规则适用于类继承其它类与接口。"},{"type":4,"line":"**Example #1 继承示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"class foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function printItem($string)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo 'Foo: ' . $string . PHP_EOL;  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    public function printPHP()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo 'PHP is great.' . PHP_EOL;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class bar extends foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function printItem($string)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo 'Bar: ' . $string . PHP_EOL;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new foo();  "},{"type":4,"line":"$bar = new bar();  "},{"type":4,"line":"$foo->printItem('baz'); // Output: 'Foo: baz'  "},{"type":4,"line":"$foo->printPHP();       // Output: 'PHP is great'   "},{"type":4,"line":"$bar->printItem('baz'); // Output: 'Bar: baz'  "},{"type":4,"line":"$bar->printPHP();       // Output: 'PHP is great'  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"9.9 范围解析操作符 （::）"},{"type":4,"line":"范围解析操作符（也可称作 Paamayim Nekudotayim）或者更简单地说是一对冒号，可以用于访问[静态](language.oop5.static.html)成员，[类常量](language.oop5.constants.html)，还可以用于覆盖类中的属性和方法。"},{"type":4,"line":"当在类定义之外引用到这些项目时，要使用类名。"},{"type":4,"line":"自 PHP 5.3.0 起，可以通过变量来引用类，该变量的值不能是关键字（如 _self_，_parent_ 和 _static_）。"},{"type":4,"line":"把 Paamayim Nekudotayim 选作双冒号操作符的名字似乎有些奇怪。然而，这是 Zend 开发小组在写 Zend Engine 0.5（被用于 PHP 3 中）时所作出的决定。事实上这个词在希伯莱文就是双冒号的意思。"},{"type":4,"line":"**Example #1 在类的外部使用 :: 操作符**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class MyClass {  "},{"type":4,"line":"    const CONST_VALUE = 'A constant value';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$classname = 'MyClass';  "},{"type":4,"line":"echo $classname::CONST_VALUE; // 自 PHP 5.3.0 起  "},{"type":4,"line":"  "},{"type":4,"line":"echo MyClass::CONST_VALUE;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"self，parent 和 static 这三个特殊的关键字是用于在类定义的内部对其属性或方法进行访问的。"},{"type":4,"line":"**Example #2 在类定义内部使用 ::**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class OtherClass extends MyClass  "},{"type":5,"line":"{  "},{"type":4,"line":"    public static $my_static = 'static var';  "},{"type":5,"line":"  "},{"type":5,"line":"    public static function doubleColon() {  "},{"type":5,"line":"        echo parent::CONST_VALUE . \"\\n\";  "},{"type":5,"line":"        echo self::$my_static . \"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$classname = 'OtherClass';  "},{"type":4,"line":"echo $classname::doubleColon(); // 自 PHP 5.3.0 起  "},{"type":4,"line":"  "},{"type":4,"line":"OtherClass::doubleColon();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当一个子类覆盖其父类中的方法时，PHP 不会调用父类中已被覆盖的方法。是否调用父类的方法取决于子类。这种机制也作用于[构造函数和析构函数](language.oop5.decon.html)，[重载](language.oop5.overloading.html)以及[魔术方法](language.oop5.magic.html)。"},{"type":4,"line":"**Example #3 调用父类的方法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    protected function myFunc() {  "},{"type":5,"line":"        echo \"MyClass::myFunc()\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class OtherClass extends MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 覆盖了父类的定义  "},{"type":5,"line":"    public function myFunc()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        // 但还是可以调用父类中被覆盖的方法  "},{"type":5,"line":"        parent::myFunc();  "},{"type":5,"line":"        echo \"OtherClass::myFunc()\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$class = new OtherClass();  "},{"type":4,"line":"$class->myFunc();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"参见 [伪变量的示例](language.oop5.basic.html#language.oop5.basic.class.this)。"},{"type":3,"line":"9.10 Static（静态）关键字"},{"type":4,"line":"**Tip**"},{"type":4,"line":"本页说明了用 _static_ 关键字来定义静态方法和属性。_static_ 也可用于[定义静态变量](language.variables.scope.html#language.variables.scope.static)以及[后期静态绑定](language.oop5.late-static-bindings.html)。参见上述页面了解 _static_ 在其中的用法。"},{"type":4,"line":"声明类属性或方法为静态，就可以不实例化类而直接访问。静态属性不能通过一个类已实例化的对象来访问（但静态方法可以）。"},{"type":4,"line":"为了兼容 PHP 4，如果没有指定[访问控制](language.oop5.visibility.html)，属性和方法默认为公有。"},{"type":4,"line":"由于静态方法不需要通过对象即可调用，所以伪变量 $this 在静态方法中不可用。"},{"type":4,"line":"静态属性不可以由对象通过 -> 操作符来访问。"},{"type":4,"line":"用静态方式调用一个非静态方法会导致一个 **`E_STRICT`** 级别的错误。"},{"type":4,"line":"就像其它所有的 PHP 静态变量一样，静态属性只能被初始化为文字或常量，不能使用表达式。所以可以把静态属性初始化为整数或数组，但不能初始化为另一个变量或函数返回值，也不能指向一个对象。"},{"type":4,"line":"自 PHP 5.3.0 起，可以用一个变量来动态调用类。但该变量的值不能为关键字 _self_，_parent_ 或 _static_。"},{"type":4,"line":"**Example #1 静态属性示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Foo  "},{"type":5,"line":"{  "},{"type":4,"line":"    public static $my_static = 'foo';  "},{"type":5,"line":"  "},{"type":5,"line":"    public function staticValue() {  "},{"type":5,"line":"        return self::$my_static;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class Bar extends Foo  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function fooStatic() {  "},{"type":5,"line":"        return parent::$my_static;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"print Foo::$my_static . \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$foo = new Foo();  "},{"type":4,"line":"print $foo->staticValue() . \"\\n\";  "},{"type":4,"line":"print $foo->my_static . \"\\n\";      // Undefined \"Property\" my_static   "},{"type":4,"line":"  "},{"type":4,"line":"print $foo::$my_static . \"\\n\";  "},{"type":4,"line":"$classname = 'Foo';  "},{"type":4,"line":"print $classname::$my_static . \"\\n\"; // As of PHP 5.3.0  "},{"type":4,"line":"  "},{"type":4,"line":"print Bar::$my_static . \"\\n\";  "},{"type":4,"line":"$bar = new Bar();  "},{"type":4,"line":"print $bar->fooStatic() . \"\\n\";  "},{"type":5,"line":"?>  "},{"type":4,"line":"   </programlisting>  "},{"type":4,"line":"  </example>  "},{"type":4,"line":"  "},{"type":5,"line":"  <example>  "},{"type":5,"line":"   <title>静态方法示例</title>  "},{"type":4,"line":"    <programlisting role=\"php\">  "},{"type":4,"line":"<![CDATA[  "},{"type":4,"line":"<?php  "},{"type":5,"line":"class Foo {  "},{"type":5,"line":"    public static function aStaticMethod() {  "},{"type":5,"line":"        // ...  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"Foo::aStaticMethod();  "},{"type":4,"line":"$classname = 'Foo';  "},{"type":4,"line":"$classname::aStaticMethod(); // 自 PHP 5.3.0 起  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"9.11 抽象类"},{"type":4,"line":"PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。"},{"type":4,"line":"继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的[访问控制](language.oop5.visibility.html)必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。"},{"type":4,"line":"**Example #1 抽象类示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"abstract class AbstractClass  "},{"type":4,"line":"{  "},{"type":5,"line":" // 强制要求子类定义这些方法  "},{"type":5,"line":"    abstract protected function getValue();  "},{"type":4,"line":"    abstract protected function prefixValue($prefix);  "},{"type":5,"line":"  "},{"type":5,"line":"    // 普通方法（非抽象方法）  "},{"type":5,"line":"    public function printOut() {  "},{"type":5,"line":"        print $this->getValue() . \"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class ConcreteClass1 extends AbstractClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    protected function getValue() {  "},{"type":5,"line":"        return \"ConcreteClass1\";  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function prefixValue($prefix) {  "},{"type":5,"line":"        return \"{$prefix}ConcreteClass1\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class ConcreteClass2 extends AbstractClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function getValue() {  "},{"type":5,"line":"        return \"ConcreteClass2\";  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function prefixValue($prefix) {  "},{"type":5,"line":"        return \"{$prefix}ConcreteClass2\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$class1 = new ConcreteClass1;  "},{"type":4,"line":"$class1->printOut();  "},{"type":4,"line":"echo $class1->prefixValue('FOO_') .\"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$class2 = new ConcreteClass2;  "},{"type":4,"line":"$class2->printOut();  "},{"type":4,"line":"echo $class2->prefixValue('FOO_') .\"\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"ConcreteClass1"},{"type":4,"line":"FOO\\_ConcreteClass1"},{"type":4,"line":"ConcreteClass2"},{"type":4,"line":"FOO\\_ConcreteClass2"},{"type":4,"line":"**Example #2 抽象类示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"abstract class AbstractClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    // 我们的抽象方法仅需要定义需要的参数  "},{"type":4,"line":"    abstract protected function prefixName($name);  "},{"type":4,"line":"  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class ConcreteClass extends AbstractClass  "},{"type":4,"line":"{  "},{"type":5,"line":"  "},{"type":5,"line":"    // 我们的子类可以定义父类签名中不存在的可选参数  "},{"type":5,"line":"    public function prefixName($name, $separator = \".\") {  "},{"type":5,"line":"        if ($name == \"Pacman\") {  "},{"type":5,"line":"            $prefix = \"Mr\";  "},{"type":5,"line":"        } elseif ($name == \"Pacwoman\") {  "},{"type":5,"line":"            $prefix = \"Mrs\";  "},{"type":5,"line":"        } else {  "},{"type":5,"line":"            $prefix = \"\";  "},{"type":5,"line":"        }  "},{"type":5,"line":"        return \"{$prefix}{$separator}{$name}\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$class = new ConcreteClass;  "},{"type":4,"line":"echo $class->prefixName(\"Pacman\"), \"\\n\";  "},{"type":4,"line":"echo $class->prefixName(\"Pacwoman\"), \"\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Mr. Pacman"},{"type":4,"line":"Mrs. Pacwoman"},{"type":4,"line":"老代码中如果没有自定义类或函数被命名为“abstract”，则应该能不加修改地正常运行。"},{"type":3,"line":"9.12 对象接口"},{"type":4,"line":"使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。"},{"type":4,"line":"接口是通过 _interface_ 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。"},{"type":4,"line":"接口中定义的所有方法都必须是公有，这是接口的特性。"},{"type":4,"line":"需要注意的是，在接口中定义一个[构造方法](language.oop5.decon.html#language.oop5.decon.constructor)是被允许的。在有些场景下这可能会很有用，例如用于工厂模式时。"},{"type":4,"line":"### 实现（_implements_）"},{"type":4,"line":"要实现一个接口，使用 _implements_ 操作符。类中必须实现接口中定义的所有方法，否则会报一个致命错误。类可以实现多个接口，用逗号来分隔多个接口的名称。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在 PHP 5.3.9 之前，实现多个接口时，接口中的方法不能有重名，因为这可能会有歧义。在最近的 PHP 版本中，只要这些重名的方法签名相同，这种行为就是允许的。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 接口也可以继承，通过使用 [extends](language.oop5.inheritance.html) 操作符。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。"},{"type":4,"line":"### _常量_"},{"type":4,"line":"接口中也可以定义常量。接口常量和[类常量](language.oop5.constants.html)的使用完全相同，但是不能被子类或子接口所覆盖。"},{"type":4,"line":"### 范例"},{"type":4,"line":"**Example #1 接口示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"// 声明一个'iTemplate'接口  "},{"type":4,"line":"interface iTemplate  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function setVariable($name, $var);  "},{"type":4,"line":"    public function getHtml($template);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"// 实现接口  "},{"type":4,"line":"// 下面的写法是正确的  "},{"type":4,"line":"class Template implements iTemplate  "},{"type":5,"line":"{  "},{"type":5,"line":"    private $vars = array();  "},{"type":5,"line":"    "},{"type":5,"line":"    public function setVariable($name, $var)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->vars[$name] = $var;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    "},{"type":5,"line":"    public function getHtml($template)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        foreach($this->vars as $name => $value) {  "},{"type":5,"line":"            $template = str_replace('{' . $name . '}', $value, $template);  "},{"type":5,"line":"        }  "},{"type":5,"line":"   "},{"type":5,"line":"        return $template;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 下面的写法是错误的，会报错，因为没有实现 getHtml()：  "},{"type":4,"line":"// Fatal error: Class BadTemplate contains 1 abstract methods  "},{"type":4,"line":"// and must therefore be declared abstract (iTemplate::getHtml)  "},{"type":4,"line":"class BadTemplate implements iTemplate  "},{"type":5,"line":"{  "},{"type":5,"line":"    private $vars = array();  "},{"type":5,"line":"    "},{"type":5,"line":"    public function setVariable($name, $var)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->vars[$name] = $var;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 可扩充的接口**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"interface a  "},{"type":5,"line":"{  "},{"type":4,"line":"    public function foo();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"interface b extends a  "},{"type":5,"line":"{  "},{"type":4,"line":"    public function baz(Baz $baz);  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 正确写法  "},{"type":4,"line":"class c implements b  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function foo()  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function baz(Baz $baz)  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 错误写法会导致一个致命错误  "},{"type":4,"line":"class d implements b  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function foo()  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function baz(Foo $foo)  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #3 继承多个接口**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"interface a  "},{"type":5,"line":"{  "},{"type":4,"line":"    public function foo();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"interface b  "},{"type":5,"line":"{  "},{"type":4,"line":"    public function bar();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"interface c extends a, b  "},{"type":5,"line":"{  "},{"type":4,"line":"    public function baz();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class d implements c  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function foo()  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function bar()  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function baz()  "},{"type":5,"line":"    {  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #4 使用接口常量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"interface a  "},{"type":5,"line":"{  "},{"type":4,"line":"    const b = 'Interface constant';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 输出接口常量  "},{"type":4,"line":"echo a::b;  "},{"type":4,"line":"  "},{"type":4,"line":"// 错误写法，因为常量不能被覆盖。接口常量的概念和类常量是一样的。  "},{"type":4,"line":"class b implements a  "},{"type":5,"line":"{  "},{"type":4,"line":"    const b = 'Class constant';  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"接口加上类型约束，提供了一种很好的方式来确保某个对象包含有某些方法。参见 [instanceof](language.operators.type.html) 操作符和[类型约束](language.oop5.typehinting.html)。"},{"type":3,"line":"9.13 Trait"},{"type":4,"line":"自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。"},{"type":4,"line":"Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。"},{"type":4,"line":"Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。 无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。"},{"type":4,"line":"**Example #1 Trait 示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait ezcReflectionReturnInfo {  "},{"type":5,"line":"    function getReturnType() { /*1*/ }  "},{"type":4,"line":"    function getReturnDescription() { /*2*/ }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class ezcReflectionMethod extends ReflectionMethod {  "},{"type":5,"line":"    use ezcReflectionReturnInfo;  "},{"type":4,"line":"    /* ... */  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class ezcReflectionFunction extends ReflectionFunction {  "},{"type":5,"line":"    use ezcReflectionReturnInfo;  "},{"type":4,"line":"    /* ... */  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 优先级"},{"type":4,"line":"从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。"},{"type":4,"line":"**Example #2 优先顺序示例**"},{"type":4,"line":"从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class Base {  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        echo 'Hello ';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"trait SayWorld {  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        parent::sayHello();  "},{"type":5,"line":"        echo 'World!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class MyHelloWorld extends Base {  "},{"type":4,"line":"    use SayWorld;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$o = new MyHelloWorld();  "},{"type":4,"line":"$o->sayHello();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Hello World!"},{"type":4,"line":"**Example #3 另一个优先级顺序的例子**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait HelloWorld {  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        echo 'Hello World!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class TheWorldIsNotEnough {  "},{"type":5,"line":"    use HelloWorld;  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        echo 'Hello Universe!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$o = new TheWorldIsNotEnough();  "},{"type":4,"line":"$o->sayHello();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Hello Universe!"},{"type":4,"line":"### 多个 trait"},{"type":4,"line":"通过逗号分隔，在 use 声明列出多个 trait，可以都插入到一个类中。"},{"type":4,"line":"**Example #4 多个 trait 的用法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait Hello {  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        echo 'Hello ';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"trait World {  "},{"type":5,"line":"    public function sayWorld() {  "},{"type":5,"line":"        echo 'World';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class MyHelloWorld {  "},{"type":5,"line":"    use Hello, World;  "},{"type":5,"line":"    public function sayExclamationMark() {  "},{"type":5,"line":"        echo '!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$o = new MyHelloWorld();  "},{"type":4,"line":"$o->sayHello();  "},{"type":4,"line":"$o->sayWorld();  "},{"type":4,"line":"$o->sayExclamationMark();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Hello World!"},{"type":4,"line":"### 冲突的解决"},{"type":4,"line":"如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。"},{"type":4,"line":"为了解决多个 trait 在同一个类中的命名冲突，需要使用 _insteadof_ 操作符来明确指定使用冲突方法中的哪一个。"},{"type":4,"line":"以上方式仅允许排除掉其它方法，_as_ 操作符可以 为某个方法引入别名。 注意，_as_ 操作符不会对方法进行重命名，也不会影响其方法。"},{"type":4,"line":"**Example #5 冲突的解决**"},{"type":4,"line":"在本例中 Talker 使用了 trait A 和 B。由于 A 和 B 有冲突的方法，其定义了使用 trait B 中的 smallTalk 以及 trait A 中的 bigTalk。"},{"type":4,"line":"Aliased\\_Talker 使用了 _as_ 操作符来定义了 _talk_ 来作为 B 的 bigTalk 的别名。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait A {  "},{"type":5,"line":"    public function smallTalk() {  "},{"type":5,"line":"        echo 'a';  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function bigTalk() {  "},{"type":5,"line":"        echo 'A';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"trait B {  "},{"type":5,"line":"    public function smallTalk() {  "},{"type":5,"line":"        echo 'b';  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function bigTalk() {  "},{"type":5,"line":"        echo 'B';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class Talker {  "},{"type":5,"line":"    use A, B {  "},{"type":5,"line":"        B::smallTalk insteadof A;  "},{"type":5,"line":"        A::bigTalk insteadof B;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class Aliased_Talker {  "},{"type":5,"line":"    use A, B {  "},{"type":5,"line":"        B::smallTalk insteadof A;  "},{"type":5,"line":"        A::bigTalk insteadof B;  "},{"type":5,"line":"        B::bigTalk as talk;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在 PHP 7.0 之前，在类里定义和 trait 同名的属性，哪怕是完全兼容的也会抛出 **`E_STRICT`**（完全兼容的意思：具有相同的访问可见性、初始默认值）。"},{"type":4,"line":"### 修改方法的访问控制"},{"type":4,"line":"使用 _as_ 语法还可以用来调整方法的访问控制。"},{"type":4,"line":"**Example #6 修改方法的访问控制**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait HelloWorld {  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        echo 'Hello World!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 修改 sayHello 的访问控制  "},{"type":5,"line":"class MyClass1 {  "},{"type":4,"line":"    use HelloWorld { sayHello as protected; }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 给方法一个改变了访问控制的别名  "},{"type":4,"line":"// 原版 sayHello 的访问控制则没有发生变化  "},{"type":5,"line":"class MyClass2 {  "},{"type":4,"line":"    use HelloWorld { sayHello as private myPrivateHello; }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 从 trait 来组成 trait"},{"type":4,"line":"正如 class 能够使用 trait 一样，其它 trait 也能够使用 trait。在 trait 定义时通过使用一个或多个 trait，能够组合其它 trait 中的部分或全部成员。"},{"type":4,"line":"**Example #7 从 trait 来组成 trait**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait Hello {  "},{"type":5,"line":"    public function sayHello() {  "},{"type":5,"line":"        echo 'Hello ';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"trait World {  "},{"type":5,"line":"    public function sayWorld() {  "},{"type":5,"line":"        echo 'World!';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"trait HelloWorld {  "},{"type":4,"line":"    use Hello, World;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class MyHelloWorld {  "},{"type":4,"line":"    use HelloWorld;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$o = new MyHelloWorld();  "},{"type":4,"line":"$o->sayHello();  "},{"type":4,"line":"$o->sayWorld();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Hello World!"},{"type":4,"line":"### Trait 的抽象成员"},{"type":4,"line":"为了对使用的类施加强制要求，trait 支持抽象方法的使用。"},{"type":4,"line":"**Example #8 表示通过抽象方法来进行强制要求**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait Hello {  "},{"type":5,"line":"    public function sayHelloWorld() {  "},{"type":5,"line":"        echo 'Hello'.$this->getWorld();  "},{"type":5,"line":"    }  "},{"type":4,"line":"    abstract public function getWorld();  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class MyHelloWorld {  "},{"type":5,"line":"    private $world;  "},{"type":5,"line":"    use Hello;  "},{"type":5,"line":"    public function getWorld() {  "},{"type":5,"line":"        return $this->world;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function setWorld($val) {  "},{"type":5,"line":"        $this->world = $val;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### Trait 的静态成员"},{"type":4,"line":"Traits 可以被静态成员静态方法定义。"},{"type":4,"line":"**Example #9 静态变量**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait Counter {  "},{"type":5,"line":"    public function inc() {  "},{"type":5,"line":"        static $c = 0;  "},{"type":5,"line":"        $c = $c + 1;  "},{"type":5,"line":"        echo \"$c\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class C1 {  "},{"type":4,"line":"    use Counter;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class C2 {  "},{"type":4,"line":"    use Counter;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$o = new C1(); $o->inc(); // echo 1  "},{"type":4,"line":"$p = new C2(); $p->inc(); // echo 1  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #10 静态方法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait StaticExample {  "},{"type":5,"line":"    public static function doSomething() {  "},{"type":5,"line":"        return 'Doing something';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class Example {  "},{"type":4,"line":"    use StaticExample;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"Example::doSomething();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### 属性"},{"type":4,"line":"Trait 同样可以定义属性。"},{"type":4,"line":"**Example #11 定义属性**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait PropertiesTrait {  "},{"type":4,"line":"    public $x = 1;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class PropertiesExample {  "},{"type":4,"line":"    use PropertiesTrait;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$example = new PropertiesExample;  "},{"type":4,"line":"$example->x;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"Trait 定义了一个属性后，类就不能定义同样名称的属性，否则会产生 fatal error。 有种情况例外：属性是兼容的（同样的访问可见度、初始默认值）。 在 PHP 7.0 之前，属性是兼容的，则会有 E\\_STRICT 的提醒。"},{"type":4,"line":"**Example #12 解决冲突**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"trait PropertiesTrait {  "},{"type":5,"line":"    public $same = true;  "},{"type":4,"line":"    public $different = false;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class PropertiesExample {  "},{"type":5,"line":"    use PropertiesTrait;  "},{"type":5,"line":"    public $same = true; // PHP 7.0.0 后没问题，之前版本是 E_STRICT 提醒  "},{"type":4,"line":"    public $different = true; // 致命错误  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"9.14 匿名类"},{"type":4,"line":"PHP 7 开始支持匿名类。 匿名类很有用，可以创建一次性的简单对象。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"// PHP 7 之前的代码  "},{"type":4,"line":"class Logger  "},{"type":5,"line":"{  "},{"type":5,"line":"    public function log($msg)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo $msg;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$util->setLogger(new Logger());  "},{"type":4,"line":"  "},{"type":4,"line":"// 使用了 PHP 7+ 后的代码  "},{"type":5,"line":"$util->setLogger(new class {  "},{"type":5,"line":"    public function log($msg)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo $msg;  "},{"type":4,"line":"    }  "},{"type":4,"line":"});"},{"type":4,"line":"```"},{"type":4,"line":"可以传递参数到匿名类的构造器，也可以扩展（extend）其他类、实现接口（implement interface），以及像其他普通的类一样使用 trait："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"class SomeClass {}  "},{"type":4,"line":"interface SomeInterface {}  "},{"type":4,"line":"trait SomeTrait {}  "},{"type":4,"line":"  "},{"type":5,"line":"var_dump(new class(10) extends SomeClass implements SomeInterface {  "},{"type":4,"line":"    private $num;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct($num)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->num = $num;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":4,"line":"    use SomeTrait;  "},{"type":4,"line":"});"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"object(class@anonymous)#1 (1) {"},{"type":4,"line":"  \\[\"Command line code0x104c5b612\":\"class@anonymous\":private\\]=>"},{"type":4,"line":"  int(10)"},{"type":4,"line":"}"},{"type":4,"line":"匿名类被嵌套进普通 Class 后，不能访问这个外部类（Outer class）的 private（私有）、protected（受保护）方法或者属性。 为了访问外部类（Outer class）protected 属性或方法，匿名类可以 extend（扩展）此外部类。 为了使用外部类（Outer class）的 private 属性，必须通过构造器传进来："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"class Outer  "},{"type":5,"line":"{  "},{"type":5,"line":"    private $prop = 1;  "},{"type":4,"line":"    protected $prop2 = 2;  "},{"type":5,"line":"  "},{"type":5,"line":"    protected function func1()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        return 3;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function func2()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        return new class($this->prop) extends Outer {  "},{"type":4,"line":"            private $prop3;  "},{"type":5,"line":"  "},{"type":5,"line":"            public function __construct($prop)  "},{"type":5,"line":"            {  "},{"type":5,"line":"                $this->prop3 = $prop;  "},{"type":4,"line":"            }  "},{"type":5,"line":"  "},{"type":5,"line":"            public function func3()  "},{"type":5,"line":"            {  "},{"type":5,"line":"                return $this->prop2 + $this->prop3 + $this->func1();  "},{"type":5,"line":"            }  "},{"type":5,"line":"        };  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"echo (new Outer)->func2()->func3();"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"6"},{"type":4,"line":"声明的同一个匿名类，所创建的对象都是这个类的实例。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function anonymous_class()  "},{"type":5,"line":"{  "},{"type":4,"line":"    return new class {};  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"if (get_class(anonymous_class()) === get_class(anonymous_class())) {  "},{"type":4,"line":"    echo 'same class';  "},{"type":5,"line":"} else {  "},{"type":4,"line":"    echo 'different class';  "},{"type":4,"line":"}"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"same class"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 注意，匿名类的名称是通过引擎赋予的，如下例所示。 由于实现的细节，不应该去依赖这个类名。"},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> echo get_class(new class {});"},{"type":4,"line":"```"},{"type":4,"line":"> "},{"type":4,"line":"> 以上例程的输出类似于："},{"type":4,"line":"> "},{"type":4,"line":"> class@anonymous/in/oNi1A0x7f8636ad2021"},{"type":4,"line":"9.15 重载"},{"type":4,"line":"--"},{"type":4,"line":"PHP所提供的重载（overloading）是指动态地创建类属性和方法。我们是通过魔术方法（magic methods）来实现的。"},{"type":4,"line":"当调用当前环境下未定义或不[可见](language.oop5.visibility.html)的类属性或方法时，重载方法会被调用。本节后面将使用不可访问属性（inaccessible properties）和不可访问方法（inaccessible methods）来称呼这些未定义或不可见的类属性或方法。"},{"type":4,"line":"所有的重载方法都必须被声明为 _public_。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 这些魔术方法的参数都不能[通过引用传递](functions.arguments.html#functions.arguments.by-reference)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> PHP中的重载与其它绝大多数面向对象语言不同。传统的重载是用于提供多个同名的类方法，但各方法的参数类型和个数不同。"},{"type":4,"line":"### 更新日志"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"5.3.0"},{"type":4,"line":"新增 [\\_\\_callStatic()](language.oop5.overloading.html#object.callstatic)魔术方法。可见性未设置为 public 或未声明为 static 的时候会产生一个警告。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"新增 [\\_\\_isset()](language.oop5.overloading.html#object.isset) 和 [\\_\\_unset()](language.oop5.overloading.html#object.unset) 两个魔术方法。"},{"type":4,"line":"### 属性重载"},{"type":4,"line":"public **\\_\\_set** ( string `$name` , [mixed](language.pseudo-types.html#language.types.mixed) `$value` ) : void"},{"type":4,"line":"public **\\_\\_get** ( string `$name` ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"public **\\_\\_isset** ( string `$name` ) : bool"},{"type":4,"line":"public **\\_\\_unset** ( string `$name` ) : void"},{"type":4,"line":"在给不可访问属性赋值时，[\\_\\_set()](language.oop5.overloading.html#object.set) 会被调用。"},{"type":4,"line":"读取不可访问属性的值时，[\\_\\_get()](language.oop5.overloading.html#object.get) 会被调用。"},{"type":4,"line":"当对不可访问属性调用 [isset()](function.isset.html) 或 [empty()](function.empty.html) 时，[\\_\\_isset()](language.oop5.overloading.html#object.isset) 会被调用。"},{"type":4,"line":"当对不可访问属性调用 [unset()](function.unset.html) 时，[\\_\\_unset()](language.oop5.overloading.html#object.unset) 会被调用。"},{"type":4,"line":"参数 $name 是指要操作的变量名称。[\\_\\_set()](language.oop5.overloading.html#object.set) 方法的 $value 参数指定了 $name 变量的值。"},{"type":4,"line":"属性重载只能在对象中进行。在静态方法中，这些魔术方法将不会被调用。所以这些方法都不能被 声明为 [static](language.oop5.static.html)。从 PHP 5.3.0 起, 将这些魔术方法定义为 _static_ 会产生一个警告。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 因为 PHP 处理赋值运算的方式，[\\_\\_set()](language.oop5.overloading.html#object.set) 的返回值将被忽略。类似的, 在下面这样的链式赋值中，[\\_\\_get()](language.oop5.overloading.html#object.get) 不会被调用："},{"type":4,"line":"> "},{"type":4,"line":">  _$a = $obj->b = 8;_ "},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在除 [isset()](function.isset.html) 外的其它语言结构中无法使用重载的属性，这意味着当对一个重载的属性使用 [empty()](function.empty.html) 时，重载魔术方法将不会被调用。"},{"type":4,"line":"> "},{"type":4,"line":"> 为避开此限制，必须将重载属性赋值到本地变量再使用 [empty()](function.empty.html)。"},{"type":4,"line":"**Example #1 使用 [\\_\\_get()](language.oop5.overloading.html#object.get)，[\\_\\_set()](language.oop5.overloading.html#object.set)，[\\_\\_isset()](language.oop5.overloading.html#object.isset) 和 [\\_\\_unset()](language.oop5.overloading.html#object.unset) 进行属性重载**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class PropertyTest {  "},{"type":5,"line":"     /**  被重载的数据保存在此  */  "},{"type":4,"line":"    private $data = array();  "},{"type":5,"line":"  "},{"type":5,"line":"   "},{"type":5,"line":"     /**  重载不能被用在已经定义的属性  */  "},{"type":4,"line":"    public $declared = 1;  "},{"type":5,"line":"  "},{"type":5,"line":"     /**  只有从类外部访问这个属性时，重载才会发生 */  "},{"type":4,"line":"    private $hidden = 2;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __set($name, $value)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"Setting '$name' to '$value'\\n\";  "},{"type":5,"line":"        $this->data[$name] = $value;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __get($name)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"Getting '$name'\\n\";  "},{"type":5,"line":"        if (array_key_exists($name, $this->data)) {  "},{"type":5,"line":"            return $this->data[$name];  "},{"type":4,"line":"        }  "},{"type":5,"line":"  "},{"type":5,"line":"        $trace = debug_backtrace();  "},{"type":5,"line":"        trigger_error(  "},{"type":5,"line":"            'Undefined property via __get(): ' . $name .  "},{"type":5,"line":"            ' in ' . $trace[0]['file'] .  "},{"type":5,"line":"            ' on line ' . $trace[0]['line'],  "},{"type":5,"line":"            E_USER_NOTICE);  "},{"type":5,"line":"        return null;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    /**  PHP 5.1.0之后版本 */  "},{"type":5,"line":"    public function __isset($name)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"Is '$name' set?\\n\";  "},{"type":5,"line":"        return isset($this->data[$name]);  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    /**  PHP 5.1.0之后版本 */  "},{"type":5,"line":"    public function __unset($name)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        echo \"Unsetting '$name'\\n\";  "},{"type":5,"line":"        unset($this->data[$name]);  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    /**  非魔术方法  */  "},{"type":5,"line":"    public function getHidden()   "},{"type":5,"line":"    {  "},{"type":5,"line":"        return $this->hidden;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"<pre>\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new PropertyTest;  "},{"type":4,"line":"  "},{"type":4,"line":"$obj->a = 1;  "},{"type":4,"line":"echo $obj->a . \"\\n\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(isset($obj->a));  "},{"type":4,"line":"unset($obj->a);  "},{"type":4,"line":"var_dump(isset($obj->a));  "},{"type":4,"line":"echo \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo $obj->declared . \"\\n\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"Let's experiment with the private property named 'hidden':\\n\";  "},{"type":4,"line":"echo \"Privates are visible inside the class, so __get() not used...\\n\";  "},{"type":4,"line":"echo $obj->getHidden() . \"\\n\";  "},{"type":4,"line":"echo \"Privates not visible outside of class, so __get() is used...\\n\";  "},{"type":4,"line":"echo $obj->hidden . \"\\n\";  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Setting 'a' to '1'"},{"type":4,"line":"Getting 'a'"},{"type":4,"line":"1"},{"type":4,"line":"Is 'a' set?"},{"type":4,"line":"bool(true)"},{"type":4,"line":"Unsetting 'a'"},{"type":4,"line":"Is 'a' set?"},{"type":4,"line":"bool(false)"},{"type":4,"line":"1"},{"type":4,"line":"Let's experiment with the private property named 'hidden':"},{"type":4,"line":"Privates are visible inside the class, so \\_\\_get() not used..."},{"type":4,"line":"2"},{"type":4,"line":"Privates not visible outside of class, so \\_\\_get() is used..."},{"type":4,"line":"Getting 'hidden'"},{"type":4,"line":"Notice:  Undefined property via \\_\\_get(): hidden in <file> on line 70 in <file> on line 29"},{"type":4,"line":"### 方法重载"},{"type":4,"line":"public **\\_\\_call** ( string `$name` , array `$arguments` ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"public static **\\_\\_callStatic** ( string `$name` , array `$arguments` ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"在对象中调用一个不可访问方法时，[\\_\\_call()](language.oop5.overloading.html#object.call) 会被调用。"},{"type":4,"line":"在静态上下文中调用一个不可访问方法时，[\\_\\_callStatic()](language.oop5.overloading.html#object.callstatic) 会被调用。"},{"type":4,"line":"$name 参数是要调用的方法名称。$arguments 参数是一个枚举数组，包含着要传递给方法 $name 的参数。"},{"type":4,"line":"**Example #2 使用 [\\_\\_call()](language.oop5.overloading.html#object.call) 和 [\\_\\_callStatic()](language.oop5.overloading.html#object.callstatic) 对方法重载**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MethodTest   "},{"type":5,"line":"{  "},{"type":5,"line":"    public function __call($name, $arguments)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        // 注意: $name 的值区分大小写  "},{"type":5,"line":"        echo \"Calling object method '$name' \"  "},{"type":5,"line":"             . implode(', ', $arguments). \"\\n\";  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    /**  PHP 5.3.0之后版本  */  "},{"type":5,"line":"    public static function __callStatic($name, $arguments)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        // 注意: $name 的值区分大小写  "},{"type":5,"line":"        echo \"Calling static method '$name' \"  "},{"type":5,"line":"             . implode(', ', $arguments). \"\\n\";  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new MethodTest;  "},{"type":4,"line":"$obj->runTest('in object context');  "},{"type":4,"line":"  "},{"type":4,"line":"MethodTest::runTest('in static context');  // PHP 5.3.0之后版本  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Calling object method 'runTest' in object context"},{"type":4,"line":"Calling static method 'runTest' in static context"},{"type":3,"line":"9.16 遍历对象"},{"type":4,"line":"PHP 5 提供了一种定义对象的方法使其可以通过单元列表来遍历，例如用 [foreach](control-structures.foreach.html) 语句。默认情况下，所有[可见](language.oop5.visibility.html)属性都将被用于遍历。"},{"type":4,"line":"**Example #1 简单的对象遍历**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $var1 = 'value 1';  "},{"type":5,"line":"    public $var2 = 'value 2';  "},{"type":4,"line":"    public $var3 = 'value 3';  "},{"type":5,"line":"  "},{"type":5,"line":"    protected $protected = 'protected var';  "},{"type":4,"line":"    private   $private   = 'private var';  "},{"type":5,"line":"  "},{"type":5,"line":"    function iterateVisible() {  "},{"type":5,"line":"       echo \"MyClass::iterateVisible:\\n\";  "},{"type":5,"line":"       foreach($this as $key => $value) {  "},{"type":5,"line":"           print \"$key => $value\\n\";  "},{"type":5,"line":"       }  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$class = new MyClass();  "},{"type":4,"line":"  "},{"type":5,"line":"foreach($class as $key => $value) {  "},{"type":4,"line":"    print \"$key => $value\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"echo \"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"$class->iterateVisible();  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"var1 => value 1"},{"type":4,"line":"var2 => value 2"},{"type":4,"line":"var3 => value 3"},{"type":4,"line":"MyClass::iterateVisible:"},{"type":4,"line":"var1 => value 1"},{"type":4,"line":"var2 => value 2"},{"type":4,"line":"var3 => value 3"},{"type":4,"line":"protected => protected var"},{"type":4,"line":"private => private var"},{"type":4,"line":"如上所示，[foreach](control-structures.foreach.html) 遍历了所有其能够访问的[可见](language.oop5.visibility.html)属性。"},{"type":4,"line":"更进一步，可以实现 **Iterator** [接口](language.oop5.interfaces.html)。可以让对象自行决定如何遍历以及每次遍历时那些值可用。"},{"type":4,"line":"**Example #2 实现 Iterator 接口的对象遍历**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyIterator implements Iterator  "},{"type":5,"line":"{  "},{"type":4,"line":"    private $var = array();  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct($array)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        if (is_array($array)) {  "},{"type":5,"line":"            $this->var = $array;  "},{"type":5,"line":"        }  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function rewind() {  "},{"type":5,"line":"        echo \"rewinding\\n\";  "},{"type":5,"line":"        reset($this->var);  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function current() {  "},{"type":5,"line":"        $var = current($this->var);  "},{"type":5,"line":"        echo \"current: $var\\n\";  "},{"type":5,"line":"        return $var;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function key() {  "},{"type":5,"line":"        $var = key($this->var);  "},{"type":5,"line":"        echo \"key: $var\\n\";  "},{"type":5,"line":"        return $var;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function next() {  "},{"type":5,"line":"        $var = next($this->var);  "},{"type":5,"line":"        echo \"next: $var\\n\";  "},{"type":5,"line":"        return $var;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function valid() {  "},{"type":5,"line":"        $var = $this->current() !== false;  "},{"type":5,"line":"        echo \"valid: {$var}\\n\";  "},{"type":5,"line":"        return $var;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$values = array(1,2,3);  "},{"type":4,"line":"$it = new MyIterator($values);  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($it as $a => $b) {  "},{"type":4,"line":"    print \"$a: $b\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"rewinding"},{"type":4,"line":"current: 1"},{"type":4,"line":"valid: 1"},{"type":4,"line":"current: 1"},{"type":4,"line":"key: 0"},{"type":4,"line":"0: 1"},{"type":4,"line":"next: 2"},{"type":4,"line":"current: 2"},{"type":4,"line":"valid: 1"},{"type":4,"line":"current: 2"},{"type":4,"line":"key: 1"},{"type":4,"line":"1: 2"},{"type":4,"line":"next: 3"},{"type":4,"line":"current: 3"},{"type":4,"line":"valid: 1"},{"type":4,"line":"current: 3"},{"type":4,"line":"key: 2"},{"type":4,"line":"2: 3"},{"type":4,"line":"next:"},{"type":4,"line":"current:"},{"type":4,"line":"valid:"},{"type":4,"line":"可以用 **IteratorAggregate** [接口](language.oop5.interfaces.html)以替代实现所有的 **Iterator** 方法。**IteratorAggregate** 只需要实现一个方法 [IteratorAggregate::getIterator()](iteratoraggregate.getiterator.html)，其应返回一个实现了 **Iterator** 的类的实例。"},{"type":4,"line":"**Example #3 通过实现 IteratorAggregate 来遍历对象**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class MyCollection implements IteratorAggregate  "},{"type":5,"line":"{  "},{"type":5,"line":"    private $items = array();  "},{"type":4,"line":"    private $count = 0;  "},{"type":5,"line":"  "},{"type":5,"line":"    // Required definition of interface IteratorAggregate  "},{"type":5,"line":"    public function getIterator() {  "},{"type":5,"line":"        return new MyIterator($this->items);  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function add($value) {  "},{"type":5,"line":"        $this->items[$this->count++] = $value;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$coll = new MyCollection();  "},{"type":4,"line":"$coll->add('value 1');  "},{"type":4,"line":"$coll->add('value 2');  "},{"type":4,"line":"$coll->add('value 3');  "},{"type":4,"line":"  "},{"type":5,"line":"foreach ($coll as $key => $val) {  "},{"type":4,"line":"    echo \"key/value: [$key -> $val]\\n\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"rewinding"},{"type":4,"line":"current: value 1"},{"type":4,"line":"valid: 1"},{"type":4,"line":"current: value 1"},{"type":4,"line":"key: 0"},{"type":4,"line":"key/value: \\[0 -> value 1\\]"},{"type":4,"line":"next: value 2"},{"type":4,"line":"current: value 2"},{"type":4,"line":"valid: 1"},{"type":4,"line":"current: value 2"},{"type":4,"line":"key: 1"},{"type":4,"line":"key/value: \\[1 -> value 2\\]"},{"type":4,"line":"next: value 3"},{"type":4,"line":"current: value 3"},{"type":4,"line":"valid: 1"},{"type":4,"line":"current: value 3"},{"type":4,"line":"key: 2"},{"type":4,"line":"key/value: \\[2 -> value 3\\]"},{"type":4,"line":"next:"},{"type":4,"line":"current:"},{"type":4,"line":"valid:"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 更多遍历的示例见 [SPL 扩展](spl.iterators.html)。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> PHP 5.5 及以后版本的用户也可参考[生成器](language.generators.html)，其提供了另一方法来定义 Iterators。"},{"type":3,"line":"9.17 魔术方法"},{"type":4,"line":"[\\_\\_construct()](language.oop5.decon.html#object.construct)， [\\_\\_destruct()](language.oop5.decon.html#object.destruct)， [\\_\\_call()](language.oop5.overloading.html#object.call)， [\\_\\_callStatic()](language.oop5.overloading.html#object.callstatic)， [\\_\\_get()](language.oop5.overloading.html#object.get)， [\\_\\_set()](language.oop5.overloading.html#object.set)， [\\_\\_isset()](language.oop5.overloading.html#object.isset)， [\\_\\_unset()](language.oop5.overloading.html#object.unset)， [\\_\\_sleep()](language.oop5.magic.html#object.sleep)， [\\_\\_wakeup()](language.oop5.magic.html#object.wakeup)， [\\_\\_toString()](language.oop5.magic.html#object.tostring)， [\\_\\_invoke()](language.oop5.magic.html#object.invoke)， [\\_\\_set\\_state()](language.oop5.magic.html#object.set-state)， [\\_\\_clone()](language.oop5.cloning.html#object.clone) 和 [\\_\\_debugInfo()](language.oop5.magic.html#object.debuginfo) 等方法在 PHP 中被称为魔术方法（Magic methods）。在命名自己的类方法时不能使用这些方法名，除非是想使用其魔术功能。"},{"type":4,"line":"**Caution**"},{"type":4,"line":"PHP 将所有以 \\_\\_（两个下划线）开头的类方法保留为魔术方法。所以在定义类方法时，除了上述魔术方法，建议不要以 \\_\\_ 为前缀。"},{"type":4,"line":"### [\\_\\_sleep()](language.oop5.magic.html#object.sleep) 和 [\\_\\_wakeup()](language.oop5.magic.html#object.wakeup)"},{"type":4,"line":"public **\\_\\_sleep** ( void ) : array"},{"type":4,"line":"**\\_\\_wakeup** ( void ) : void"},{"type":4,"line":"[serialize()](function.serialize.html) 函数会检查类中是否存在一个魔术方法 [\\_\\_sleep()](language.oop5.magic.html#object.sleep)。如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 **`NULL`** 被序列化，并产生一个 **`E_NOTICE`** 级别的错误。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> [\\_\\_sleep()](language.oop5.magic.html#object.sleep) 不能返回父类的私有成员的名字。这样做会产生一个 **`E_NOTICE`** 级别的错误。可以用 **Serializable** 接口来替代。"},{"type":4,"line":"[\\_\\_sleep()](language.oop5.magic.html#object.sleep) 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。"},{"type":4,"line":"与之相反，[unserialize()](function.unserialize.html) 会检查是否存在一个 [\\_\\_wakeup()](language.oop5.magic.html#object.wakeup) 方法。如果存在，则会先调用 _\\_\\_wakeup_ 方法，预先准备对象需要的资源。"},{"type":4,"line":"[\\_\\_wakeup()](language.oop5.magic.html#object.wakeup) 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。"},{"type":4,"line":"**Example #1 Sleep 和 wakeup**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class Connection   "},{"type":5,"line":"{  "},{"type":5,"line":"    protected $link;  "},{"type":5,"line":"    private $server, $username, $password, $db;  "},{"type":5,"line":"      "},{"type":5,"line":"    public function __construct($server, $username, $password, $db)  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->server = $server;  "},{"type":5,"line":"        $this->username = $username;  "},{"type":5,"line":"        $this->password = $password;  "},{"type":5,"line":"        $this->db = $db;  "},{"type":5,"line":"        $this->connect();  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    private function connect()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->link = mysql_connect($this->server, $this->username, $this->password);  "},{"type":5,"line":"        mysql_select_db($this->db, $this->link);  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    public function __sleep()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        return array('server', 'username', 'password', 'db');  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    public function __wakeup()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->connect();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"### [\\_\\_toString()](language.oop5.magic.html#object.tostring)"},{"type":4,"line":"public **\\_\\_toString** ( void ) : string"},{"type":4,"line":"[\\_\\_toString()](language.oop5.magic.html#object.tostring) 方法用于一个类被当成字符串时应怎样回应。例如 _echo $obj;_ 应该显示些什么。此方法必须返回一个字符串，否则将发出一条 **`E_RECOVERABLE_ERROR`** 级别的致命错误。"},{"type":4,"line":"**Warning**"},{"type":4,"line":"不能在 [\\_\\_toString()](language.oop5.magic.html#object.tostring) 方法中抛出异常。这么做会导致致命错误。"},{"type":4,"line":"**Example #2 简单示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// Declare a simple class  "},{"type":4,"line":"class TestClass  "},{"type":5,"line":"{  "},{"type":4,"line":"    public $foo;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct($foo)   "},{"type":5,"line":"    {  "},{"type":5,"line":"        $this->foo = $foo;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __toString() {  "},{"type":5,"line":"        return $this->foo;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$class = new TestClass('Hello');  "},{"type":4,"line":"echo $class;  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Hello"},{"type":4,"line":"需要指出的是在 PHP 5.2.0 之前，[\\_\\_toString()](language.oop5.magic.html#object.tostring) 方法只有在直接使用于 [echo](function.echo.html) 或 [print](function.print.html) 时才能生效。PHP 5.2.0 之后，则可以在任何字符串环境生效（例如通过 [printf()](function.printf.html)，使用 _%s_ 修饰符），但不能用于非字符串环境（如使用 _%d_ 修饰符）。自 PHP 5.2.0 起，如果将一个未定义 [\\_\\_toString()](language.oop5.magic.html#object.tostring) 方法的对象转换为字符串，会产生 **`E_RECOVERABLE_ERROR`** 级别的错误。"},{"type":4,"line":"### [\\_\\_invoke()](language.oop5.magic.html#object.invoke)"},{"type":4,"line":"**\\_\\_invoke** (\\[ `$...` \\] ) : [mixed](language.pseudo-types.html#language.types.mixed)"},{"type":4,"line":"当尝试以调用函数的方式调用一个对象时，[\\_\\_invoke()](language.oop5.magic.html#object.invoke) 方法会被自动调用。"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 本特性只在 PHP 5.3.0 及以上版本有效。"},{"type":4,"line":"**Example #3 使用 [\\_\\_invoke()](language.oop5.magic.html#object.invoke)**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class CallableClass   "},{"type":5,"line":"{  "},{"type":5,"line":"    function __invoke($x) {  "},{"type":5,"line":"        var_dump($x);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"$obj = new CallableClass;  "},{"type":4,"line":"$obj(5);  "},{"type":4,"line":"var_dump(is_callable($obj));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"int(5)"},{"type":4,"line":"bool(true)"},{"type":4,"line":"### [\\_\\_set\\_state()](language.oop5.magic.html#object.set-state)"},{"type":4,"line":"static **\\_\\_set\\_state** ( array `$properties` ) : object"},{"type":4,"line":"自 PHP 5.1.0 起当调用 [var\\_export()](function.var-export.html) 导出类时，此[静态](language.oop5.static.html) 方法会被调用。"},{"type":4,"line":"本方法的唯一参数是一个数组，其中包含按 _array('property' => value, ...)_ 格式排列的类属性。"},{"type":4,"line":"**Example #4 使用 [\\_\\_set\\_state()](language.oop5.magic.html#object.set-state)\\>（PHP 5.1.0 起）**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"class A  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $var1;  "},{"type":4,"line":"    public $var2;  "},{"type":5,"line":"  "},{"type":5,"line":"    public static function __set_state($an_array) // As of PHP 5.1.0  "},{"type":5,"line":"    {  "},{"type":5,"line":"        $obj = new A;  "},{"type":5,"line":"        $obj->var1 = $an_array['var1'];  "},{"type":5,"line":"        $obj->var2 = $an_array['var2'];  "},{"type":5,"line":"        return $obj;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$a = new A;  "},{"type":4,"line":"$a->var1 = 5;  "},{"type":4,"line":"$a->var2 = 'foo';  "},{"type":4,"line":"  "},{"type":5,"line":"eval('$b = ' . var_export($a, true) . ';'); // $b = A::__set_state(array(  "},{"type":5,"line":"                                            //    'var1' => 5,  "},{"type":5,"line":"                                            //    'var2' => 'foo',  "},{"type":4,"line":"                                            // ));  "},{"type":4,"line":"var_dump($b);  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"object(A)#2 (2) {"},{"type":4,"line":"  \\[\"var1\"\\]=>"},{"type":4,"line":"  int(5)"},{"type":4,"line":"  \\[\"var2\"\\]=>"},{"type":4,"line":"  string(3) \"foo\""},{"type":4,"line":"}"},{"type":4,"line":"### [\\_\\_debugInfo()](language.oop5.magic.html#object.debuginfo)"},{"type":4,"line":"**\\_\\_debugInfo** ( void ) : array"},{"type":4,"line":"This method is called by [var\\_dump()](function.var-dump.html) when dumping an object to get the properties that should be shown. If the method isn't defined on an object, then all public, protected and private properties will be shown."},{"type":4,"line":"This feature was added in PHP 5.6.0."},{"type":4,"line":"**Example #5 Using [\\_\\_debugInfo()](language.oop5.magic.html#object.debuginfo)**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class C {  "},{"type":4,"line":"    private $prop;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct($val) {  "},{"type":5,"line":"        $this->prop = $val;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __debugInfo() {  "},{"type":5,"line":"        return [  "},{"type":5,"line":"            'propSquared' => $this->prop ** 2,  "},{"type":5,"line":"        ];  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"var_dump(new C(42));  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"object(C)#1 (1) {"},{"type":4,"line":"  \\[\"propSquared\"\\]=>"},{"type":4,"line":"  int(1764)"},{"type":4,"line":"}"},{"type":3,"line":"9.18 Final 关键字"},{"type":4,"line":"PHP 5 新增了一个 final 关键字。如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。"},{"type":4,"line":"**Example #1 Final 方法示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class BaseClass {  "},{"type":5,"line":"   public function test() {  "},{"type":5,"line":"       echo \"BaseClass::test() called\\n\";  "},{"type":5,"line":"   }  "},{"type":5,"line":"     "},{"type":5,"line":"   final public function moreTesting() {  "},{"type":5,"line":"       echo \"BaseClass::moreTesting() called\\n\";  "},{"type":4,"line":"   }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class ChildClass extends BaseClass {  "},{"type":5,"line":"   public function moreTesting() {  "},{"type":5,"line":"       echo \"ChildClass::moreTesting() called\\n\";  "},{"type":4,"line":"   }  "},{"type":4,"line":"}  "},{"type":4,"line":"// Results in Fatal error: Cannot override final method BaseClass::moreTesting()  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"**Example #2 Final 类示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"final class BaseClass {  "},{"type":5,"line":"   public function test() {  "},{"type":5,"line":"       echo \"BaseClass::test() called\\n\";  "},{"type":5,"line":"   }  "},{"type":5,"line":"     "},{"type":5,"line":"   // 这里无论你是否将方法声明为final，都没有关系  "},{"type":5,"line":"   final public function moreTesting() {  "},{"type":5,"line":"       echo \"BaseClass::moreTesting() called\\n\";  "},{"type":4,"line":"   }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class ChildClass extends BaseClass {  "},{"type":4,"line":"}  "},{"type":4,"line":"// 产生 Fatal error: Class ChildClass may not inherit from final class (BaseClass)  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"> **Note**: 属性不能被定义为 final，只有类和方法才能被定义为 final。"},{"type":3,"line":"9.19 对象复制"},{"type":4,"line":"在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。"},{"type":4,"line":"对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 [\\_\\_clone()](language.oop5.cloning.html#object.clone) 方法）。对象中的 [\\_\\_clone()](language.oop5.cloning.html#object.clone) 方法不能被直接调用。"},{"type":4,"line":"$copy\\_of\\_object = clone $object;"},{"type":4,"line":"当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。"},{"type":4,"line":"**\\_\\_clone** ( void ) : void"},{"type":4,"line":"当复制完成时，如果定义了 [\\_\\_clone()](language.oop5.cloning.html#object.clone) 方法，则新创建的对象（复制生成的对象）中的 [\\_\\_clone()](language.oop5.cloning.html#object.clone) 方法会被调用，可用于修改属性的值（如果有必要的话）。"},{"type":4,"line":"**Example #1 复制一个对象**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"class SubObject  "},{"type":5,"line":"{  "},{"type":5,"line":"    static $instances = 0;  "},{"type":4,"line":"    public $instance;  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __construct() {  "},{"type":5,"line":"        $this->instance = ++self::$instances;  "},{"type":4,"line":"    }  "},{"type":5,"line":"  "},{"type":5,"line":"    public function __clone() {  "},{"type":5,"line":"        $this->instance = ++self::$instances;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class MyCloneable  "},{"type":5,"line":"{  "},{"type":5,"line":"    public $object1;  "},{"type":4,"line":"    public $object2;  "},{"type":5,"line":"  "},{"type":5,"line":"    function __clone()  "},{"type":5,"line":"    {  "},{"type":5,"line":"        "},{"type":5,"line":"        // 强制复制一份this->object， 否则仍然指向同一个对象  "},{"type":5,"line":"        $this->object1 = clone $this->object1;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$obj = new MyCloneable();  "},{"type":4,"line":"  "},{"type":4,"line":"$obj->object1 = new SubObject();  "},{"type":4,"line":"$obj->object2 = new SubObject();  "},{"type":4,"line":"  "},{"type":4,"line":"$obj2 = clone $obj;  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"print(\"Original Object:\\n\");  "},{"type":4,"line":"print_r($obj);  "},{"type":4,"line":"  "},{"type":4,"line":"print(\"Cloned Object:\\n\");  "},{"type":4,"line":"print_r($obj2);  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Original Object:"},{"type":4,"line":"MyCloneable Object"},{"type":5,"line":"("},{"type":5,"line":"    \\[object1\\] => SubObject Object"},{"type":5,"line":"        ("},{"type":5,"line":"            \\[instance\\] => 1"},{"type":4,"line":"        )"},{"type":5,"line":"    \\[object2\\] => SubObject Object"},{"type":5,"line":"        ("},{"type":5,"line":"            \\[instance\\] => 2"},{"type":4,"line":"        )"},{"type":4,"line":")"},{"type":4,"line":"Cloned Object:"},{"type":4,"line":"MyCloneable Object"},{"type":5,"line":"("},{"type":5,"line":"    \\[object1\\] => SubObject Object"},{"type":5,"line":"        ("},{"type":5,"line":"            \\[instance\\] => 3"},{"type":4,"line":"        )"},{"type":5,"line":"    \\[object2\\] => SubObject Object"},{"type":5,"line":"        ("},{"type":5,"line":"            \\[instance\\] => 2"},{"type":4,"line":"        )"},{"type":4,"line":")"},{"type":3,"line":"9.20 对象比较"},{"type":4,"line":"PHP 5 中的对象比较要比 PHP 4 中复杂，所期望的结果更符合一个面向对象语言。"},{"type":4,"line":"当使用比较运算符（_\\==_）比较两个对象变量时，比较的原则是：如果两个对象的属性和属性值 都相等，而且两个对象是同一个类的实例，那么这两个对象变量相等。"},{"type":4,"line":"而如果使用全等运算符（_\\===_），这两个对象变量一定要指向某个类的同一个实例（即同一个对象）。"},{"type":4,"line":"通过下面的示例可以理解以上原则。"},{"type":4,"line":"**Example #1 PHP 5 的对象比较**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"function bool2str($bool)  "},{"type":5,"line":"{  "},{"type":5,"line":"    if ($bool === false) {  "},{"type":5,"line":"        return 'FALSE';  "},{"type":5,"line":"    } else {  "},{"type":5,"line":"        return 'TRUE';  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"function compareObjects(&$o1, &$o2)  "},{"type":5,"line":"{  "},{"type":5,"line":"    echo 'o1 == o2 : ' . bool2str($o1 == $o2) . \"\\n\";  "},{"type":5,"line":"    echo 'o1 != o2 : ' . bool2str($o1 != $o2) . \"\\n\";  "},{"type":5,"line":"    echo 'o1 === o2 : ' . bool2str($o1 === $o2) . \"\\n\";  "},{"type":4,"line":"    echo 'o1 !== o2 : ' . bool2str($o1 !== $o2) . \"\\n\";  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class Flag  "},{"type":5,"line":"{  "},{"type":4,"line":"    public $flag;  "},{"type":5,"line":"  "},{"type":5,"line":"    function Flag($flag = true) {  "},{"type":5,"line":"        $this->flag = $flag;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"class OtherFlag  "},{"type":5,"line":"{  "},{"type":4,"line":"    public $flag;  "},{"type":5,"line":"  "},{"type":5,"line":"    function OtherFlag($flag = true) {  "},{"type":5,"line":"        $this->flag = $flag;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$o = new Flag();  "},{"type":4,"line":"$p = new Flag();  "},{"type":4,"line":"$q = $o;  "},{"type":4,"line":"$r = new OtherFlag();  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"Two instances of the same class\\n\";  "},{"type":4,"line":"compareObjects($o, $p);  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\nTwo references to the same instance\\n\";  "},{"type":4,"line":"compareObjects($o, $q);  "},{"type":4,"line":"  "},{"type":4,"line":"echo \"\\nInstances of two different classes\\n\";  "},{"type":4,"line":"compareObjects($o, $r);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"Two instances of the same class"},{"type":4,"line":"o1 == o2 : TRUE"},{"type":4,"line":"o1 != o2 : FALSE"},{"type":4,"line":"o1 === o2 : FALSE"},{"type":4,"line":"o1 !== o2 : TRUE"},{"type":4,"line":"Two references to the same instance"},{"type":4,"line":"o1 == o2 : TRUE"},{"type":4,"line":"o1 != o2 : FALSE"},{"type":4,"line":"o1 === o2 : TRUE"},{"type":4,"line":"o1 !== o2 : FALSE"},{"type":4,"line":"Instances of two different classes"},{"type":4,"line":"o1 == o2 : FALSE"},{"type":4,"line":"o1 != o2 : TRUE"},{"type":4,"line":"o1 === o2 : FALSE"},{"type":4,"line":"o1 !== o2 : TRUE"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> PHP 扩展中可以自行定义对象比较的原则。"},{"type":3,"line":"9.21 类型约束"},{"type":4,"line":"PHP 5 可以使用类型约束。函数的参数可以指定必须为对象（在函数原型里面指定类的名字），接口，数组（PHP 5.1 起）或者 [callable](language.types.callable.html)（PHP 5.4 起）。不过如果使用 [NULL](language.types.null.html) 作为参数的默认值，那么在调用函数的时候依然可以使用 [NULL](language.types.null.html) 作为实参。"},{"type":4,"line":"如果一个类或接口指定了类型约束，则其所有的子类或实现也都如此。"},{"type":4,"line":"类型约束不能用于标量类型如 [int](language.types.integer.html) 或 [string](language.types.string.html)。[Traits](language.oop5.traits.html) 也不允许。"},{"type":4,"line":"**Example #1 类型约束示例**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"//如下面的类  "},{"type":4,"line":"class MyClass  "},{"type":5,"line":"{  "},{"type":5,"line":"    /**  "},{"type":5,"line":"     * 测试函数  "},{"type":5,"line":"     * 第一个参数必须为 OtherClass 类的一个对象  "},{"type":5,"line":"     */  "},{"type":5,"line":"    public function test(OtherClass $otherclass) {  "},{"type":5,"line":"        echo $otherclass->var;  "},{"type":4,"line":"    }  "},{"type":4,"line":"  "},{"type":5,"line":"  "},{"type":5,"line":"    /**  "},{"type":5,"line":"     * 另一个测试函数  "},{"type":5,"line":"     * 第一个参数必须为数组   "},{"type":5,"line":"     */  "},{"type":5,"line":"    public function test_array(array $input_array) {  "},{"type":5,"line":"        print_r($input_array);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":5,"line":"  "},{"type":5,"line":"    /**  "},{"type":5,"line":"     * 第一个参数必须为递归类型  "},{"type":5,"line":"     */  "},{"type":5,"line":"    public function test_interface(Traversable $iterator) {  "},{"type":5,"line":"        echo get_class($iterator);  "},{"type":5,"line":"    }  "},{"type":5,"line":"      "},{"type":5,"line":"    /**  "},{"type":5,"line":"     * 第一个参数必须为回调类型  "},{"type":5,"line":"     */  "},{"type":5,"line":"    public function test_callable(callable $callback, $data) {  "},{"type":5,"line":"        call_user_func($callback, $data);  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// OtherClass 类定义  "},{"type":5,"line":"class OtherClass {  "},{"type":4,"line":"    public $var = 'Hello World';  "},{"type":4,"line":"}  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"函数调用的参数与定义的参数类型不一致时，会抛出一个可捕获的致命错误。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 两个类的对象  "},{"type":4,"line":"$myclass = new MyClass;  "},{"type":4,"line":"$otherclass = new OtherClass;  "},{"type":4,"line":"  "},{"type":4,"line":"// 致命错误：第一个参数必须是 OtherClass 类的一个对象  "},{"type":4,"line":"$myclass->test('hello');  "},{"type":4,"line":"  "},{"type":4,"line":"// 致命错误：第一个参数必须为 OtherClass 类的一个实例  "},{"type":4,"line":"$foo = new stdClass;  "},{"type":4,"line":"$myclass->test($foo);  "},{"type":4,"line":"  "},{"type":4,"line":"// 致命错误：第一个参数不能为 null  "},{"type":4,"line":"$myclass->test(null);  "},{"type":4,"line":"  "},{"type":4,"line":"// 正确：输出 Hello World   "},{"type":4,"line":"$myclass->test($otherclass);  "},{"type":4,"line":"  "},{"type":4,"line":"// 致命错误：第一个参数必须为数组  "},{"type":4,"line":"$myclass->test_array('a string');  "},{"type":4,"line":"  "},{"type":4,"line":"// 正确：输出数组  "},{"type":4,"line":"$myclass->test_array(array('a', 'b', 'c'));  "},{"type":4,"line":"  "},{"type":4,"line":"// 正确：输出 ArrayObject  "},{"type":4,"line":"$myclass->test_interface(new ArrayObject(array()));  "},{"type":4,"line":"  "},{"type":4,"line":"// 正确：输出 int(1)  "},{"type":4,"line":"$myclass->test_callable('var_dump', 1);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"类型约束不只是用在类的成员函数里，也能使用在函数里："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"// 如下面的类  "},{"type":5,"line":"class MyClass {  "},{"type":4,"line":"    public $var = 'Hello World';  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"/**  "},{"type":4,"line":" * 测试函数  "},{"type":4,"line":" * 第一个参数必须是 MyClass 类的一个对象  "},{"type":4,"line":" */  "},{"type":5,"line":"function MyFunction (MyClass $foo) {  "},{"type":4,"line":"    echo $foo->var;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"// 正确  "},{"type":4,"line":"$myclass = new MyClass;  "},{"type":4,"line":"MyFunction($myclass);  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"类型约束允许 NULL 值："},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"  "},{"type":4,"line":"/* 接受 NULL 值 */  "},{"type":4,"line":"function test(stdClass $obj = NULL) {  "},{"type":4,"line":"  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"test(NULL);  "},{"type":4,"line":"test(new stdClass);  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":3,"line":"9.22 后期静态绑定"},{"type":4,"line":"自 PHP 5.3.0 起，PHP 增加了一个叫做后期静态绑定的功能，用于在继承范围内引用静态调用的类。"},{"type":4,"line":"准确说，后期静态绑定工作原理是存储了在上一个“非转发调用”（non-forwarding call）的类名。当进行静态方法调用时，该类名即为明确指定的那个（通常在 [_::_](language.oop5.paamayim-nekudotayim.html) 运算符左侧部分）；当进行非静态方法调用时，即为该对象所属的类。所谓的“转发调用”（forwarding call）指的是通过以下几种方式进行的静态调用：_self::_，_parent::_，_static::_ 以及 [forward\\_static\\_call()](function.forward-static-call.html)。可用 [get\\_called\\_class()](function.get-called-class.html) 函数来得到被调用的方法所在的类名，_static::_ 则指出了其范围。"},{"type":4,"line":"该功能从语言内部角度考虑被命名为“后期静态绑定”。“后期绑定”的意思是说，_static::_ 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为“静态绑定”，因为它可以用于（但不限于）静态方法的调用。"},{"type":4,"line":"### _self::_ 的限制"},{"type":4,"line":"使用 _self::_ 或者 _\\_\\_CLASS\\_\\__ 对当前类的静态引用，取决于定义当前方法所在的类："},{"type":4,"line":"**Example #1 _self::_ 用法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class A {  "},{"type":5,"line":"    public static function who() {  "},{"type":5,"line":"        echo __CLASS__;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public static function test() {  "},{"type":5,"line":"        self::who();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class B extends A {  "},{"type":5,"line":"    public static function who() {  "},{"type":5,"line":"        echo __CLASS__;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"B::test();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"A"},{"type":4,"line":"### 后期静态绑定的用法"},{"type":4,"line":"后期静态绑定本想通过引入一个新的关键字表示运行时最初调用的类来绕过限制。简单地说，这个关键字能够让你在上述例子中调用 _test()_ 时引用的类是 _B_ 而不是 _A_。最终决定不引入新的关键字，而是使用已经预留的 _static_ 关键字。"},{"type":4,"line":"**Example #2 _static::_ 简单用法**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class A {  "},{"type":5,"line":"    public static function who() {  "},{"type":5,"line":"        echo __CLASS__;  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public static function test() {  "},{"type":5,"line":"        static::who(); // 后期静态绑定从这里开始  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class B extends A {  "},{"type":5,"line":"    public static function who() {  "},{"type":5,"line":"        echo __CLASS__;  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"B::test();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"B"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 在非静态环境下，所调用的类即为该对象实例所属的类。由于 _$this->_ 会在同一作用范围内尝试调用私有方法，而 _static::_ 则可能给出不同结果。另一个区别是 _static::_ 只能用于静态属性。"},{"type":4,"line":"**Example #3 非静态环境下使用 _static::_**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class A {  "},{"type":5,"line":"    private function foo() {  "},{"type":5,"line":"        echo \"success!\\n\";  "},{"type":5,"line":"    }  "},{"type":5,"line":"    public function test() {  "},{"type":5,"line":"        $this->foo();  "},{"type":5,"line":"        static::foo();  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class B extends A {  "},{"type":5,"line":"   /* foo() will be copied to B, hence its scope will still be A and  "},{"type":4,"line":"    * the call be successful */  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":5,"line":"class C extends A {  "},{"type":5,"line":"    private function foo() {  "},{"type":5,"line":"        /* original method is replaced; the scope of the new one is C */  "},{"type":4,"line":"    }  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"$b = new B();  "},{"type":4,"line":"$b->test();  "},{"type":4,"line":"$c = new C();  "},{"type":4,"line":"$c->test();   //fails  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"success!"},{"type":4,"line":"success!"},{"type":4,"line":"success!"},{"type":4,"line":"Fatal error:  Call to private method C::foo() from context 'A' in /tmp/test.php on line 9"},{"type":4,"line":"> **Note**:"},{"type":4,"line":"> "},{"type":4,"line":"> 后期静态绑定的解析会一直到取得一个完全解析了的静态调用为止。另一方面，如果静态调用使用 _parent::_ 或者 _self::_ 将转发调用信息。"},{"type":4,"line":"> "},{"type":4,"line":"> **Example #4 转发和非转发调用**"},{"type":4,"line":"> "},{"type":4,"line":"> "},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":4,"line":"> class A {  "},{"type":4,"line":">     public static function foo() {  "},{"type":4,"line":">         static::who();  "},{"type":4,"line":">     }  "},{"type":4,"line":">   "},{"type":4,"line":">     public static function who() {  "},{"type":4,"line":">         echo __CLASS__.\"\\n\";  "},{"type":4,"line":">     }  "},{"type":4,"line":"> }  "},{"type":4,"line":">   "},{"type":4,"line":"> class B extends A {  "},{"type":4,"line":">     public static function test() {  "},{"type":4,"line":">         A::foo();  "},{"type":4,"line":">         parent::foo();  "},{"type":4,"line":">         self::foo();  "},{"type":4,"line":">     }  "},{"type":4,"line":">   "},{"type":4,"line":">     public static function who() {  "},{"type":4,"line":">         echo __CLASS__.\"\\n\";  "},{"type":4,"line":">     }  "},{"type":4,"line":"> }  "},{"type":4,"line":"> class C extends B {  "},{"type":4,"line":">     public static function who() {  "},{"type":4,"line":">         echo __CLASS__.\"\\n\";  "},{"type":4,"line":">     }  "},{"type":4,"line":"> }  "},{"type":4,"line":">   "},{"type":4,"line":"> C::test();  "},{"type":4,"line":"> ?>"},{"type":4,"line":"```"},{"type":4,"line":"> "},{"type":4,"line":"> 以上例程会输出："},{"type":4,"line":"> "},{"type":4,"line":"> A"},{"type":4,"line":"> C"},{"type":4,"line":"> C"},{"type":3,"line":"9.23 对象和引用"},{"type":4,"line":"在php5 的对象编程经常提到的一个关键点是“默认情况下对象是通过引用传递的”。但其实这不是完全正确的。下面通过一些例子来说明。"},{"type":4,"line":"PHP 的引用是别名，就是两个不同的变量名字指向相同的内容。在 PHP 5，一个对象变量已经不再保存整个对象的值。只是保存一个标识符来访问真正的对象内容。 当对象作为参数传递，作为结果返回，或者赋值给另外一个变量，另外一个变量跟原来的不是引用的关系，只是他们都保存着同一个标识符的拷贝，这个标识符指向同一个对象的真正内容。"},{"type":4,"line":"**Example #1 引用和对象**"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"class A {  "},{"type":4,"line":"    public $foo = 1;  "},{"type":4,"line":"}    "},{"type":4,"line":"  "},{"type":4,"line":"$a = new A;  "},{"type":5,"line":"$b = $a;     // $a ,$b都是同一个标识符的拷贝  "},{"type":4,"line":"             // ($a) = ($b) = <id>  "},{"type":4,"line":"$b->foo = 2;  "},{"type":4,"line":"echo $a->foo.\"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"$c = new A;  "},{"type":5,"line":"$d = &$c;    // $c ,$d是引用  "},{"type":4,"line":"             // ($c,$d) = <id>  "},{"type":4,"line":"  "},{"type":4,"line":"$d->foo = 2;  "},{"type":4,"line":"echo $c->foo.\"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"  "},{"type":4,"line":"$e = new A;  "},{"type":4,"line":"  "},{"type":5,"line":"function foo($obj) {  "},{"type":5,"line":"    // ($obj) = ($e) = <id>  "},{"type":4,"line":"    $obj->foo = 2;  "},{"type":4,"line":"}  "},{"type":4,"line":"  "},{"type":4,"line":"foo($e);  "},{"type":4,"line":"echo $e->foo.\"\\n\";  "},{"type":4,"line":"  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"以上例程会输出："},{"type":4,"line":"2"},{"type":4,"line":"2"},{"type":4,"line":"2"},{"type":3,"line":"9.24 对象序列化"},{"type":3,"line":"序列化对象 - 在会话中存放对象"},{"type":4,"line":"所有php里面的值都可以使用函数[serialize()](function.serialize.html)来返回一个包含字节流的字符串来表示。[unserialize()](function.unserialize.html)函数能够重新把字符串变回php原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。"},{"type":4,"line":"为了能够[unserialize()](function.unserialize.html)一个对象，这个对象的类必须已经定义过。如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。 如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数[spl\\_autoload\\_register()](function.spl-autoload-register.html)来实现。"},{"type":4,"line":"```php"},{"type":4,"line":"<?php  "},{"type":5,"line":"// classa.inc:  "},{"type":4,"line":"    "},{"type":5,"line":"  class A {  "},{"type":5,"line":"      public $one = 1;  "},{"type":5,"line":"      "},{"type":5,"line":"      public function show_one() {  "},{"type":5,"line":"          echo $this->one;  "},{"type":4,"line":"      }  "},{"type":5,"line":"  }  "},{"type":4,"line":"    "},{"type":4,"line":"// page1.php:  "},{"type":4,"line":"  "},{"type":5,"line":"  include(\"classa.inc\");  "},{"type":4,"line":"    "},{"type":4,"line":"  $a = new A;  "},{"type":4,"line":"  $s = serialize($a);  "},{"type":4,"line":"  // 把变量$s保存起来以便文件page2.php能够读到  "},{"type":4,"line":"  file_put_contents('store', $s);  "},{"type":4,"line":"  "},{"type":5,"line":"// page2.php:  "},{"type":4,"line":"    "},{"type":4,"line":"  // 要正确了解序列化，必须包含下面一个文件  "},{"type":4,"line":"  include(\"classa.inc\");  "},{"type":4,"line":"  "},{"type":4,"line":"  $s = file_get_contents('store');  "},{"type":4,"line":"  $a = unserialize($s);  "},{"type":4,"line":"  "},{"type":4,"line":"  // 现在可以使用对象$a里面的函数 show_one()  "},{"type":4,"line":"  $a->show_one();  "},{"type":4,"line":"?>"},{"type":4,"line":"```"},{"type":4,"line":"当一个应用程序使用函数[session\\_register()](function.session-register.html)来保存对象到会话中时，在每个页面结束的时候这些对象都会自动序列化，而在每个页面开始的时候又自动解序列化。 所以一旦对象被保存在会话中，整个应用程序的页面都能使用这些对象。但是，[session\\_register()](function.session-register.html)在php5.4.0之后被移除了。"},{"type":4,"line":"在应用程序中序列化对象以便在之后使用，强烈推荐在整个应用程序都包含对象的类的定义。 不然有可能出现在解序列化对象的时候，没有找到该对象的类的定义，从而把没有方法的类**\\_\\_PHP\\_Incomplete\\_Class\\_Name**作为该对象的类，导致返回一个没有用的对象。"},{"type":4,"line":"所以在上面的例子中，当运行_session\\_register(\"a\")_，把变量$a放在会话里之后，需要在每个页面都包含文件_classa.inc_，而不是只有文件page1.php和page2.php。"},{"type":4,"line":"除了以上建议，可以在对象上使用 [\\_\\_sleep()](language.oop5.magic.html#object.sleep) 和 [\\_\\_wakeup()](language.oop5.magic.html#object.wakeup) 方法对序列化/反序列化事件挂载钩子。 使用 [\\_\\_sleep()](language.oop5.magic.html#object.sleep) 也能够让仅仅序列化对象的某些属性。"},{"type":3,"line":"9.25 OOP 变更日志"},{"type":4,"line":"PHP 5 OOP 模型的变更将被记录在此。功能的描述与其他相关注意事项记录在了 OOP 5 文档之中。"},{"type":4,"line":"版本"},{"type":4,"line":"说明"},{"type":4,"line":"7.0.0"},{"type":4,"line":"Trait 里定义兼容的属性不再产生错误信息。"},{"type":4,"line":"5.6.0"},{"type":4,"line":"增加: [\\_\\_debugInfo()](language.oop5.magic.html#object.debuginfo) 方法。"},{"type":4,"line":"5.5.0"},{"type":4,"line":"增加: [::class](language.oop5.basic.html#language.oop5.basic.class.class) 魔法常量。"},{"type":4,"line":"5.5.0"},{"type":4,"line":"增加: [finally](language.exceptions.html) 来处理异常。"},{"type":4,"line":"5.4.0"},{"type":4,"line":"增加： [traits](language.oop5.traits.html)。"},{"type":4,"line":"5.4.0"},{"type":4,"line":"已变更：如果一个[抽象](language.oop5.abstract.html) 类定义了构造函数的签名，它将必须被实现。"},{"type":4,"line":"5.3.3"},{"type":4,"line":"已变更： [命名空间](language.namespaces.html) 中和类同名的方法不再被作为 [构造函数](language.oop5.decon.html)。这个变更不影响非命名空间中的类。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"已变更：类实现接口的方法所具有的默认值不再需要和接口的默认值一致。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"已变更： 现在它也能够通过一个变量来引用一个类（例如，_echo $classname::constant;_）。 这个变量的值不能是一个保留关键词（比如，_self_、_parent_ 或 _static_）。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"已变更： 如果[重载](language.oop5.overloading.html)方法被定义为 [static](language.oop5.static.html) 将导致一个 **`E_WARNING`** 级别的错误。 同时它也需要强制使用 public 的可见性。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"已变更： 在 5.3.0 之前的版本，[\\_\\_autoload()](function.autoload.html) 函数里抛出的异常不能被 [catch](language.exceptions.html) 块结构捕获，并会导致一个致命错误。 现在在一个前提下 [catch](language.exceptions.html) 块能够捕获 \\_\\_autoload 函数中抛出的错误。如果抛出一个自定义异常，这个自定义异常的类必须是可用的。否则 \\_\\_autoload 函数可能递归自动加载这个自定义异常类。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"新增： [\\_\\_callStatic](language.oop5.overloading.html) 方法。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"新增： [heredoc](language.types.string.html#language.types.string.syntax.heredoc) 和 [nowdoc](language.types.string.html#language.types.string.syntax.heredoc) 支持类的 _常量_ 和属性的定义。 注意：heredoc 值必须和双引号字符串遵循同样的规则（比如，变量将被替换）。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"新增： [后期静态绑定](language.oop5.late-static-bindings.html)。"},{"type":4,"line":"5.3.0"},{"type":4,"line":"新增： [\\_\\_invoke](language.oop5.magic.html#object.invoke) 方法。"},{"type":4,"line":"5.2.0"},{"type":4,"line":"已变更：[\\_\\_toString](language.oop5.magic.html#object.tostring) 方法仅在直接与 [echo](function.echo.html) 或 [print](function.print.html) 使用时被调用。但是现在它能在任何字符串上下文被调用（比如在 [printf()](function.printf.html) 中使用 _%s_ ），但不是在其他类型的上下文被调用（例如 _%d_ 修饰符）。 自 PHP 5.2.0 起，将不具有 _\\_\\_toString_ 方法的对象转化为字符串将导致一个 **`E_RECOVERABLE_ERROR`** 级别的错误。"},{"type":4,"line":"5.1.3"},{"type":4,"line":"已变更：在 PHP 5 之前的版本，_var_ 的使用已被废弃，并将产生一个 **`E_STRICT`** 级别的错误。现在它不再被废弃，因此也不会产生错误。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"已变更：现在 [\\_\\_set\\_state](language.oop5.magic.html#object.set-state) 静态方法在 [var\\_export()](function.var-export.html) 导出类时会被调用。"},{"type":4,"line":"5.1.0"},{"type":4,"line":"新增：[\\_\\_isset](language.oop5.overloading.html#object.isset) 和 [\\_\\_unset](language.oop5.overloading.html#object.unset) 方法。"}]