<h1 id="6_">6. 运算符</h1>
<h3 id="6_1">6.1 运算符优先级</h3>
<p>运算符优先级指定了两个表达式绑定得有多"紧密".例如,表达式 <em>1 + 5 * 3</em> 的结果是 <em>16</em> 而不是 <em>18</em> 是因为乘号("*")的优先级比加号("+")高.必要时可以用括号来强制改变优先级.例如:<em>(1 + 5) * 3</em> 的值为 <em>18</em>.</p>
<p>如果运算符优先级相同,那运算符的结合方向决定了该如何运算.例如,"-"是左联的,那么 <em>1 - 2 - 3</em> 就等同于 <em>(1 - 2) - 3</em> 并且结果是 <em>-4</em>. 另外一方面,"="是右联的,所以 <em>$a = $b = $c</em> 等同于 <em>$a = ($b = $c)</em>.</p>
<p>没有结合的相同优先级的运算符不能连在一起使用,例如 <em>1 < 2 > 1</em> 在PHP是不合法的.但另外一方面表达式 <em>1 <= 1 == 1</em> 是合法的, 因为 <em>==</em> 的优先级低于 <em><=</em>.</p>
<p>括号的使用,哪怕在不是必要的场合下,通过括号的配对来明确标明运算顺序,而非靠运算符优先级和结合性来决定,通常能够增加代码的可读性.</p>
<p>下表按照优先级从高到低列出了运算符.同一行中的运算符具有相同优先级,此时它们的结合方向决定求值顺序.</p>
<p><strong>运算符优先级</strong></p>
<p>结合方向</p>
<p>运算符</p>
<p>附加信息</p>
<p>无</p>
<p>clone new</p>
<p><a href="language.oop5.cloning.html">clone</a> 和 <a href="language.oop5.basic.html#language.oop5.basic.new">new</a></p>
<p>左</p>
<p><em>[</em></p>
<p><a href="function.array.html">array()</a></p>
<p>右</p>
<p><em>**</em></p>
<p><a href="language.operators.arithmetic.html">算术运算符</a></p>
<p>右</p>
<p><em>++</em> <em>--</em> <em>~</em> <em>(int)</em> <em>(float)</em> <em>(string)</em> <em>(array)</em> <em>(object)</em> <em>(bool)</em> <em>@</em></p>
<p><a href="language.types.html">类型</a>和<a href="language.operators.increment.html">递增/递减</a></p>
<p>无</p>
<p><em>instanceof</em></p>
<p><a href="language.types.html">类型</a></p>
<p>右</p>
<p><em>!</em></p>
<p><a href="language.operators.logical.html">逻辑运算符</a></p>
<p>左</p>
<p><em>*</em> <em>/</em> <em>%</em></p>
<p><a href="language.operators.arithmetic.html">算术运算符</a></p>
<p>左</p>
<p><em>+</em> <em>-</em> <em>.</em></p>
<p><a href="language.operators.arithmetic.html">算术运算符</a>和<a href="language.operators.string.html">字符串运算符</a></p>
<p>左</p>
<p><em><<_ _\>></em></p>
<p><a href="language.operators.bitwise.html">位运算符</a></p>
<p>无</p>
<p><em><_ _<=_ _\></em> <em>>=</em></p>
<p><a href="language.operators.comparison.html">比较运算符</a></p>
<p>无</p>
<p><em>==</em> <em>!=</em> <em>===</em> <em>!==</em> <em><></em> <em><=></em></p>
<p><a href="language.operators.comparison.html">比较运算符</a></p>
<p>左</p>
<p><em>&</em></p>
<p><a href="language.operators.bitwise.html">位运算符</a>和<a href="language.references.html">引用</a></p>
<p>左</p>
<p><em>^</em></p>
<p><a href="language.operators.bitwise.html">位运算符</a></p>
<p>左</p>
<p><em>|</em></p>
<p><a href="language.operators.bitwise.html">位运算符</a></p>
<p>左</p>
<p><em>&&</em></p>
<p><a href="language.operators.logical.html">逻辑运算符</a></p>
<p>左</p>
<p><em>||</em></p>
<p><a href="language.operators.logical.html">逻辑运算符</a></p>
<p>左</p>
<p><em>??</em></p>
<p><a href="language.operators.comparison.html">比较运算符</a></p>
<p>左</p>
<p><em>? :</em></p>
<p><a href="language.operators.comparison.html#language.operators.comparison.ternary">ternary</a></p>
<p>right</p>
<p><em>=</em> <em>+=</em> <em>-=</em> <em>*=</em> <em>**=</em> <em>/=</em> <em>.=</em> <em>%=</em> <em>&=</em> <em>|=</em> <em>^=</em> <em><<=</em> <em>>>=</em></p>
<p><a href="language.operators.assignment.html">赋值运算符</a></p>
<p>左</p>
<p><em>and</em></p>
<p><a href="language.operators.logical.html">逻辑运算符</a></p>
<p>左</p>
<p><em>xor</em></p>
<p><a href="language.operators.logical.html">逻辑运算符</a></p>
<p>左</p>
<p><em>or</em></p>
<p><a href="language.operators.logical.html">逻辑运算符</a></p>
<p><strong>Example #1 结合方向</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = 3 * 3 % 5; // (3 * 3) % 5 = 4  
// ternary operator associativity differs from C/C++  
$a = true ? 0 : true ? 1 : 2; // (true ? 0 : true) ? 1 : 2 = 2  

$a = 1;  
$b = 2;  
$a = $b += 3; // $a = ($b += 3) -&gt; $a = 5, $b = 5  
?&gt;
</code></pre>
<p>Operator precedence and associativity only determine how expressions are grouped, they do not specify an order of evaluation. PHP does not (in the general case) specify in which order an expression is evaluated and code that assumes a specific order of evaluation should be avoided, because the behavior can change between versions of PHP or depending on the surrounding code.</p>
<p><strong>Example #2 Undefined order of evaluation</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = 1;  
echo $a + $a++; // may print either 2 or 3  

$i = 1;  
$array[$i] = $i++; // may set either index 1 or 2  
?&gt;
</code></pre>
<blockquote>
  <p><strong>Note</strong>:</p>
  <p>尽管 <em>=</em> 比其它大多数的运算符的优先级低,PHP 仍旧允许类似如下的表达式:<em>if (!$a = foo())</em>,在此例中 <em>foo()</em> 的返回值被赋给了 $a.</p>
</blockquote>
<h3 id="6_2">6.2 算术运算符</h3>
<p>还记得学校里学到的基本数学知识吗?就和它们一样.</p>
<p><strong>算术运算符</strong></p>
<p>例子</p>
<p>名称</p>
<p>结果</p>
<p>-$a</p>
<p>取反</p>
<p>$a 的负值.</p>
<p>$a + $b</p>
<p>加法</p>
<p>$a 和 $b 的和.</p>
<p>$a - $b</p>
<p>减法</p>
<p>$a 和 $b 的差.</p>
<p>$a * $b</p>
<p>乘法</p>
<p>$a 和 $b 的积.</p>
<p>$a / $b</p>
<p>除法</p>
<p>$a 除以 $b 的商.</p>
<p>$a % $b</p>
<p>取模</p>
<p>$a 除以 $b 的余数.</p>
<p>$a ** $b</p>
<p>Exponentiation</p>
<p>Result of raising $a to the $b'th power. Introduced in PHP 5.6.</p>
<p>除法运算符总是返回浮点数.只有在下列情况例外:两个操作数都是整数(或字符串转换成的整数)并且正好能整除,这时它返回一个整数.</p>
<p>取模运算符的操作数在运算之前都会转换成整数(除去小数部分).</p>
<p>取模运算符 <em>%</em> 的结果和被除数的符号(正负号)相同.即 <em>$a % $b</em> 的结果和 $a 的符号相同.例如:</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  

echo (5 % 3)."\n";           // prints 2  
echo (5 % -3)."\n";          // prints 2  
echo (-5 % 3)."\n";          // prints -2  
echo (-5 % -3)."\n";         // prints -2  

?&gt;
</code></pre>
<p>参见手册中的<a href="ref.math.html">数学函数</a>.</p>
<h3 id="6_3">6.3 赋值运算符</h3>
<p>基本的赋值运算符是"=".一开始可能会以为它是"等于",其实不是的.它实际上意味着把右边表达式的值赋给左边的运算数.</p>
<p>赋值运算表达式的值也就是所赋的值.也就是说,"<em>$a = 3</em>"的值是 3.这样就可以做一些小技巧:</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  

$a = ($b = 4) + 5; // $a 现在成了 9,而 $b 成了 4.  

?&gt;
</code></pre>
<p>在基本赋值运算符之外,还有适合于所有<a href="language.operators.html">二元算术</a>,数组集合和字符串运算符的"组合运算符",这样可以在一个表达式中使用它的值并把表达式的结果赋给它,例如:</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  

$a = 3;  
$a += 5; // sets $a to 8, as if we had said: $a = $a + 5;  
$b = "Hello ";  
$b .= "There!"; // sets $b to "Hello There!", just like $b = $b . "There!";  

?&gt;
</code></pre>
<p>注意赋值运算将原变量的值拷贝到新变量中(传值赋值),所以改变其中一个并不影响另一个.这也适合于在密集循环中拷贝一些值例如大数组.</p>
<p>在 PHP 中普通的传值赋值行为有个例外就是碰到对象 <a href="language.types.object.html">object</a> 时,在 PHP 5 中是以引用赋值的,除非明确使用了 <a href="language.oop5.cloning.html">clone</a> 关键字来拷贝.</p>
<h3 id="">引用赋值</h3>
<p>PHP 支持引用赋值,使用"$var = &amp;$othervar;"语法.引用赋值意味着两个变量指向了同一个数据,没有拷贝任何东西.</p>
<p><strong>Example #1 引用赋值</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = 3;  
$b = &amp;$a; // $b 是 $a 的引用  

print "$a\n"; // 输出 3  
print "$b\n"; // 输出 3  

$a = 4; // 修改 $a  

print "$a\n"; // 输出 4  
print "$b\n"; // 也输出 4,因为 $b 是 $a 的引用,因此也被改变  
?&gt;
</code></pre>
<p>自 PHP 5 起,<a href="language.oop5.basic.html#language.oop5.basic.new">new</a> 运算符自动返回一个引用,因此再对 <a href="language.oop5.basic.html#language.oop5.basic.new">new</a> 的结果进行引用赋值在 PHP 5.3 以及以后版本中会发出一条 <strong><code>E_DEPRECATED</code></strong> 错误信息,在之前版本会发出一条 <strong><code>E_STRICT</code></strong> 错误信息.</p>
<p>例如以下代码将产生警告:</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
class C {}  

/* The following line generates the following error message:  
 * Deprecated: Assigning the return value of new by reference is deprecated in...  
 */  
$o = &amp;new C;  
?&gt;
</code></pre>
<p>有关引用更多信息参见本手册中<a href="language.references.html">引用的解释</a>一章.</p>
<h3 id="6_4">6.4 位运算符</h3>
<p>位运算符允许对整型数中指定的位进行求值和操作.</p>
<p><strong>位运算符</strong></p>
<p>例子</p>
<p>名称</p>
<p>结果</p>
<p><strong><code>$a &amp; $b</code></strong></p>
<p>And(按位与)</p>
<p>将把 $a 和 $b 中都为 1 的位设为 1.</p>
<p><strong><code>$a | $b</code></strong></p>
<p>Or(按位或)</p>
<p>将把 $a 和 $b 中任何一个为 1 的位设为 1.</p>
<p><strong><code>$a ^ $b</code></strong></p>
<p>Xor(按位异或)</p>
<p>将把 $a 和 $b 中一个为 1 另一个为 0 的位设为 1.</p>
<p><strong><code>~ $a</code></strong></p>
<p>Not(按位取反)</p>
<p>将 $a 中为 0 的位设为 1,反之亦然.</p>
<p><strong><code>$a &lt;&lt; $b</code></strong></p>
<p>Shift left(左移)</p>
<p>将 $a 中的位向左移动 $b 次(每一次移动都表示"乘以 2").</p>
<p><strong><code>$a &gt;&gt; $b</code></strong></p>
<p>Shift right(右移)</p>
<p>将 $a 中的位向右移动 $b 次(每一次移动都表示"除以 2").</p>
<p>位移在 PHP 中是数学运算.向任何方向移出去的位都被丢弃.左移时右侧以零填充,符号位被移走意味着正负号不被保留.右移时左侧以符号位填充,意味着正负号被保留.</p>
<p>要用括号确保想要的<a href="language.operators.precedence.html">优先级</a>.例如 <em>$a & $b == true</em> 先进行比较再进行按位与;而 <em>($a & $b) == true</em> 则先进行按位与再进行比较.</p>
<p>If both operands for the <em>&</em>, <em>|</em> and <em>^</em> operators are strings, then the operation will be performed on the ASCII values of the characters that make up the strings and the result will be a string. In all other cases, both operands will be <a href="language.types.integer.html#language.types.integer.casting">converted to integers</a> and the result will be an integer.</p>
<p>If the operand for the <em>~</em> operator is a string, the operation will be performed on the ASCII values of the characters that make up the string and the result will be a string, otherwise the operand and the result will be treated as integers.</p>
<p>Both operands and the result for the <em><<_ and _\>></em> operators are always treated as integers.</p>
<p>PHP 的 ini 设定 error_reporting 使用了按位的值,
提供了关闭某个位的真实例子.要显示除了提示级别
之外的所有错误,php.ini 中是这样用的:
<strong><code>E_ALL &amp; ~E_NOTICE</code></strong></p>
<p>具体运作方式是先取得 E_ALL 的值:
00000000000000000111011111111111
再取得 E_NOTICE 的值:
00000000000000000000000000001000
然后通过 <em>~</em> 将其取反:
11111111111111111111111111110111
最后再用按位与 AND(&amp;)得到两个值中都设定了(为 1)的位:
00000000000000000111011111110111</p>
<p>另外一个方法是用按位异或 XOR(<em>^</em>)来取得只在
其中一个值中设定了的位:
<strong><code>E_ALL ^ E_NOTICE</code></strong></p>
<p>error_reporting 也可用来演示怎样置位.只显示错误和可恢复
错误的方法是:
<strong><code>E_ERROR | E_RECOVERABLE_ERROR</code></strong></p>
<p>也就是将 E_ERROR
00000000000000000000000000000001
和 E_RECOVERABLE_ERROR
00000000000000000001000000000000
用按位或 OR(<em>|</em>)运算符来取得在任何一个值中被置位的结果:
00000000000000000001000000000001</p>
<p><strong>Example #1 整数的 AND,OR 和 XOR 位运算符</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
/*  
 * Ignore the top section,  
 * it is just formatting to make output clearer.  
 */  

$format = '(%1$2d = %1$04b) = (%2$2d = %2$04b)'  
        . ' %3$s (%4$2d = %4$04b)' . "\n";  

echo &lt;&lt;&lt;EOH  
 ---------     ---------  -- ---------  
 result        value      op test  
 ---------     ---------  -- ---------  
EOH;  


/*  
 * Here are the examples.  
 */  

$values = array(0, 1, 2, 4, 8);  
$test = 1 + 4;  

echo "\n Bitwise AND \n";  
foreach ($values as $value) {  
    $result = $value &amp; $test;  
    printf($format, $result, $value, '&amp;', $test);  
}  

echo "\n Bitwise Inclusive OR \n";  
foreach ($values as $value) {  
    $result = $value | $test;  
    printf($format, $result, $value, '|', $test);  
}  

echo "\n Bitwise Exclusive OR (XOR) \n";  
foreach ($values as $value) {  
    $result = $value ^ $test;  
    printf($format, $result, $value, '^', $test);  
}  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>---------     ---------  -- ---------
 result        value      op test
 ---------     ---------  -- ---------
 Bitwise AND
( 0 = 0000) = ( 0 = 0000) &amp; ( 5 = 0101)
( 1 = 0001) = ( 1 = 0001) &amp; ( 5 = 0101)
( 0 = 0000) = ( 2 = 0010) &amp; ( 5 = 0101)
( 4 = 0100) = ( 4 = 0100) &amp; ( 5 = 0101)
( 0 = 0000) = ( 8 = 1000) &amp; ( 5 = 0101)</p>
<p>Bitwise Inclusive OR
( 5 = 0101) = ( 0 = 0000) | ( 5 = 0101)
( 5 = 0101) = ( 1 = 0001) | ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) | ( 5 = 0101)
( 5 = 0101) = ( 4 = 0100) | ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) | ( 5 = 0101)</p>
<p>Bitwise Exclusive OR (XOR)
( 5 = 0101) = ( 0 = 0000) ^ ( 5 = 0101)
( 4 = 0100) = ( 1 = 0001) ^ ( 5 = 0101)
( 7 = 0111) = ( 2 = 0010) ^ ( 5 = 0101)
( 1 = 0001) = ( 4 = 0100) ^ ( 5 = 0101)
(13 = 1101) = ( 8 = 1000) ^ ( 5 = 0101)</p>
<p><strong>Example #2 字符串的 XOR 运算符</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
echo 12 ^ 9; // Outputs '5'  

echo "12" ^ "9"; // Outputs the Backspace character (ascii 8)  
                 // ('1' (ascii 49)) ^ ('9' (ascii 57)) = #8  

echo "hallo" ^ "hello"; // Outputs the ascii values #0 #4 #0 #0 #0  
                        // 'a' ^ 'e' = #4  

echo 2 ^ "3"; // Outputs 1  
              // 2 ^ ((int)"3") == 1  

echo "2" ^ 3; // Outputs 1  
              // ((int)"2") ^ 3 == 1  
?&gt;
</code></pre>
<p><strong>Example #3 整数的位移</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
/*  
 * Here are the examples.  
 */  

echo "\n--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---\n";  

$val = 4;  
$places = 1;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places, 'copy of sign bit shifted into left side');  

$val = 4;  
$places = 2;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places);  

$val = 4;  
$places = 3;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places, 'bits shift out right side');  

$val = 4;  
$places = 4;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places, 'same result as above; can not shift beyond 0');  


echo "\n--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---\n";  

$val = -4;  
$places = 1;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places, 'copy of sign bit shifted into left side');  

$val = -4;  
$places = 2;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places, 'bits shift out right side');  

$val = -4;  
$places = 3;  
$res = $val &gt;&gt; $places;  
p($res, $val, '&gt;&gt;', $places, 'same result as above; can not shift beyond -1');  


echo "\n--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---\n";  

$val = 4;  
$places = 1;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places, 'zeros fill in right side');  

$val = 4;  
$places = (PHP_INT_SIZE * 8) - 4;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places);  

$val = 4;  
$places = (PHP_INT_SIZE * 8) - 3;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places, 'sign bits get shifted out');  

$val = 4;  
$places = (PHP_INT_SIZE * 8) - 2;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places, 'bits shift out left side');  


echo "\n--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---\n";  

$val = -4;  
$places = 1;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places, 'zeros fill in right side');  

$val = -4;  
$places = (PHP_INT_SIZE * 8) - 3;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places);  

$val = -4;  
$places = (PHP_INT_SIZE * 8) - 2;  
$res = $val &lt;&lt; $places;  
p($res, $val, '&lt;&lt;', $places, 'bits shift out left side, including sign bit');  


/*  
 * Ignore this bottom section,  
 * it is just formatting to make output clearer.  
 */  

function p($res, $val, $op, $places, $note = '') {  
    $format = '%0' . (PHP_INT_SIZE * 8) . "b\n";  

    printf("Expression: %d = %d %s %d\n", $res, $val, $op, $places);  

    echo " Decimal:\n";  
    printf("  val=%d\n", $val);  
    printf("  res=%d\n", $res);  

    echo " Binary:\n";  
    printf('  val=' . $format, $val);  
    printf('  res=' . $format, $res);  

    if ($note) {  
        echo " NOTE: $note\n";  
    }  

    echo "\n";  
}  
?&gt;
</code></pre>
<p>以上例程在 32 位机器上的输出:</p>
<p>--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 &gt;&gt; 1
 Decimal:
  val=4
  res=2
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side</p>
<p>Expression: 1 = 4 &gt;&gt; 2
 Decimal:
  val=4
  res=1
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000001</p>
<p>Expression: 0 = 4 &gt;&gt; 3
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out right side</p>
<p>Expression: 0 = 4 &gt;&gt; 4
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0</p>
<p>--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 &gt;&gt; 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side</p>
<p>Expression: -1 = -4 &gt;&gt; 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: bits shift out right side</p>
<p>Expression: -1 = -4 &gt;&gt; 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1</p>
<p>--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 &lt;&lt; 1
 Decimal:
  val=4
  res=8
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000001000
 NOTE: zeros fill in right side</p>
<p>Expression: 1073741824 = 4 &lt;&lt; 28
 Decimal:
  val=4
  res=1073741824
 Binary:
  val=00000000000000000000000000000100
  res=01000000000000000000000000000000</p>
<p>Expression: -2147483648 = 4 &lt;&lt; 29
 Decimal:
  val=4
  res=-2147483648
 Binary:
  val=00000000000000000000000000000100
  res=10000000000000000000000000000000
 NOTE: sign bits get shifted out</p>
<p>Expression: 0 = 4 &lt;&lt; 30
 Decimal:
  val=4
  res=0
 Binary:
  val=00000000000000000000000000000100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side</p>
<p>--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 &lt;&lt; 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=11111111111111111111111111111100
  res=11111111111111111111111111111000
 NOTE: zeros fill in right side</p>
<p>Expression: -2147483648 = -4 &lt;&lt; 29
 Decimal:
  val=-4
  res=-2147483648
 Binary:
  val=11111111111111111111111111111100
  res=10000000000000000000000000000000</p>
<p>Expression: 0 = -4 &lt;&lt; 30
 Decimal:
  val=-4
  res=0
 Binary:
  val=11111111111111111111111111111100
  res=00000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit</p>
<p>以上例程在 64 位机器上的输出:</p>
<p>--- BIT SHIFT RIGHT ON POSITIVE INTEGERS ---
Expression: 2 = 4 &gt;&gt; 1
 Decimal:
  val=4
  res=2
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000010
 NOTE: copy of sign bit shifted into left side</p>
<p>Expression: 1 = 4 &gt;&gt; 2
 Decimal:
  val=4
  res=1
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000001</p>
<p>Expression: 0 = 4 &gt;&gt; 3
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out right side</p>
<p>Expression: 0 = 4 &gt;&gt; 4
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: same result as above; can not shift beyond 0</p>
<p>--- BIT SHIFT RIGHT ON NEGATIVE INTEGERS ---
Expression: -2 = -4 &gt;&gt; 1
 Decimal:
  val=-4
  res=-2
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111110
 NOTE: copy of sign bit shifted into left side</p>
<p>Expression: -1 = -4 &gt;&gt; 2
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: bits shift out right side</p>
<p>Expression: -1 = -4 &gt;&gt; 3
 Decimal:
  val=-4
  res=-1
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111111
 NOTE: same result as above; can not shift beyond -1</p>
<p>--- BIT SHIFT LEFT ON POSITIVE INTEGERS ---
Expression: 8 = 4 &lt;&lt; 1
 Decimal:
  val=4
  res=8
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000001000
 NOTE: zeros fill in right side</p>
<p>Expression: 4611686018427387904 = 4 &lt;&lt; 60
 Decimal:
  val=4
  res=4611686018427387904
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0100000000000000000000000000000000000000000000000000000000000000</p>
<p>Expression: -9223372036854775808 = 4 &lt;&lt; 61
 Decimal:
  val=4
  res=-9223372036854775808
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=1000000000000000000000000000000000000000000000000000000000000000
 NOTE: sign bits get shifted out</p>
<p>Expression: 0 = 4 &lt;&lt; 62
 Decimal:
  val=4
  res=0
 Binary:
  val=0000000000000000000000000000000000000000000000000000000000000100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side</p>
<p>--- BIT SHIFT LEFT ON NEGATIVE INTEGERS ---
Expression: -8 = -4 &lt;&lt; 1
 Decimal:
  val=-4
  res=-8
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1111111111111111111111111111111111111111111111111111111111111000
 NOTE: zeros fill in right side</p>
<p>Expression: -9223372036854775808 = -4 &lt;&lt; 61
 Decimal:
  val=-4
  res=-9223372036854775808
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=1000000000000000000000000000000000000000000000000000000000000000</p>
<p>Expression: 0 = -4 &lt;&lt; 62
 Decimal:
  val=-4
  res=0
 Binary:
  val=1111111111111111111111111111111111111111111111111111111111111100
  res=0000000000000000000000000000000000000000000000000000000000000000
 NOTE: bits shift out left side, including sign bit</p>
<p><strong>Warning</strong></p>
<p>Shifting integers by values greater than or equal to the system long integer width results in undefined behavior. In other words, don't shift more than 31 bits on a 32-bit system, and don't shift more than 63 bits on a 64-bit system.</p>
<p>使用 <a href="book.gmp.html">gmp</a> 扩展对超出 <em>PHP_INT_MAX</em> 的数值来进行位操作.</p>
<p>参见 <a href="function.pack.html">pack()</a>, <a href="function.unpack.html">unpack()</a>, <a href="function.gmp-and.html">gmp_and()</a>, <a href="function.gmp-or.html">gmp_or()</a>, <a href="function.gmp-xor.html">gmp_xor()</a>, <a href="function.gmp-testbit.html">gmp_testbit()</a>, <a href="function.gmp-clrbit.html">gmp_clrbit()</a></p>
<h3 id="6_5">6.5 比较运算符</h3>
<p>比较运算符,如同它们名称所暗示的,允许对两个值进行比较.还可以参考 <a href="types.comparisons.html">PHP 类型比较表</a>看不同类型相互比较的例子.</p>
<p><strong>比较运算符</strong></p>
<p>例子</p>
<p>名称</p>
<p>结果</p>
<p>$a == $b</p>
<p>等于</p>
<p><strong><code>TRUE</code></strong>,如果类型转换后 $a 等于 $b.</p>
<p>$a === $b</p>
<p>全等</p>
<p><strong><code>TRUE</code></strong>,如果 $a 等于 $b,并且它们的类型也相同.</p>
<p>$a != $b</p>
<p>不等</p>
<p><strong><code>TRUE</code></strong>,如果类型转换后 $a 不等于 $b.</p>
<p>$a &lt;&gt; $b</p>
<p>不等</p>
<p><strong><code>TRUE</code></strong>,如果类型转换后 $a 不等于 $b.</p>
<p>$a !== $b</p>
<p>不全等</p>
<p><strong><code>TRUE</code></strong>,如果 $a 不等于 $b,或者它们的类型不同.</p>
<p>$a &lt; $b</p>
<p>小与</p>
<p><strong><code>TRUE</code></strong>,如果 $a 严格小于 $b.</p>
<p>$a &gt; $b</p>
<p>大于</p>
<p><strong><code>TRUE</code></strong>,如果 $a 严格大于 $b.</p>
<p>$a &lt;= $b</p>
<p>小于等于</p>
<p><strong><code>TRUE</code></strong>,如果 $a 小于或者等于 $b.</p>
<p>$a &gt;= $b</p>
<p>大于等于</p>
<p><strong><code>TRUE</code></strong>,如果 $a 大于或者等于 $b.</p>
<p>$a <=> $b</p>
<p>太空船运算符(组合比较符)</p>
<p>当$a小于,等于,大于$b时 分别返回一个小于,等于,大于0的<a href="language.types.integer.html">integer</a> 值. PHP7开始提供.</p>
<p>$a ?? $b ?? $c</p>
<p>NULL 合并操作符</p>
<p>从左往右第一个存在且不为 <strong><code>NULL</code></strong> 的操作数.如果都没有定义且不为 <strong><code>NULL</code></strong>,则返回 <strong><code>NULL</code></strong>.PHP7开始提供.</p>
<p>如果比较一个数字和字符串或者比较涉及到数字内容的字符串,则字符串会被<a href="language.types.string.html#language.types.string.conversion">转换为数值</a>并且比较按照数值来进行.此规则也适用于 <a href="control-structures.switch.html">switch</a> 语句.当用 === 或 !== 进行比较时则不进行类型转换,因为此时类型和数值都要比对.</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
var_dump(0 == "a"); // 0 == 0 -&gt; true  
var_dump("1" == "01"); // 1 == 1 -&gt; true  
var_dump("10" == "1e1"); // 10 == 10 -&gt; true  
var_dump(100 == "1e2"); // 100 == 100 -&gt; true  

switch ("a") {  
case 0:  
    echo "0";  
    break;  
case "a": // never reached because "a" is already matched with 0  
    echo "a";  
    break;  
}  
?&gt;
</code></pre>
<pre class="prettyprint"><code class="php language-php">&lt;?php    
// Integers  
echo 1 &lt;=&gt; 1; // 0  
echo 1 &lt;=&gt; 2; // -1  
echo 2 &lt;=&gt; 1; // 1  

// Floats  
echo 1.5 &lt;=&gt; 1.5; // 0  
echo 1.5 &lt;=&gt; 2.5; // -1  
echo 2.5 &lt;=&gt; 1.5; // 1  

// Strings  
echo "a" &lt;=&gt; "a"; // 0  
echo "a" &lt;=&gt; "b"; // -1  
echo "b" &lt;=&gt; "a"; // 1  

echo "a" &lt;=&gt; "aa"; // -1  
echo "zz" &lt;=&gt; "aa"; // 1  

// Arrays  
echo [] &lt;=&gt; []; // 0  
echo [1, 2, 3] &lt;=&gt; [1, 2, 3]; // 0  
echo [1, 2, 3] &lt;=&gt; []; // 1  
echo [1, 2, 3] &lt;=&gt; [1, 2, 1]; // 1  
echo [1, 2, 3] &lt;=&gt; [1, 2, 4]; // -1  

// Objects  
$a = (object) ["a" =&gt; "b"];   
$b = (object) ["a" =&gt; "b"];   
echo $a &lt;=&gt; $b; // 0  

$a = (object) ["a" =&gt; "b"];   
$b = (object) ["a" =&gt; "c"];   
echo $a &lt;=&gt; $b; // -1  

$a = (object) ["a" =&gt; "c"];   
$b = (object) ["a" =&gt; "b"];   
echo $a &lt;=&gt; $b; // 1  

// only values are compared  
$a = (object) ["a" =&gt; "b"];   
$b = (object) ["b" =&gt; "b"];   
echo $a &lt;=&gt; $b; // 1  

?&gt;
</code></pre>
<p>对于多种类型,比较运算符根据下表比较(按顺序).</p>
<p><strong>比较多种类型</strong></p>
<p>运算数 1 类型</p>
<p>运算数 2 类型</p>
<p>结果</p>
<p><a href="language.types.null.html">null</a> 或 <a href="language.types.string.html">string</a></p>
<p><a href="language.types.string.html">string</a></p>
<p>将 <strong><code>NULL</code></strong> 转换为 "",进行数字或词汇比较</p>
<p><a href="language.types.boolean.html">bool</a> 或 <a href="language.types.null.html">null</a></p>
<p>任何其它类型</p>
<p>转换为 <a href="language.types.boolean.html">bool</a>,<strong><code>FALSE</code></strong> &lt; <strong><code>TRUE</code></strong></p>
<p><a href="language.types.object.html">object</a></p>
<p><a href="language.types.object.html">object</a></p>
<p>内置类可以定义自己的比较,不同类不能比较,相同类和数组同样方式比较属性(PHP 4 中),PHP 5 有其自己的<a href="language.oop5.object-comparison.html">说明</a></p>
<p><a href="language.types.string.html">string</a>,<a href="language.types.resource.html">resource</a> 或 <a href="language.pseudo-types.html#language.types.number">number</a></p>
<p><a href="language.types.string.html">string</a>,<a href="language.types.resource.html">resource</a> 或 <a href="language.pseudo-types.html#language.types.number">number</a></p>
<p>将字符串和资源转换成数字,按普通数学比较</p>
<p><a href="language.types.array.html">array</a></p>
<p><a href="language.types.array.html">array</a></p>
<p>具有较少成员的数组较小,如果运算数 1 中的键不存在于运算数 2 中则数组无法比较,否则挨个值比较(见下例)</p>
<p><a href="language.types.object.html">object</a></p>
<p>任何其它类型</p>
<p><a href="language.types.object.html">object</a> 总是更大</p>
<p><a href="language.types.array.html">array</a></p>
<p>任何其它类型</p>
<p><a href="language.types.array.html">array</a> 总是更大</p>
<p><strong>Example #1 标准数组比较代码</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
// 数组是用标准比较运算符这样比较的  
function standard_array_compare($op1, $op2)  
{  
    if (count($op1) &lt; count($op2)) {  
        return -1; // $op1 &lt; $op2  
    } elseif (count($op1) &gt; count($op2)) {  
        return 1; // $op1 &gt; $op2  
    }  
    foreach ($op1 as $key =&gt; $val) {  
        if (!array_key_exists($key, $op2)) {  
            return null; // uncomparable  
        } elseif ($val &lt; $op2[$key]) {  
            return -1;  
        } elseif ($val &gt; $op2[$key]) {  
            return 1;  
        }  
    }  
    return 0; // $op1 == $op2  
}  
?&gt;
</code></pre>
<p><strong>Example #2 Transcription of standard array comparison</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
// Arrays are compared like this with standard comparison operators  
function standard_array_compare($op1, $op2)  
{  
    if (count($op1) &lt; count($op2)) {  
        return -1; // $op1 &lt; $op2  
    } elseif (count($op1) &gt; count($op2)) {  
        return 1; // $op1 &gt; $op2  
    }  
    foreach ($op1 as $key =&gt; $val) {  
        if (!array_key_exists($key, $op2)) {  
            return null; // uncomparable  
        } elseif ($val &lt; $op2[$key]) {  
            return -1;  
        } elseif ($val &gt; $op2[$key]) {  
            return 1;  
        }  
    }  
    return 0; // $op1 == $op2  
}  
?&gt;
</code></pre>
<p>参见 <a href="function.strcasecmp.html">strcasecmp()</a>,<a href="function.strcmp.html">strcmp()</a>,<a href="language.operators.array.html">数组运算符</a>和<a href="language.types.html">类型</a>章节.</p>
<p><strong>Warning</strong></p>
<h2 id="比较浮点数">比较浮点数</h2>
<p>由于浮点数 <a href="language.types.float.html">float</a> 的内部表达方式,不应比较两个浮点数<a href="language.types.float.html">float</a>是否相等.</p>
<p>更多信息参见 <a href="language.types.float.html">float</a>.</p>
<h3 id="-1">三元运算符</h3>
<p>另一个条件运算符是"?:"(或三元)运算符 .</p>
<p><strong>Example #3 赋默认值</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
// Example usage for: Ternary Operator  
$action = (empty($_POST['action'])) ? 'default' : $_POST['action'];  

// The above is identical to this if/else statement  
if (empty($_POST['action'])) {  
    $action = 'default';  
} else {  
    $action = $_POST['action'];  
}  

?&gt;
</code></pre>
<p>表达式 <em>(expr1) ? (expr2) : (expr3)</em> 在 expr1 求值为 <strong><code>TRUE</code></strong> 时的值为 expr2,在 expr1 求值为 <strong><code>FALSE</code></strong> 时的值为 expr3.</p>
<p>自 PHP 5.3 起,可以省略三元运算符中间那部分.表达式 <em>expr1 ?: expr3</em> 在 expr1 求值为 <strong><code>TRUE</code></strong> 时返回 expr1,否则返回 expr3.</p>
<blockquote>
  <p><strong>Note</strong>: 注意三元运算符是个语句,因此其求值不是变量,而是语句的结果.如果想通过引用返回一个变量这点就很重要.在一个通过引用返回的函数中语句 <em>return $var == 42 ? $a : $b;</em> 将不起作用,以后的 PHP 版本会为此发出一条警告.</p>
  <p><strong>Note</strong>:</p>
  <p>建议避免将三元运算符堆积在一起使用.当在一条语句中使用多个三元运算符时会造成 PHP 运算结果不清晰:</p>
  <p><strong>Example #4 不清晰的三元运算符行为</strong></p>
</blockquote>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
&gt; // 乍看起来下面的输出是 'true'  
&gt; echo (true?'true':false?'t':'f');  
&gt;   
&gt; // 然而,上面语句的实际输出是't',因为三元运算符是从左往右计算的  
&gt;   
&gt; // 下面是与上面等价的语句,但更清晰  
&gt; echo ((true ? 'true' : 'false') ? 't' : 'f');  
&gt;   
&gt; // here, you can see that the first expression is evaluated to 'true', which  
&gt; // in turn evaluates to (bool)true, thus returning the true branch of the  
&gt; // second ternary expression.  
&gt; ?&gt;
</code></pre>
<h3 id="6_6">6.6 错误控制运算符</h3>
<p>PHP 支持一个错误控制运算符:@.当将其放置在一个 PHP 表达式之前,该表达式可能产生的任何错误信息都被忽略掉.</p>
<p>如果用 <a href="function.set-error-handler.html">set_error_handler()</a> 设定了自定义的错误处理函数,仍然会被调用,但是此错误处理函数可以(并且也应该)调用 <a href="function.error-reporting.html">error_reporting()</a>,而该函数在出错语句前有 @ 时将返回 0.</p>
<p>如果激活了 <a href="errorfunc.configuration.html#ini.track-errors"><strong>track_errors</strong></a> 特性,表达式所产生的任何错误信息都被存放在变量 <a href="reserved.variables.phperrormsg.html">$php_errormsg</a> 中.此变量在每次出错时都会被覆盖,所以如果想用它的话就要尽早检查.</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
/* Intentional file error */  
$my_file = @file ('non_existent_file') or  
    die ("Failed opening file: error was '$php_errormsg'");  

// this works for any expression, not just functions:  
$value = @$cache[$key];  
// will not issue a notice if the index $key doesn't exist.  

?&gt;
</code></pre>
<blockquote>
  <p><strong>Note</strong>: @ 运算符只对<a href="language.expressions.html">表达式</a>有效.对新手来说一个简单的规则就是:如果能从某处得到值,就能在它前面加上 @ 运算符.例如,可以把它放在变量,函数和 <a href="function.include.html">include</a> 调用,常量,等等之前.不能把它放在函数或类的定义之前,也不能用于条件结构例如 <em>if</em> 和 <a href="control-structures.foreach.html">foreach</a> 等.</p>
</blockquote>
<p>参见 <a href="function.error-reporting.html">error_reporting()</a> 及手册中<a href="ref.errorfunc.html">错误处理及日志函数</a>的有关章节.</p>
<p><strong>Warning</strong></p>
<p>目前的"@"错误控制运算符前缀甚至使导致脚本终止的严重错误的错误报告也失效.这意味着如果在某个不存在或者敲错了字母的函数调用前用了"@"来抑制错误信息,那脚本会没有任何迹象显示原因而死在那里.</p>
<h3 id="6_7">6.7 执行运算符</h3>
<p>PHP 支持一个执行运算符:反引号(``).注意这不是单引号!PHP 将尝试将反引号中的内容作为 shell 命令来执行,并将其输出信息返回(即,可以赋给一个变量而不是简单地丢弃到标准输出).使用反引号运算符"`"的效果与函数 <a href="function.shell-exec.html">shell_exec()</a> 相同.</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$output = `ls -al`;  
echo "&lt;pre&gt;$output&lt;/pre&gt;";  
?&gt;
</code></pre>
<blockquote>
  <p><strong>Note</strong>:</p>
  <p>反引号运算符在激活了<a href="ini.sect.safe-mode.html#ini.safe-mode">安全模式</a>或者关闭了 <a href="function.shell-exec.html">shell_exec()</a> 时是无效的.</p>
  <p><strong>Note</strong>:</p>
  <p>与其它某些语言不同,反引号不能在双引号字符串中使用.</p>
</blockquote>
<p>参见手册中<a href="ref.exec.html">程序执行函数</a>,<a href="function.popen.html">popen()</a>,<a href="function.proc-open.html">proc_open()</a> 以及 <a href="features.commandline.html">PHP 的命令行模式</a>.</p>
<h3 id="6_8">6.8 递增/递减运算符</h3>
<p>PHP 支持 C 风格的前/后递增与递减运算符.</p>
<blockquote>
  <p><strong>Note</strong>: 递增/递减运算符不影响布尔值.递减 <strong><code>NULL</code></strong> 值也没有效果,但是递增 <strong><code>NULL</code></strong> 的结果是 <em>1</em>.</p>
</blockquote>
<p><strong>递增/递减运算符</strong></p>
<p>例子</p>
<p>名称</p>
<p>效果</p>
<p>++$a</p>
<p>前加</p>
<p>$a 的值加一,然后返回 $a.</p>
<p>$a++</p>
<p>后加</p>
<p>返回 $a,然后将 $a 的值加一.</p>
<p>--$a</p>
<p>前减</p>
<p>$a 的值减一, 然后返回 $a.</p>
<p>$a--</p>
<p>后减</p>
<p>返回 $a,然后将 $a 的值减一.</p>
<p>一个简单的示例脚本:</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
echo "&lt;h3&gt;Postincrement&lt;/h3&gt;";  
$a = 5;  
echo "Should be 5: " . $a++ . "&lt;br /&gt;\n";  
echo "Should be 6: " . $a . "&lt;br /&gt;\n";  

echo "&lt;h3&gt;Preincrement&lt;/h3&gt;";  
$a = 5;  
echo "Should be 6: " . ++$a . "&lt;br /&gt;\n";  
echo "Should be 6: " . $a . "&lt;br /&gt;\n";  

echo "&lt;h3&gt;Postdecrement&lt;/h3&gt;";  
$a = 5;  
echo "Should be 5: " . $a-- . "&lt;br /&gt;\n";  
echo "Should be 4: " . $a . "&lt;br /&gt;\n";  

echo "&lt;h3&gt;Predecrement&lt;/h3&gt;";  
$a = 5;  
echo "Should be 4: " . --$a . "&lt;br /&gt;\n";  
echo "Should be 4: " . $a . "&lt;br /&gt;\n";  
?&gt;
</code></pre>
<p>在处理字符变量的算数运算时,PHP 沿袭了 Perl 的习惯,而非 C 的.例如,在 Perl 中 <em>$a = 'Z'; $a++;</em> 将把 <em>$a</em> 变成<em>'AA'</em>,而在 C 中,<em>a = 'Z'; a++;</em> 将把 <em>a</em> 变成 <em>'['</em>(<em>'Z'</em> 的 ASCII 值是 90,<em>'['</em> 的 ASCII 值是 91).注意字符变量只能递增,不能递减,并且只支持纯字母(a-z 和 A-Z).递增/递减其他字符变量则无效,原字符串没有变化.</p>
<p><strong>Example #1 涉及字符变量的算数运算</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
echo '== Alphabets ==' . PHP_EOL;  
$s = 'W';  
for ($n=0; $n&lt;6; $n++) {  
    echo ++$s . PHP_EOL;  
}  
// Digit characters behave differently  
echo '== Digits ==' . PHP_EOL;  
$d = 'A8';  
for ($n=0; $n&lt;6; $n++) {  
    echo ++$d . PHP_EOL;  
}  
$d = 'A08';  
for ($n=0; $n&lt;6; $n++) {  
    echo ++$d . PHP_EOL;  
}  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>== Characters ==
X
Y
Z
AA
AB
AC
== Digits ==
A9
B0
B1
B2
B3
B4
A09
A10
A11
A12
A13
A14</p>
<p>递增或递减布尔值没有效果.</p>
<h3 id="6_9">6.9 逻辑运算符</h3>
<p><strong>逻辑运算符</strong></p>
<p>例子</p>
<p>名称</p>
<p>结果</p>
<p>$a and $b</p>
<p>And(逻辑与)</p>
<p><strong><code>TRUE</code></strong>,如果 $a 和 $b 都为 <strong><code>TRUE</code></strong>.</p>
<p>$a or $b</p>
<p>Or(逻辑或)</p>
<p><strong><code>TRUE</code></strong>,如果 $a 或 $b 任一为 <strong><code>TRUE</code></strong>.</p>
<p>$a xor $b</p>
<p>Xor(逻辑异或)</p>
<p><strong><code>TRUE</code></strong>,如果 $a 或 $b 任一为 <strong><code>TRUE</code></strong>,但不同时是.</p>
<p>! $a</p>
<p>Not(逻辑非)</p>
<p><strong><code>TRUE</code></strong>,如果 $a 不为 <strong><code>TRUE</code></strong>.</p>
<p>$a &amp;&amp; $b</p>
<p>And(逻辑与)</p>
<p><strong><code>TRUE</code></strong>,如果 $a 和 $b 都为 <strong><code>TRUE</code></strong>.</p>
<p>$a || $b</p>
<p>Or(逻辑或)</p>
<p><strong><code>TRUE</code></strong>,如果 $a 或 $b 任一为 <strong><code>TRUE</code></strong>.</p>
<p>"与"和"或"有两种不同形式运算符的原因是它们运算的优先级不同(见<a href="language.operators.precedence.html">运算符优先级</a>).</p>
<p><strong>Example #1 逻辑运算符示例</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  

// --------------------  
// foo() 根本没机会被调用,被运算符"短路"了  

$a = (false &amp;&amp; foo());  
$b = (true  || foo());  
$c = (false and foo());  
$d = (true  or  foo());  

// --------------------  
// "||" 比 "or" 的优先级高  

// 表达式 (false || true) 的结果被赋给 $e  
// 等同于:($e = (false || true))  
$e = false || true;  

// 常量 false 被赋给 $f,true 被忽略  
// 等同于:(($f = false) or true)  
$f = false or true;  

var_dump($e, $f);  

// --------------------  
// "&amp;&amp;" 比 "and" 的优先级高  

// 表达式 (true &amp;&amp; false) 的结果被赋给 $g  
// 等同于:($g = (true &amp;&amp; false))  
$g = true &amp;&amp; false;  

// 常量 true 被赋给 $h,false 被忽略  
// 等同于:(($h = true) and false)  
$h = true and false;  

var_dump($g, $h);  
?&gt;
</code></pre>
<p>以上例程的输出类似于:</p>
<p>bool(true)
bool(false)
bool(false)
bool(true)</p>
<h3 id="6_10">6.10 字符串运算符</h3>
<p>有两个字符串(<a href="language.types.string.html">string</a>)运算符.第一个是连接运算符("."),它返回其左右参数连接后的字符串.第二个是连接赋值运算符(".="),它将右边参数附加到左边的参数之后.更多信息见<a href="language.operators.assignment.html">赋值运算符</a>.</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = "Hello ";  
$b = $a . "World!"; // now $b contains "Hello World!"  

$a = "Hello ";  
$a .= "World!";     // now $a contains "Hello World!"  
?&gt;
</code></pre>
<p>参见<a href="language.types.string.html">字符串类型</a>和<a href="ref.strings.html">字符串函数</a>章节.</p>
<h3 id="6_11">6.11 数组运算符</h3>
<p><strong>数组运算符</strong></p>
<p>例子</p>
<p>名称</p>
<p>结果</p>
<p>$a + $b</p>
<p>联合</p>
<p>$a 和 $b 的联合.</p>
<p>$a == $b</p>
<p>相等</p>
<p>如果 $a 和 $b 具有相同的键/值对则为 <strong><code>TRUE</code></strong>.</p>
<p>$a === $b</p>
<p>全等</p>
<p>如果 $a 和 $b 具有相同的键/值对并且顺序和类型都相同则为 <strong><code>TRUE</code></strong>.</p>
<p>$a != $b</p>
<p>不等</p>
<p>如果 $a 不等于 $b 则为 <strong><code>TRUE</code></strong>.</p>
<p>$a &lt;&gt; $b</p>
<p>不等</p>
<p>如果 $a 不等于 $b 则为 <strong><code>TRUE</code></strong>.</p>
<p>$a !== $b</p>
<p>不全等</p>
<p>如果 $a 不全等于 $b 则为 <strong><code>TRUE</code></strong>.</p>
<p><em>+</em> 运算符把右边的数组元素附加到左边的数组后面,两个数组中都有的键名,则只用左边数组中的,右边的被忽略.</p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = array("a" =&gt; "apple", "b" =&gt; "banana");  
$b = array("a" =&gt; "pear", "b" =&gt; "strawberry", "c" =&gt; "cherry");  

$c = $a + $b; // Union of $a and $b  
echo "Union of \$a and \$b: \n";  
var_dump($c);  

$c = $b + $a; // Union of $b and $a  
echo "Union of \$b and \$a: \n";  
var_dump($c);  

$a += $b; // Union of $a += $b is $a and $b  
echo "Union of \$a += \$b: \n";  
var_dump($a);  
?&gt;
</code></pre>
<p>执行后,此脚本会显示:</p>
<p>Union of $a and $b:
array(3) {
  ["a"]=&gt;
  string(5) "apple"
  ["b"]=&gt;
  string(6) "banana"
  ["c"]=&gt;
  string(6) "cherry"
}
Union of $b and $a:
array(3) {
  ["a"]=&gt;
  string(4) "pear"
  ["b"]=&gt;
  string(10) "strawberry"
  ["c"]=&gt;
  string(6) "cherry"
}
Union of $a += $b:
array(3) {
  'a' =&gt;
  string(5) "apple"
  'b' =&gt;
  string(6) "banana"
  'c' =&gt;
  string(6) "cherry"
}</p>
<p>数组中的单元如果具有相同的键名和值则比较时相等.</p>
<p><strong>Example #1 比较数组</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = array("apple", "banana");  
$b = array(1 =&gt; "banana", "0" =&gt; "apple");  

var_dump($a == $b); // bool(true)  
var_dump($a === $b); // bool(false)  
?&gt;
</code></pre>
<p>参见<a href="language.types.array.html">数组类型</a>和<a href="ref.array.html">数组函数</a>章节.</p>
<h3 id="6_12">6.12 类型运算符</h3>
<p><em>instanceof</em> 用于确定一个 PHP 变量是否属于某一类 <a href="language.oop5.basic.html#language.oop5.basic.class">class</a> 的实例:</p>
<p><strong>Example #1 对类使用 <em>instanceof</em></strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
class MyClass  
{  
}  

class NotMyClass  
{  
}  
$a = new MyClass;  

var_dump($a instanceof MyClass);  
var_dump($a instanceof NotMyClass);  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(true)
bool(false)</p>
<p><em>instanceof</em> 也可用来确定一个变量是不是继承自某一父类的子类的实例:</p>
<p><strong>Example #2 对继承类使用 <em>instanceof</em></strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
class ParentClass  
{  
}  

class MyClass extends ParentClass  
{  
}  

$a = new MyClass;  

var_dump($a instanceof MyClass);  
var_dump($a instanceof ParentClass);  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(true)
bool(true)</p>
<p>检查一个对象是否<em>不是</em>某个类的实例,可以使用<a href="language.operators.logical.html">逻辑运算符 <em>not</em></a>.</p>
<p><strong>Example #3 使用 <em>instanceof</em> 检查对象<em>不是</em>某个类的实例</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
class MyClass  
{  
}  

$a = new MyClass;  
var_dump(!($a instanceof stdClass));  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(true)</p>
<p>最后,<em>instanceof</em>也可用于确定一个变量是不是实现了某个<a href="language.oop5.interfaces.html">接口</a>的对象的实例:</p>
<p><strong>Example #4 对接口使用 <em>instanceof</em></strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
interface MyInterface  
{  
}  

class MyClass implements MyInterface  
{  
}  

$a = new MyClass;  

var_dump($a instanceof MyClass);  
var_dump($a instanceof MyInterface);  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(true)
bool(true)</p>
<p>虽然 <em>instanceof</em> 通常直接与类名一起使用,但也可以使用对象或字符串变量:</p>
<p><strong>Example #5 对其它变量使用 <em>instanceof</em></strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
interface MyInterface  
{  
}  

class MyClass implements MyInterface  
{  
}  

$a = new MyClass;  
$b = new MyClass;  
$c = 'MyClass';  
$d = 'NotMyClass';  

var_dump($a instanceof $b); // $b is an object of class MyClass  
var_dump($a instanceof $c); // $c is a string 'MyClass'  
var_dump($a instanceof $d); // $d is a string 'NotMyClass'  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(true)
bool(true)
bool(false)</p>
<p>如果被检测的变量不是对象,instanceof 并不发出任何错误信息而是返回 <strong><code>FALSE</code></strong>.不允许用来检测常量.</p>
<p><strong>Example #6 用 <em>instanceof</em> 检测其它变量</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$a = 1;  
$b = NULL;  
$c = imagecreate(5, 5);  
var_dump($a instanceof stdClass); // $a is an integer  
var_dump($b instanceof stdClass); // $b is NULL  
var_dump($c instanceof stdClass); // $c is a resource  
var_dump(FALSE instanceof stdClass);  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(false)
bool(false)
bool(false)
PHP Fatal error:  instanceof expects an object instance, constant given</p>
<p>然而 instanceof 的使用还有一些陷阱必须了解.在 PHP 5.1.0 之前,如果要检查的类名称不存在,<em>instanceof</em> 会调用 <a href="function.autoload.html">__autoload()</a>.另外,如果该类没有被装载则会产生一个致命错误.可以通过使用动态类引用或用一个包含类名的字符串变量来避开这种问题:</p>
<p><strong>Example #7 避免 PHP 5.0 中 instanceof 引起的类名查找和致命错误问题</strong></p>
<pre class="prettyprint"><code class="php language-php">&lt;?php  
$d = 'NotMyClass';  
var_dump($a instanceof $d); // no fatal error here  
?&gt;
</code></pre>
<p>以上例程会输出:</p>
<p>bool(false)</p>
<p><em>instanceof</em> 运算符是 PHP 5 引进的.在此之前用 <a href="function.is-a.html">is_a()</a>,但是后来 <a href="function.is-a.html">is_a()</a> 被废弃而用 <em>instanceof</em> 替代了.注意自 PHP 5.3.0 起,又恢复使用 <a href="function.is-a.html">is_a()</a> 了.</p>
<p>参见 <a href="function.get-class.html">get_class()</a> 和 <a href="function.is-a.html">is_a()</a>.</p>