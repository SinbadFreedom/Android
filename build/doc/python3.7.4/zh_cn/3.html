<h1 id="3_">3. Python 的非正式介绍</h1>
<p>在下面的例子中,通过提示符 (<code>&gt;&gt;&gt;</code> 与 <code>...</code>) 的出现与否来区分输入和输出:如果你想复现这些例子,当提示符出现后,你必须在提示符后键入例子中的每一个词;不以提示符开头的那些行是解释器的输出.注意例子中某行中出现第二个提示符意味着你必须键入一个空白行;这是用来结束多行命令的.</p>
<p>这个手册中的许多例子都包含注释,甚至交互性命令中也有.Python中的注释以井号 # 开头,并且一直延伸到该文本行结束为止.注释可以出现在一行的开头或者是空白和代码的后边,但是不能出现在字符串中间.字符串中的井号就是井号.因为注释是用来阐明代码的,不会被 Python 解释,所以在键入这些例子时,注释是可以被忽略的.</p>
<p>几个例子:</p>
<pre class="prettyprint"><code># this is the first comment
spam = 1  # and this is the second comment
          # ... and now a third!
text = "# This is not a comment because it's inside quotes."
</code></pre>
<h2 id="3_1_">3.1. Python 作为计算器使用</h2>
<p>让我们尝试一些简单的 Python 命令.启动解释器,等待界面中的提示符,<code>&gt;&gt;&gt;</code> (这应该花不了多少时间).</p>
<h3 id="3_1_1_">3.1.1. 数字</h3>
<p>解释器就像一个简单的计算器一样:你可以在里面输入一个表达式然后它会写出答案. 表达式的语法很直接:运算符 <code>+</code>,<code>-</code>,<code>*</code>,<code>/</code> 的用法和其他大部分语言一样(比如 Pascal 或者 C 语言);括号 (<code>()</code>) 用来分组.比如:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 2 + 2
4
&gt;&gt;&gt; 50 - 5*6
20
&gt;&gt;&gt; (50 - 5*6) / 4
5.0
&gt;&gt;&gt; 8 / 5  # division always returns a floating point number
1.6
</code></pre>
<p>整数(比如 <code>2</code>,<code>4</code>,<code>20</code> )有 <code>int</code> 类型,有小数部分的(比如 <code>5.0</code>,<code>1.6</code> )有 float 类型.在这个手册的后半部分我们会看到更多的数值类型.</p>
<p>除法运算 (<code>/</code>) 永远返回浮点数类型.如果要做 floor division 得到一个整数结果(忽略小数部分)你可以使用 <code>//</code> 运算符;如果要计算余数,可以使用 <code>%</code></p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 17 / 3  # classic division returns a float
5.666666666666667
&gt;&gt;&gt;
&gt;&gt;&gt; 17 // 3  # floor division discards the fractional part
5
&gt;&gt;&gt; 17 % 3  # the % operator returns the remainder of the division
2
&gt;&gt;&gt; 5 * 3 + 2  # result * divisor + remainder
17
</code></pre>
<p>在Python中,可以使用 ** 运算符来计算乘方 [1]</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 5 ** 2  # 5 squared
25
&gt;&gt;&gt; 2 ** 7  # 2 to the power of 7
128
</code></pre>
<p>等号 (<code>=</code>) 用于给一个变量赋值.然后在下一个交互提示符之前不会有结果显示出来:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; width = 20
&gt;&gt;&gt; height = 5 * 9
&gt;&gt;&gt; width * height
900
</code></pre>
<p>如果一个变量未定义(未赋值),试图使用它时会向你提示错误:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; n  # try to access an undefined variable
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
NameError: name 'n' is not defined
</code></pre>
<p>Python中提供浮点数的完整支持;包含多种混合类型运算数的运算会把整数转换为浮点数:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 4 * 3.75 - 1
14.0
</code></pre>
<p>在交互模式下,上一次打印出来的表达式被赋值给变量 _.这意味着当你把Python用作桌面计算器时,继续计算会相对简单,比如:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; tax = 12.5 / 100
&gt;&gt;&gt; price = 100.50
&gt;&gt;&gt; price * tax
12.5625
&gt;&gt;&gt; price + _
113.0625
&gt;&gt;&gt; round(_, 2)
113.06
</code></pre>
<p>这个变量应该被使用者当作是只读类型.不要向它显式地赋值--你会创建一个和它名字相同独立的本地变量,它会使用魔法行为屏蔽内部变量.</p>
<p>除了 <code>int</code> 和 <code>float</code>,Python也支持其他类型的数字,例如 Decimal 或者 Fraction.Python 也内置对 复数 的支持,使用后缀 <code>j</code> 或者 <code>J</code> 就可以表示虚数部分(例如 <code>3+5j</code> ).</p>
<h3 id="3_1_2_">3.1.2. 字符串</h3>
<p>除了数字,Python 也可以操作字符串.字符串有多种形式,可以使用单引号(<code>'……'</code>),双引号(<code>"……"</code>)都可以获得同样的结果 [2].反斜杠 <code>\</code> 可以用来转义:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 'spam eggs'  # single quotes
'spam eggs'
&gt;&gt;&gt; 'doesn\'t'  # use \' to escape the single quote...
"doesn't"
&gt;&gt;&gt; "doesn't"  # ...or use double quotes instead
"doesn't"
&gt;&gt;&gt; '"Yes," they said.'
'"Yes," they said.'
&gt;&gt;&gt; "\"Yes,\" they said."
'"Yes," they said.'
&gt;&gt;&gt; '"Isn\'t," they said.'
'"Isn\'t," they said.'
</code></pre>
<p>在交互式解释器中,输出的字符串外面会加上引号,特殊字符会使用反斜杠来转义. 虽然有时这看起来会与输入不一样(外面所加的引号可能会改变),但两个字符串是相同的. 如果字符串中有单引号而没有双引号,该字符串外将加双引号来表示,否则就加单引号. print() 函数会生成可读性更强的输出,即略去两边的引号,并且打印出经过转义的特殊字符:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; '"Isn\'t," they said.'
'"Isn\'t," they said.'
&gt;&gt;&gt; print('"Isn\'t," they said.')
"Isn't," they said.
&gt;&gt;&gt; s = 'First line.\nSecond line.'  # \n means newline
&gt;&gt;&gt; s  # without print(), \n is included in the output
'First line.\nSecond line.'
&gt;&gt;&gt; print(s)  # with print(), \n produces a new line
First line.
Second line.
</code></pre>
<p>如果你不希望前置了 <code>\</code> 的字符转义成特殊字符,可以使用 <em>原始字符串</em> 方式,在引号前添加 <code>r</code> 即可:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; print('C:\some\name')  # here \n means newline!
C:\some
ame
&gt;&gt;&gt; print(r'C:\some\name')  # note the r before the quote
C:\some\name
</code></pre>
<p>字符串字面值可以跨行连续输入.一种方式是用三重引号:"""…""" 或 '''…'''.字符串中的回车换行会自动包含到字符串中,如果不想包含,在行尾添加一个 <code>\</code> 即可.如下例:</p>
<pre class="prettyprint"><code>print("""\
Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
""")
</code></pre>
<p>将产生如下输出(注意最开始的换行没有包括进来):</p>
<pre class="prettyprint"><code>Usage: thingy [OPTIONS]
     -h                        Display this usage message
     -H hostname               Hostname to connect to
</code></pre>
<p>字符串可以用 <code>+</code> 进行连接(粘到一起),也可以用 <code>*</code> 进行重复:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; # 3 times 'un', followed by 'ium'
&gt;&gt;&gt; 3 * 'un' + 'ium'
'unununium'
</code></pre>
<p>相邻的两个或多个 <em>字符串字面值</em> (引号引起来的字符)将会自动连接到一起.</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 'Py' 'thon'
'Python'
</code></pre>
<p>把很长的字符串拆开分别输入的时候尤其有用:</p>
<pre class="prettyprint"><code>&gt;&gt; text = ('Put several strings within parentheses '
...         'to have them joined together.')
&gt;&gt;&gt; text
'Put several strings within parentheses to have them joined together.'
</code></pre>
<p>只能对两个字面值这样操作,变量或表达式不行:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; prefix = 'Py'
&gt;&gt;&gt; prefix 'thon'  # can't concatenate a variable and a string literal
  File "&lt;stdin&gt;", line 1
    prefix 'thon'
                ^
SyntaxError: invalid syntax
&gt;&gt;&gt; ('un' * 3) 'ium'
  File "&lt;stdin&gt;", line 1
    ('un' * 3) 'ium'
                   ^
SyntaxError: invalid syntax
</code></pre>
<p>如果你想连接变量,或者连接变量和字面值,可以用 <code>+</code> 号:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; prefix + 'thon'
'Python'
</code></pre>
<p>字符串是可以被 <em>索引</em> (下标访问)的,第一个字符索引是 0.单个字符并没有特殊的类型,只是一个长度为一的字符串:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word = 'Python'
&gt;&gt;&gt; word[0]  # character in position 0
'P'
&gt;&gt;&gt; word[5]  # character in position 5
'n'
</code></pre>
<p>索引也可以用负数,这种会从右边开始数:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[-1]  # last character
'n'
&gt;&gt;&gt; word[-2]  # second-last character
'o'
&gt;&gt;&gt; word[-6]
'P'
</code></pre>
<p>注意 -0 和 0 是一样的,所以负数索引从 -1 开始.</p>
<p>除了索引,字符串还支持 <em>切片</em>.索引可以得到单个字符,而 <em>切片</em> 可以获取子字符串:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[0:2]  # characters from position 0 (included) to 2 (excluded)
'Py'
&gt;&gt;&gt; word[2:5]  # characters from position 2 (included) to 5 (excluded)
'tho'
</code></pre>
<p>注意切片的开始总是被包括在结果中,而结束不被包括.这使得 <code>s[:i] + s[i:]</code> 总是等于 <code>s</code></p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[:2] + word[2:]
'Python'
&gt;&gt;&gt; word[:4] + word[4:]
'Python'
</code></pre>
<p>切片的索引有默认值;省略开始索引时默认为0,省略结束索引时默认为到字符串的结束:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[:2]   # character from the beginning to position 2 (excluded)
'Py'
&gt;&gt;&gt; word[4:]   # characters from position 4 (included) to the end
'on'
&gt;&gt;&gt; word[-2:]  # characters from the second-last (included) to the end
'on'
</code></pre>
<p>您也可以这么理解切片:将索引视作指向字符 之间 ,第一个字符的左侧标为0,最后一个字符的右侧标为 n ,其中 n 是字符串长度.例如:</p>
<pre class="prettyprint"><code>+---+---+---+---+---+---+
| P | y | t | h | o | n |
+---+---+---+---+---+---+
0   1   2   3   4   5   6
</code></pre>
<p>-6  -5  -4  -3  -2  -1</p>
<p>第一行数标注了字符串非负的索引的位置,第二行标注了对应的负的索引.那么从 <em>i</em> 到 <em>j</em> 的切片就包括了标有 <em>i</em> 和 <em>j</em> 的位置之间的所有字符.</p>
<p>对于使用非负索引的切片,如果索引不越界,那么得到的切片长度就是起止索引之差.例如, <code>word[1:3]</code> 的长度为2.</p>
<p>使用过大的索引会产生一个错误:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[42]  # the word only has 6 characters
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
IndexError: string index out of range
</code></pre>
<p>但是,切片中的越界索引会被自动处理:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[4:42]
'on'
&gt;&gt;&gt; word[42:]
''
</code></pre>
<p>Python 中的字符串不能被修改,它们是 immutable 的.因此,向字符串的某个索引位置赋值会产生一个错误:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; word[0] = 'J'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
&gt;&gt;&gt; word[2:] = 'py'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: 'str' object does not support item assignment
</code></pre>
<p>如果需要一个不同的字符串,应当新建一个:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; 'J' + word[1:]
'Jython'
&gt;&gt;&gt; word[:2] + 'py'
'Pypy'
</code></pre>
<p>内建函数 len() 返回一个字符串的长度:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; s = 'supercalifragilisticexpialidocious'
&gt;&gt;&gt; len(s)
34
</code></pre>
<p>参见:</p>
<p>文本序列类型 --- str
     字符串是一种 <em>序列类型</em> ,因此也支持序列类型的各种操作.</p>
<p>字符串的方法
     字符串支持许多变换和查找的方法.</p>
<p>格式字符串语法
    内嵌表达式的字符串字面值.</p>
<p>格式字符串语法
     使用 str.format() 进行字符串格式化.</p>
<p>printf 风格的字符串格式化
     这里详述了使用 <code>%</code> 运算符进行字符串格式化.</p>
<h3 id="3_1_3_">3.1.3. 列表</h3>
<p>Python 中可以通过组合一些值得到多种 <em>复合</em> 数据类型.其中最常用的 <em>列表</em> ,可以通过方括号括起,逗号分隔的一组值得到.一个 <em>列表</em> 可以包含不同类型的元素,但通常使用时各个元素类型相同:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; squares = [1, 4, 9, 16, 25]
&gt;&gt;&gt; squares
[1, 4, 9, 16, 25]
</code></pre>
<p>和字符串(以及各种内置的 sequence 类型)一样,列表也支持索引和切片:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; squares[0]  # indexing returns the item
1
&gt;&gt;&gt; squares[-1]
25
&gt;&gt;&gt; squares[-3:]  # slicing returns a new list
[9, 16, 25]
</code></pre>
<p>所有的切片操作都返回一个新列表,这个新列表包含所需要的元素.就是说,如下的切片会返回列表的一个新的(浅)拷贝:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; squares[:]
[1, 4, 9, 16, 25]
</code></pre>
<p>列表同样支持拼接操作:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; squares + [36, 49, 64, 81, 100]
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]
</code></pre>
<p>与 immutable 的字符串不同, 列表是一个 mutable 类型,就是说,它自己的内容可以改变:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; cubes = [1, 8, 27, 65, 125]  # something's wrong here
&gt;&gt;&gt; 4 ** 3  # the cube of 4 is 64, not 65!
64
&gt;&gt;&gt; cubes[3] = 64  # replace the wrong value
&gt;&gt;&gt; cubes
[1, 8, 27, 64, 125]
</code></pre>
<p>你也可以在列表结尾,通过 <code>append()</code> <em>方法</em> 添加新元素 (我们会在后面解释更多关于方法的内容):</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; cubes.append(216)  # add the cube of 6
&gt;&gt;&gt; cubes.append(7 ** 3)  # and the cube of 7
&gt;&gt;&gt; cubes
[1, 8, 27, 64, 125, 216, 343]
</code></pre>
<p>给切片赋值也是可以的,这样甚至可以改变列表大小,或者把列表整个清空:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
&gt;&gt;&gt; letters
['a', 'b', 'c', 'd', 'e', 'f', 'g']
&gt;&gt;&gt; # replace some values
&gt;&gt;&gt; letters[2:5] = ['C', 'D', 'E']
&gt;&gt;&gt; letters
['a', 'b', 'C', 'D', 'E', 'f', 'g']
&gt;&gt;&gt; # now remove them
&gt;&gt;&gt; letters[2:5] = []
&gt;&gt;&gt; letters
['a', 'b', 'f', 'g']
&gt;&gt;&gt; # clear the list by replacing all the elements with an empty list
&gt;&gt;&gt; letters[:] = []
&gt;&gt;&gt; letters
[]
</code></pre>
<p>内置函数 len() 也可以作用到列表上:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; letters = ['a', 'b', 'c', 'd']
&gt;&gt;&gt; len(letters)
4
</code></pre>
<p>也可以嵌套列表 (创建包含其他列表的列表), 比如说:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; a = ['a', 'b', 'c']
&gt;&gt;&gt; n = [1, 2, 3]
&gt;&gt;&gt; x = [a, n]
&gt;&gt;&gt; x
[['a', 'b', 'c'], [1, 2, 3]]
&gt;&gt;&gt; x[0]
['a', 'b', 'c']
&gt;&gt;&gt; x[0][1]
'b'
</code></pre>
<h2 id="3_2_">3.2. 走向编程的第一步</h2>
<p>当然,我们可以将 Python 用于更复杂的任务,而不是仅仅两个和两个一起添加. 例如,我们可以编写 斐波那契数列 的初始子序列,如下所示:</p>
<pre class="prettyprint"><code>&gt;&gt;&gt; # Fibonacci series:
... # the sum of two elements defines the next
... a, b = 0, 1
&gt;&gt;&gt; while a &lt; 10:
...     print(a)
...     a, b = b, a+b
...
0
1
1
2
3
5
8
</code></pre>
<p>这个例子引入了几个新的特点.</p>
<ul>
<li><p>第一行含有一个 <em>多重赋值</em>: 变量 <code>a</code> 和 <code>b</code> 同时得到了新值 0 和 1. 最后一行又用了一次多重赋值, 这体现出了右手边的表达式,在任何赋值发生之前就被求值了.右手边的表达式是从左到右被求值的.</p></li>
<li><p>while 循环只要它的条件(这里指: <code>a &lt; 10</code>)保持为真就会一直执行.Python 和 C 一样,任何非零整数都为真;零为假.这个条件也可以是字符串或是列表的值,事实上任何序列都可以;长度非零就为真,空序列就为假.在这个例子里,判断条件是一个简单的比较.标准的比较操作符的写法和 C 语言里是一样: <code>&lt;</code> (小于), <code>&gt;</code> (大于), <code>==</code> (等于), <code>&lt;=</code>(小于或等于), <code>&gt;=</code> (大于或等于)以及 <code>!=</code> (不等于).</p></li>
<li><p><em>循环体</em> 是 <em>缩进的</em> :缩进是 Python 组织语句的方式.在交互式命令行里,你得给每个缩进的行敲下 Tab 键或者(多个)空格键.实际上用文本编辑器的话,你要准备更复杂的输入方式;所有像样的文本编辑器都有自动缩进的设置.交互式命令行里,当一个组合的语句输入时, 需要在最后敲一个空白行表示完成(因为语法分析器猜不出来你什么时候打的是最后一行).注意,在同一块语句中的每一行,都要缩进相同的长度.</p></li>
<li><p>print() 函数将所有传进来的参数值打印出来. 它和直接输入你要显示的表达式(比如我们之前在计算器的例子里做的)不一样, print() 能处理多个参数,包括浮点数,字符串. 字符串会打印不带引号的内容, 并且在参数项之间会插入一个空格, 这样你就可以很好的把东西格式化, 像这样:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>i = 256*256
      print('The value of i is', i)
      The value of i is 65536</p>
    </blockquote>
  </blockquote>
</blockquote></li>
<li><p>关键字参数 <code>end</code> 可以用来取消输出后面的换行, 或是用另外一个字符串来结尾:</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>a, b = 0, 1
      while a &lt; 1000:
      …     print(a, end=',')
      …     a, b = b, a+b
      …
      0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,</p>
    </blockquote>
  </blockquote>
</blockquote></li>
</ul>
<p>脚注</p>
<p>[1] 因为 <code>**</code> 比 <code>-</code> 有更高的优先级, 所以 <code>-3**2</code>会被解释成 <code>-(3**2)</code> ,因此结果是 <code>-9</code>. 为了避免这个并且得到结果 <code>9</code>, 你可以用这个式子 <code>(-3)**2</code>.</p>
<p>[2] 和其他语言不一样的是, 特殊字符比如说 <code>\n</code> 在单引号 (<code>'...'</code>) 和双引号 (<code>"..."</code>) 里有一样的意义. 这两种引号唯一的区别是,你不需要在单引号里转义双引号 <code>"</code> (但是你必须把单引号转义成 <code>\'</code>) , 反之亦然.</p>